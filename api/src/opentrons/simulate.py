"""
An easy entrypoint for simulating a protocol offline.
"""

import argparse
import json
import sys
import logging
import queue
from typing import Any, List, Mapping

import opentrons
import opentrons.protocols
import opentrons.commands


class AccumulatingHandler(logging.Handler):
    def __init__(self, level, command_queue):
        """ Create the handler

        :param level: The logging level to capture
        :param command_queue: The queue.Queue to use for messages
        """
        self._command_queue = command_queue
        super().__init__(level)

    def emit(self, record):
        self._command_queue.put(record)


def simulate(protocol_file,
             propagate_logs=False,
             log_level='warning') -> List[Mapping[str, Any]]:
    """
    Simulate the protocol itself.

    This is a one-stop function to simulate a protocol, whether python or json,
    no matter the api version, from external (i.e. not bound up in other
    internal server infrastructure) sources.

    To simulate an opentrons protocol from other places, pass in a file like
    object as protocol_file; this function either returns (if the simulation
    has no problems) or raises an exception.

    To call from the command line use either the autogenerated entrypoint
    opentrons_simulate(.exe, on windows) or python -m opentrons.simulate.

    The return value is the run log, a list of dicts that represent the
    commands executed by the robot. Each dict has the following keys:

        - ``level``: The depth at which this command is nested - if this an
                     aspirate inside a mix inside a transfer, for instance,
                     it would be 3.
        - ``payload``: The command, its arguments, and how to format its text.
                       For more specific details see
                       :py:mod:`opentrons.commands`. To format a message from
                       a payload do ``payload['text'].format(**payload)``.
        - ``logs``: Any log messages that occurred during execution of this
                    command, as a logging.LogRecord

    :param file-like protocol_file: The protocol file to simulate.
    :param propagate_logs: Whether this function should allow logs from the
                           Opentrons stack to propagate up to the root handler.
                           This can be useful if you're integrating this
                           function in a larger application, but most logs that
                           occur during protocol simulation are best associated
                           with the actions in the protocol that cause them.
    :param log_level: The level of logs to capture in the runlog
    :returns List[Dict[str, str]]: A run log for user output.
    """
    stack_logger = logging.getLogger('opentrons')
    stack_logger.propagate = propagate_logs
    log_queue = queue.Queue()  # type: ignore
    stack_logger.addHandler(
        AccumulatingHandler(
            getattr(logging, log_level.upper(), logging.WARNING),
            log_queue))

    contents = protocol_file.read()
    depth = 0
    commands = []

    def command_scraper(message):
        nonlocal depth
        payload = message['payload']
        if message['$'] == 'before':
            commands.append({'level': depth,
                             'payload': payload,
                             'logs': []})
            depth += 1
        else:
            while not log_queue.empty():
                commands[-1]['logs'].append(log_queue.get())
            depth = max(depth-1, 0)

    if opentrons.config.feature_flags.use_protocol_api_v2():
        try:
            execute_args = {'protocol_json': json.loads(contents)}
        except json.JSONDecodeError:
            execute_args = {'protocol_code': contents}
        context = opentrons.protocol_api.context.ProtocolContext()
        unsub = context.broker.subscribe(
            opentrons.commands.command_types.COMMAND,
            command_scraper)
        context.home()
        execute_args['simulate'] = True
        while not log_queue.empty():
            log_queue.get()
        opentrons.protocol_api.execute.run_protocol(**execute_args)
    else:
        try:
            proto = json.loads(contents)
        except json.JSONDecodeError:
            proto = contents
        opentrons.robot.disconnect()
        unsub = opentrons.robot.broker.subscribe(
            opentrons.commands.command_types.COMMAND,
            command_scraper)
        while not log_queue.empty():
            log_queue.get()
        if isinstance(proto, dict):
            opentrons.protocols.execute_protocol(proto)
        else:
            exec(proto, {})
    unsub()
    return commands


def format_runlog(runlog: List[Mapping[str, Any]]) -> str:
    """
    Format a run log (return value of simulate) into a human-readable string

    :param runlog: The output of a call to :py:func:`simulate`
    """
    to_ret = []
    for command in runlog:
        to_ret.append(
            '\t' * command['level']
            + command['payload'].get('text', '').format(**command['payload']))
        if command['logs']:
            to_ret.append('\t' * command['level'] + 'Logs from this command:')
            to_ret.extend(
                ['\t' * command['level']
                 + f'{l.levelname} ({l.module}): {l.msg}' % l.args
                 for l in command['logs']])
    return '\n'.join(to_ret)


# Note - this script is also set up as a setuptools entrypoint and thus does
# an absolute minimum of work since setuptools does something odd generating
# the scripts
def main():
    """ Run the simulation """
    parser = argparse.ArgumentParser(prog='opentrons_simulate',
                                     description=__doc__)
    parser.add_argument(
        'protocol', metavar='PROTOCOL_FILE',
        type=argparse.FileType('r'),
        help='The protocol file to simulate (specify - to read from stdin).')
    parser.add_argument(
        '-v', '--version', action='version',
        version=f'%(prog)s {opentrons.__version__}',
        help='Print the opentrons package version and exit')
    parser.add_argument(
        '-o', '--output', action='store',
        help='What to output during simulations',
        choices=['runlog', 'nothing'],
        default='runlog')
    parser.add_argument(
        '-l', '--log-level', action='store',
        help=('Log level for the opentrons stack. Anything below warning '
              'can be chatty'),
        choices=['error', 'warning', 'info', 'debug'],
        default='warning'
    )
    args = parser.parse_args()

    runlog = simulate(args.protocol, log_level=args.log_level)
    if args.output == 'runlog':
        print(format_runlog(runlog))
    return 0


if __name__ == '__main__':
    sys.exit(main())
