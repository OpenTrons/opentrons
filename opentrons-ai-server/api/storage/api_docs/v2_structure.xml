<directory name="v2"><directory name="basic_commands"><file name="liquids.rst" type="rst"><content>:og:description: Basic commands for working with liquids. .. _liquid-control: ************** Liquid Control ************** After attaching a tip, your robot is ready to aspirate, dispense, and perform other liquid handling tasks. The API includes methods that help you perform these actions and the following sections show how to use them. The examples used here assume that you&apos;ve loaded the pipettes and labware from the basic :ref:`protocol template &amp;lt;protocol-template&amp;gt;`. .. _new-aspirate: Aspirate ======== To draw liquid up into a pipette tip, call the :py:meth:`.InstrumentContext.aspirate` method. Using this method, you can specify the aspiration volume in µL, the well location, and pipette flow rate. Other parameters let you position the pipette within a well. For example, this snippet tells the robot to aspirate 200 µL from well location A1. .. code-block:: python pipette.pick_up_tip() pipette.aspirate(200, plate[&quot;A1&quot;]) If the pipette doesn&apos;t move, you can specify an additional aspiration action without including a location. To demonstrate, this code snippet pauses the protocol, automatically resumes it, and aspirates a second time from ``plate[&quot;A1&quot;]``). .. code-block:: python pipette.pick_up_tip() pipette.aspirate(200, plate[&quot;A1&quot;]) protocol.delay(seconds=5) # pause for 5 seconds pipette.aspirate(100) # aspirate 100 µL at current position Now our pipette holds 300 µL. Aspirate by Well or Location ---------------------------- The :py:meth:`~.InstrumentContext.aspirate` method includes a ``location`` parameter that accepts either a :py:class:`.Well` or a :py:class:`~.types.Location`. If you specify a well, like ``plate[&quot;A1&quot;]``, the pipette will aspirate from a default position 1 mm above the bottom center of that well. To change the default clearance, first set the ``aspirate`` attribute of :py:obj:`.well_bottom_clearance`:: pipette.pick_up_tip pipette.well_bottom_clearance.aspirate = 2 # tip is 2 mm above well bottom pipette.aspirate(200, plate[&quot;A1&quot;]) You can also aspirate from a location along the center vertical axis within a well using the :py:meth:`.Well.top` and :py:meth:`.Well.bottom` methods. These methods move the pipette to a specified distance relative to the top or bottom center of a well:: pipette.pick_up_tip() depth = plate[&quot;A1&quot;].bottom(z=2) # tip is 2 mm above well bottom pipette.aspirate(200, depth) See also: - :ref:`new-default-op-positions` for information about controlling pipette height for a particular pipette. - :ref:`position-relative-labware` for information about controlling pipette height from within a well. - :ref:`move-to` for information about moving a pipette to any reachable deck location. Aspiration Flow Rates --------------------- Flex and OT-2 pipettes aspirate at :ref:`default flow rates &amp;lt;new-plunger-flow-rates&amp;gt;` measured in µL/s. Specifying the ``rate`` parameter multiplies the flow rate by that value. As a best practice, don&apos;t set the flow rate higher than 3x the default. For example, this code causes the pipette to aspirate at twice its normal rate:: pipette.aspirate(200, plate[&quot;A1&quot;], rate=2.0) .. versionadded:: 2.0 .. _new-dispense: Dispense ======== To dispense liquid from a pipette tip, call the :py:meth:`.InstrumentContext.dispense` method. Using this method, you can specify the dispense volume in µL, the well location, and pipette flow rate. Other parameters let you position the pipette within a well. For example, this snippet tells the robot to dispense 200 µL into well location B1. .. code-block:: python pipette.dispense(200, plate[&quot;B1&quot;]) .. note:: In API version 2.16 and earlier, you could pass a ``volume`` argument to ``dispense()`` greater than what was aspirated into the pipette. In this case, the API would ignore ``volume`` and dispense the pipette&apos;s :py:obj:`~.InstrumentContext.current_volume`. The robot *would not* move the plunger lower as a result. In version 2.17 and later, passing such values raises an error. To move the plunger a small extra amount, add a :ref:`push out &amp;lt;push-out-dispense&amp;gt;`. Or to move it a large amount, use :ref:`blow out &amp;lt;blow-out&amp;gt;`. If the pipette doesn’t move, you can specify an additional dispense action without including a location. To demonstrate, this code snippet pauses the protocol, automatically resumes it, and dispense a second time from location B1. .. code-block:: python pipette.dispense(100, plate[&quot;B1&quot;]) protocol.delay(seconds=5) # pause for 5 seconds pipette.dispense(100) # dispense 100 µL at current position Dispense by Well or Location ---------------------------- The :py:meth:`~.InstrumentContext.dispense` method includes a ``location`` parameter that accepts either a :py:class:`.Well` or a :py:class:`~.types.Location`. If you specify a well, like ``plate[&quot;B1&quot;]``, the pipette will dispense from a default position 1 mm above the bottom center of that well. To change the default clearance, you would call :py:obj:`.well_bottom_clearance`:: pipette.well_bottom_clearance.dispense=2 # tip is 2 mm above well bottom pipette.dispense(200, plate[&quot;B1&quot;]) You can also dispense from a location along the center vertical axis within a well using the :py:meth:`.Well.top` and :py:meth:`.Well.bottom` methods. These methods move the pipette to a specified distance relative to the top or bottom center of a well:: depth = plate[&quot;B1&quot;].bottom(z=2) # tip is 2 mm above well bottom pipette.dispense(200, depth) See also: - :ref:`new-default-op-positions` for information about controlling pipette height for a particular pipette. - :ref:`position-relative-labware` for formation about controlling pipette height from within a well. - :ref:`move-to` for information about moving a pipette to any reachable deck location. Dispense Flow Rates ------------------- Flex and OT-2 pipettes dispense at :ref:`default flow rates &amp;lt;new-plunger-flow-rates&amp;gt;` measured in µL/s. Adding a number to the ``rate`` parameter multiplies the flow rate by that value. As a best practice, don&apos;t set the flow rate higher than 3x the default. For example, this code causes the pipette to dispense at twice its normal rate:: pipette.dispense(200, plate[&quot;B1&quot;], rate=2.0) .. versionadded:: 2.0 .. _push-out-dispense: Push Out After Dispense ----------------------- The optional ``push_out`` parameter of ``dispense()`` helps ensure all liquid leaves the tip. Use ``push_out`` for applications that require moving the pipette plunger lower than the default, without performing a full :ref:`blow out &amp;lt;blow-out&amp;gt;`. For example, this dispense action moves the plunger the equivalent of an additional 5 µL beyond where it would stop if ``push_out`` was set to zero or omitted:: pipette.pick_up_tip() pipette.aspirate(100, plate[&quot;A1&quot;]) pipette.dispense(100, plate[&quot;B1&quot;], push_out=5) pipette.drop_tip() .. versionadded:: 2.15 .. _new-blow-out: .. _blow-out: Blow Out ======== To blow an extra amount of air through the pipette&apos;s tip, call the :py:meth:`.InstrumentContext.blow_out` method. You can use a specific well in a well plate or reservoir as the blowout location. If no location is specified, the pipette will blowout from its current well position:: pipette.blow_out() You can also specify a particular well as the blowout location:: pipette.blow_out(plate[&quot;B1&quot;]) Many protocols use a trash container for blowing out the pipette. You can specify the pipette&apos;s current trash container as the blowout location by using the :py:obj:`.InstrumentContext.trash_container` property:: pipette.blow_out(pipette.trash_container) .. versionadded:: 2.0 .. versionchanged:: 2.16 Added support for ``TrashBin`` and ``WasteChute`` locations. .. _touch-tip: Touch Tip ========= The :py:meth:`.InstrumentContext.touch_tip` method moves the pipette so the tip touches each wall of a well. A touch tip procedure helps knock off any droplets that might cling to the pipette&apos;s tip. This method includes optional arguments that allow you to control where the tip will touch the inner walls of a well and the touch speed. Calling :py:meth:`~.InstrumentContext.touch_tip` without arguments causes the pipette to touch the well walls from its current location:: pipette.touch_tip() Touch Location -------------- These optional location arguments give you control over where the tip will touch the side of a well. This example demonstrates touching the tip in a specific well:: pipette.touch_tip(plate[&quot;B1&quot;]) This example uses an offset to set the touch tip location 2mm below the top of the current well:: pipette.touch_tip(v_offset=-2) This example moves the pipette 75% of well&apos;s total radius and 2 mm below the top of well:: pipette.touch_tip(plate[&quot;B1&quot;], radius=0.75, v_offset=-2) The ``touch_tip`` feature allows the pipette to touch the edges of a well gently instead of crashing into them. It includes the ``radius`` argument. When ``radius=1`` the robot moves the centerline of the pipette’s plunger axis to the edge of a well. This means a pipette tip may sometimes touch the well wall too early, causing it to bend inwards. A smaller radius helps avoid premature wall collisions and a lower speed produces gentler motion. Different liquid droplets behave differently, so test out these parameters in a single well before performing a full protocol run. .. warning:: *Do not* set the ``radius`` value greater than ``1.0``. When ``radius`` is &amp;gt; ``1.0``, the robot will forcibly move the pipette tip across a well wall or edge. This type of aggressive movement can damage the pipette tip and the pipette. Touch Speed ----------- Touch speed controls how fast the pipette moves in mm/s during a touch tip step. The default movement speed is 60 mm/s, the minimum is 1 mm/s, and the maximum is 80 mm/s. Calling ``touch_tip`` without any arguments moves a tip at the default speed in the current well:: pipette.touch_tip() This example specifies a well location and sets the speed to 20 mm/s:: pipette.touch_tip(plate[&quot;B1&quot;], speed=20) This example uses the current well and sets the speed to 80 mm/s:: pipette.touch_tip(speed=80) .. versionadded:: 2.0 .. versionchanged:: 2.4 Lowered minimum speed to 1 mm/s. .. _mix: Mix ==== The :py:meth:`~.InstrumentContext.mix` method aspirates and dispenses repeatedly in a single location. It&apos;s designed to mix the contents of a well together using a single command rather than using multiple ``aspirate()`` and ``dispense()`` calls. This method includes arguments that let you specify the number of times to mix, the volume (in µL) of liquid, and the well that contains the liquid you want to mix. This example draws 100 µL from the current well and mixes it three times:: pipette.mix(repetitions=3, volume=100) This example draws 100 µL from well B1 and mixes it three times:: pipette.mix(3, 100, plate[&quot;B1&quot;]) This example draws an amount equal to the pipette&apos;s maximum rated volume and mixes it three times:: pipette.mix(repetitions=3) .. note:: In API versions 2.2 and earlier, during a mix, the pipette moves up and out of the target well. In API versions 2.3 and later, the pipette does not move while mixing. .. versionadded:: 2.0 .. _air-gap: Air Gap ======= The :py:meth:`.InstrumentContext.air_gap` method tells the pipette to draw in air before or after a liquid. Creating an air gap helps keep liquids from seeping out of a pipette after drawing it from a well. This method includes arguments that give you control over the amount of air to aspirate and the pipette&apos;s height (in mm) above the well. By default, the pipette moves 5 mm above a well before aspirating air. Calling :py:meth:`~.InstrumentContext.air_gap` with no arguments uses the entire remaining volume in the pipette. This example aspirates 200 µL of air 5 mm above the current well:: pipette.air_gap(volume=200) This example aspirates 200 µL of air 20 mm above the the current well:: pipette.air_gap(volume=200, height=20) This example aspirates enough air to fill the remaining volume in a pipette:: pipette.air_gap() .. versionadded:: 2.0 .. _detect-liquid-presence: Detect Liquids ============== The :py:meth:`.InstrumentContext.detect_liquid_presence` method tells a Flex pipette to check for liquid in a well. It returns ``True`` if the pressure sensors in the pipette detect a liquid and ``False`` if the sensors do not. When ``detect_liquid_presence()`` finds an empty well it won&apos;t raise an error or stop your protocol. ``detect_liquid_presence()`` is a standalone method to record the presence or absence of a liquid. You don&apos;t have to aspirate after detecting liquid presence. However, you should always pick up a tip immediately prior to checking for liquid, and either aspirate or drop the tip immediately after. This ensures that the pipette uses a clean, dry tip to check for liquid, and prevents cross-contamination. A potential use of liquid detection is to try aspirating from another well if the first well is found to contain no liquid. .. code-block:: python pipette.pick_up_tip() if pipette.detect_liquid_presence(reservoir[&quot;A1&quot;]): pipette.aspirate(100, reservoir[&quot;A1&quot;]) else: pipette.aspirate(100, reservoir[&quot;A2&quot;]) .. versionadded:: 2.20 .. _require-liquid-presence: Require Liquids =============== The :py:meth:`.InstrumentContext.require_liquid_presence` method tells a Flex pipette to check for `and require` liquid in a well. When ``require_liquid_presence()`` finds an empty well, it raises an error and pauses the protocol to let you resolve the problem. ``require_liquid_presence()`` is a standalone method to react to a missing liquid or empty well. You don&apos;t have to aspirate after requiring liquid presence. However, you should always pick up a tip immediately prior to checking for liquid, and either aspirate or drop the tip immediately after. This ensures that the pipette uses a clean, dry tip to check for liquid, and prevents cross-contamination. .. code-block:: python pipette.pick_up_tip() pipette.require_liquid_presence(reservoir[&quot;A1&quot;]) pipette.aspirate(100, reservoir[&quot;A1&quot;]) # only occurs if liquid found You can also require liquid presence for all aspirations performed with a given pipette. See :ref:`lpd`. .. versionadded:: 2.20</content></file><file name="pipette_tips.rst" type="rst"><content>:og:description: Basic commands for working with pipette tips. .. _pipette-tips: ************************* Manipulating Pipette Tips ************************* Your robot needs to attach a disposable tip to the pipette before it can aspirate or dispense liquids. The API provides three basic functions that help the robot attach and manage pipette tips during a protocol run. These methods are :py:meth:`.InstrumentContext.pick_up_tip`, :py:meth:`.InstrumentContext.drop_tip`, and :py:meth:`.InstrumentContext.return_tip`. Respectively, these methods tell the robot to pick up a tip from a tip rack, drop a tip into the trash (or another location), and return a tip to its location in the tip rack. The following sections demonstrate how to use each method and include sample code. The examples used here assume that you&apos;ve loaded the pipettes and labware from the basic :ref:`protocol template &amp;lt;protocol-template&amp;gt;`. .. _basic-tip-pickup: Picking Up a Tip ================ To pick up a tip, call the :py:meth:`~.InstrumentContext.pick_up_tip` method without any arguments:: pipette.pick_up_tip() When added to the protocol template, this simple statement works because the API knows which tip rack is associated with ``pipette``, as indicated by ``tip_racks=[tiprack_1]`` in the :py:meth:`.load_instrument` call. And it knows the on-deck location of the tip rack (slot D3 on Flex, slot 3 on OT-2) from the ``location`` argument of :py:meth:`~.ProtocolContext.load_labware`. Given this information, the robot moves to the tip rack and picks up a tip from position A1 in the rack. On subsequent calls to ``pick_up_tip()``, the robot will use the next available tip. For example:: pipette.pick_up_tip() # picks up tip from rack location A1 pipette.drop_tip() # drops tip in trash bin pipette.pick_up_tip() # picks up tip from rack location B1 pipette.drop_tip() # drops tip in trash bin If you omit the ``tip_rack`` argument from the ``pipette`` variable, the API will raise an error. In that case, you must pass the tip rack&apos;s location to ``pick_up_tip`` like this:: pipette.pick_up_tip(tiprack_1[&quot;A1&quot;]) pipette.drop_tip() pipette.pick_up_tip(tiprack_1[&quot;B1&quot;]) In most cases, it&apos;s best to associate tip racks with a pipette and let the API automatically track pickup location for you. This also makes it easy to pick up tips when iterating over a loop, as shown in the next section. .. versionadded:: 2.0 Automating Tip Pick Up ====================== When used with Python&apos;s :py:class:`range` class, a ``for`` loop brings automation to the tip pickup and tracking process. It also eliminates the need to call ``pick_up_tip()`` multiple times. For example, this snippet tells the robot to sequentially use all the tips in a 96-tip rack:: for i in range(96): pipette.pick_up_tip() # liquid handling commands pipette.drop_tip() If your protocol requires a lot of tips, add a second tip rack to the protocol. Then, associate it with your pipette and increase the number of repetitions in the loop. The robot will work through both racks. First, add another tip rack to the sample protocol:: tiprack_2 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;C3&quot; ) Next, change the pipette&apos;s ``tip_rack`` property to include the additional rack:: pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1, tiprack_2], ) Finally, iterate over a larger range:: for i in range(192): pipette.pick_up_tip() # liquid handling commands pipette.drop_tip() For a more advanced &quot;real-world&quot; example, review the :ref:`off-deck location protocol &amp;lt;off-deck-location&amp;gt;` on the :ref:`moving-labware` page. This example also uses a ``for`` loop to iterate through a tip rack, but it includes other commands that pause the protocol and let you replace an on-deck tip rack with another rack stored in an off-deck location. .. _pipette-drop-tip: Dropping a Tip ============== To drop a tip in the pipette&apos;s trash container, call the :py:meth:`~.InstrumentContext.drop_tip` method with no arguments:: pipette.drop_tip() You can specify where to drop the tip by passing in a location. For example, this code drops a tip in the trash bin and returns another tip to to a previously used well in a tip rack:: pipette.pick_up_tip() # picks up tip from rack location A1 pipette.drop_tip() # drops tip in default trash container pipette.pick_up_tip() # picks up tip from rack location B1 pipette.drop_tip(tiprack[&quot;A1&quot;]) # drops tip in rack location A1 .. versionadded:: 2.0 Another use of the ``location`` parameter is to drop a tip in a specific trash container. For example, calling ``pipette.drop_tip(chute)`` will dispose tips in the waste chute, even if the pipette&apos;s default trash container is a trash bin:: pipette.pick_up_tip() # picks up tip from rack location A1 pipette.drop_tip() # drops tip in default trash container pipette.pick_up_tip() # picks up tip from rack location B1 pipette.drop_tip(chute) # drops tip in waste chute .. versionadded:: 2.16 .. _pipette-return-tip: Returning a Tip =============== To return a tip to its original location, call the :py:meth:`~.InstrumentContext.return_tip` method with no arguments:: pipette.return_tip() .. versionadded:: 2.0 .. note:: You can&apos;t return tips with a pipette that&apos;s configured to use :ref:`partial tip pickup &amp;lt;partial-tip-pickup&amp;gt;`. This restriction ensures that the pipette has clear access to unused tips. For example, a 96-channel pipette in column configuration can&apos;t reach column 2 unless column 1 is empty. If you call ``return_tip()`` while using partial tip pickup, the API will raise an error. Use ``drop_tip()`` to dispose the tips instead. Working With Used Tips ====================== Currently, the API considers tips as &quot;used&quot; after being picked up. For example, if the robot picked up a tip from rack location A1 and then returned it to the same location, it will not attempt to pick up this tip again, unless explicitly specified. Instead, the robot will pick up a tip starting from rack location B1. For example:: pipette.pick_up_tip() # picks up tip from rack location A1 pipette.return_tip() # drops tip in rack location A1 pipette.pick_up_tip() # picks up tip from rack location B1 pipette.drop_tip() # drops tip in trash bin pipette.pick_up_tip(tiprack_1[&quot;A1&quot;]) # picks up tip from rack location A1 Early API versions treated returned tips as unused items. They could be picked up again without an explicit argument. For example:: pipette.pick_up_tip() # picks up tip from rack location A1 pipette.return_tip() # drops tip in rack location A1 pipette.pick_up_tip() # picks up tip from rack location A1 .. versionchanged:: 2.2</content></file><file name="utilities.rst" type="rst"><content>:og:description: Basic commands for working with robot utility features. .. _new-utility-commands: **************** Utility Commands **************** With utility commands, you can control various robot functions such as pausing or delaying a protocol, checking the robot&apos;s door, turning robot lights on/off, and more. The following sections show you how to these utility commands and include sample code. The examples used here assume that you’ve loaded the pipettes and labware from the basic :ref:`protocol template &amp;lt;protocol-template&amp;gt;`. Delay and Resume ================ Call the :py:meth:`.ProtocolContext.delay` method to insert a timed delay into your protocol. This method accepts time increments in seconds, minutes, or combinations of both. Your protocol resumes automatically after the specified time expires. This example delays a protocol for 10 seconds:: protocol.delay(seconds=10) This example delays a protocol for 5 minutes:: protocol.delay(minutes=5) This example delays a protocol for 5 minutes and 10 seconds:: protocol.delay(minutes=5, seconds=10) Pause Until Resumed =================== Call the :py:meth:`.ProtocolContext.pause` method to stop a protocol at a specific step. Unlike a delay, :py:meth:`~.ProtocolContext.pause` does not restart your protocol automatically. To resume, you&apos;ll respond to a prompt on the touchscreen or in the Opentrons App. This method also lets you specify an optional message that provides on-screen or in-app instructions on how to proceed. This example inserts a pause and includes a brief message:: protocol.pause(&quot;Remember to get more pipette tips&quot;) .. versionadded:: 2.0 .. _utility-homing: Homing ====== Homing commands the robot to move the gantry, a pipette, or a pipette plunger to a defined position. For example, homing the gantry moves it to the back right of the working area. With the available homing methods you can home the gantry, home the mounted pipette and plunger, and home the pipette plunger. These functions take no arguments. To home the gantry, call :py:meth:`.ProtocolContext.home`:: protocol.home() To home a specific pipette&apos;s Z axis and plunger, call :py:meth:`.InstrumentContext.home`:: pipette = protocol.load_instrument(&quot;flex_1channel_1000&quot;, &quot;right&quot;) pipette.home() To home a specific pipette&apos;s plunger only, you can call :py:meth:`.InstrumentContext.home_plunger`:: pipette = protocol.load_instrument(&quot;flex_1channel_1000&quot;, &quot;right&quot;) pipette.home_plunger() .. versionadded:: 2.0 Comment ======= Call the :py:meth:`.ProtocolContext.comment` method if you want to write and display a brief message in the Opentrons App during a protocol run:: protocol.comment(&quot;Hello, world!&quot;) .. versionadded:: 2.0 Control and Monitor Robot Rail Lights ===================================== Call the :py:meth:`.ProtocolContext.set_rail_lights` method to turn the robot&apos;s rail lights on or off during a protocol. This method accepts Boolean ``True`` (lights on) or ``False`` (lights off) arguments. Rail lights are off by default. This example turns the rail lights on:: protocol.set_rail_lights(True) This example turns the rail lights off:: protocol.set_rail_lights(False) .. versionadded:: 2.5 You can also check whether the rail lights are on or off in the protocol by using :py:obj:`.ProtocolContext.rail_lights_on`. This method returns ``True`` when lights are on and ``False`` when the lights are off. .. versionadded:: 2.5 OT-2 Door Safety Switch ======================= Introduced with :ref:`robot software version &amp;lt;version-table&amp;gt;` 3.19, the safety switch feature prevents the OT-2, and your protocol, from running if the door is open. To operate properly, the front door and top window of your OT-2 must be closed. You can toggle the door safety switch on or off from **Robot Settings &amp;gt; Advanced &amp;gt; Usage Settings**. To check if the robot&apos;s door is closed at a specific point during a protocol run, call :py:obj:`.ProtocolContext.door_closed`. It returns a Boolean ``True`` (door closed) or ``False`` (door open) response. .. code-block:: python protocol.door_closed .. warning:: :py:obj:`~.ProtocolContext.door_closed` is a status check only. It does not control the robot&apos;s behavior. If you wish to implement a custom method to pause or resume a protocol using ``door_closed``, disable the door safety feature first (not recommended). .. versionadded:: 2.5</content></file></directory><directory name="complex_commands"><file name="order_operations.rst" type="rst"><content>:og:description: The order of basic commands that are part of a complex liquid handling commmand in the Python API. .. _complex-command-order: ******************* Order of Operations ******************* Complex commands perform a series of :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` in order. In fact, the run preview for your protocol in the Opentrons App lists all of these commands as separate steps. This lets you examine what effect your complex commands will have before running them. This page describes what steps you should expect the robot to perform when using different complex commands with different required and :ref:`optional &amp;lt;complex_params&amp;gt;` parameters. Step Sequence ============= The order of steps is fixed within complex commands. Aspiration and dispensing are the only required actions. You can enable or disable all of the other actions with :ref:`complex liquid handling parameters &amp;lt;complex_params&amp;gt;`. A complex command designed to perform every possible action will proceed in this order: 1. Pick up tip 2. Mix at source 3. Aspirate from source 4. Touch tip at source 5. Air gap 6. Dispense into destination 7. Mix at destination 8. Touch tip at destination 9. Blow out 10. Drop tip The command may repeat some or all of these steps in order to move liquid as requested. :py:meth:`.transfer` repeats as many times as there are wells in the longer of its ``source`` or ``dest`` argument. :py:meth:`.distribute` and :py:meth:`.consolidate` try to repeat as few times as possible. See :ref:`complex-tip-refilling` below for how they behave when they do need to repeat. Example Orders ============== The smallest possible number of steps in a complex command is just two: aspirating and dispensing. This is possible by omitting the tip pickup and drop steps:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=plate[&quot;B1&quot;], new_tip=&quot;never&quot;, ) Here&apos;s another example, a distribute command that adds touch tip steps (and does not turn off tip handling). The code for this command is:: pipette.distribute( volume=100, source=[plate[&quot;A1&quot;]], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], touch_tip=True, ) Compared to the list of all possible actions, this code will only perform the following: 1. Pick up tip 2. Aspirate from source 3. Touch tip at source 4. Dispense into destination 5. Touch tip at destination 6. Blow out 7. Drop tip Let&apos;s unpack this. Picking up and dropping tips is default behavior for ``distribute()``. Specifying ``touch_tip=True`` adds two steps, as it is performed at both the source and destination. And it&apos;s also default behavior for ``distribute()`` to aspirate a disposal volume, which is blown out before dropping the tip. The exact order of steps in the run preview should look similar to this: .. code-block:: text Picking up tip from A1 of tip rack on 3 Aspirating 220.0 uL from A1 of well plate on 2 at 92.86 uL/sec Touching tip Dispensing 100.0 uL into B1 of well plate on 2 at 92.86 uL/sec Touching tip Dispensing 100.0 uL into B2 of well plate on 2 at 92.86 uL/sec Touching tip Blowing out at A1 of Opentrons Fixed Trash on 12 Dropping tip into A1 of Opentrons Fixed Trash on 12 Since dispensing and touching the tip are both associated with the destination wells, those steps are performed at each of the two destination wells. .. _complex-tip-refilling: Tip Refilling ============= One factor that affects the exact order of steps for a complex command is whether the amount of liquid being moved can fit in the tip at once. If it won&apos;t fit, you don&apos;t have to adjust your command. The API will handle it for you by including additional steps to refill the tip when needed. For example, say you need to move 100 µL of liquid from one well to another, but you only have a 50 µL pipette attached to your robot. To accomplish this with building block commands, you&apos;d need multiple aspirates and dispenses. ``aspirate(volume=100)`` would raise an error, since it exceeds the tip&apos;s volume. But you can accomplish this with a single transfer command:: pipette50.transfer( volume=100, source=plate[&quot;A1&quot;], dest=plate[&quot;B1&quot;], ) To effect the transfer, the API will aspirate and dispense the maximum volume of the pipette (50 µL) twice: .. code-block:: text Picking up tip from A1 of tip rack on D3 Aspirating 50.0 uL from A1 of well plate on D2 at 57 uL/sec Dispensing 50.0 uL into B1 of well plate on D2 at 57 uL/sec Aspirating 50.0 uL from A1 of well plate on D2 at 57 uL/sec Dispensing 50.0 uL into B1 of well plate on D2 at 57 uL/sec Dropping tip into A1 of Opentrons Fixed Trash on A3 You can change ``volume`` to any value (above the minimum volume of the pipette) and the API will automatically calculate how many times the pipette needs to aspirate and dispense. ``volume=50`` would require just one repetition. ``volume=75`` would require two, split into 50 µL and 25 µL. ``volume=1000`` would repeat 20 times — not very efficient, but perhaps more useful than having to swap to a different pipette! Remember that ``distribute()`` includes a disposal volume by default, and this can affect the number of times the pipette refills its tip. Say you want to distribute 80 µL to each of the 12 wells in row A of a plate. That&apos;s 960 µL total — less than the capacity of the pipette — but the 100 µL disposal volume will cause the pipette to refill. .. code-block:: text Picking up tip from A1 of tip rack on 3 Aspirating 980.0 uL from A1 of well plate on 2 at 274.7 uL/sec Dispensing 80.0 uL into B1 of well plate on 2 at 274.7 uL/sec Dispensing 80.0 uL into B2 of well plate on 2 at 274.7 uL/sec ... Dispensing 80.0 uL into B11 of well plate on 2 at 274.7 uL/sec Blowing out at A1 of Opentrons Fixed Trash on 12 Aspirating 180.0 uL from A1 of well plate on 2 at 274.7 uL/sec Dispensing 80.0 uL into B12 of well plate on 2 at 274.7 uL/sec Blowing out at A1 of Opentrons Fixed Trash on 12 Dropping tip into A1 of Opentrons Fixed Trash on 12 This command will blow out 200 total µL of liquid in the trash. If you need to conserve liquid, use :ref:`complex liquid handling parameters &amp;lt;complex_params&amp;gt;` to reduce or eliminate the :ref:`disposal volume &amp;lt;param-disposal-volume&amp;gt;`, or to :ref:`blow out &amp;lt;param-blow-out&amp;gt;` in a location other than the trash. .. _distribute-consolidate-volume-list: .. _complex-list-volumes: List of Volumes =============== Complex commands can aspirate or dispense different amounts for different wells, rather than the same amount across all wells. To do this, set the ``volume`` parameter to a list of volumes instead of a single number. The list must be the same length as the longer of ``source`` or ``dest``, or the API will raise an error. For example, this command transfers a different amount of liquid into each of wells B1, B2, and B3:: pipette.transfer( volume=[20, 40, 60], source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;], plate[&quot;B3&quot;]], ) .. versionadded: 2.0 Setting any item in the list to ``0`` will skip aspirating and dispensing for the corresponding well. This example takes the command from above and skips B2:: pipette.transfer( volume=[20, 0, 60], source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;], plate[&quot;B3&quot;]], ) The pipette dispenses in B1 and B3, and does not move to B2 at all. .. code-block:: text Picking up tip from A1 of tip rack on 3 Aspirating 20.0 uL from A1 of well plate on 2 at 274.7 uL/sec Dispensing 20.0 uL into B1 of well plate on 2 at 274.7 uL/sec Aspirating 60.0 uL from A1 of well plate on 2 at 274.7 uL/sec Dispensing 60.0 uL into B3 of well plate on 2 at 274.7 uL/sec Dropping tip into A1 of Opentrons Fixed Trash on 12 This is such a simple example that you might prefer to use two ``transfer()`` commands instead. Lists of volumes become more useful when they are longer than a couple elements. For example, you can specify ``volume`` as a list with 96 items and ``dest=plate.wells()`` to individually control amounts to dispense (and wells to skip) across an entire plate. .. note:: When the optional ``new_tip`` parameter is set to ``&quot;always&quot;``, the pipette will pick up and drop a tip even for skipped wells. If you don&apos;t want to waste tips, pre-process your list of sources or destinations and use the result as the argument of your complex command. .. versionadded:: 2.0 Skip wells for ``transfer()`` and ``distribute()``. .. versionadded:: 2.8 Skip wells for ``consolidate()``.</content></file><file name="parameters.rst" type="rst"><content>:og:description: Parameters for fine-tuning complex liquid handling behavior in the Python API. .. _complex_params: ********************************** Complex Liquid Handling Parameters ********************************** Complex commands accept a number of optional parameters that give you greater control over the exact steps they perform. This page describes the accepted values and behavior of each parameter. The parameters are organized in the order that they first add a step. Some parameters, such as ``touch_tip``, add multiple steps. See :ref:`complex-command-order` for more details on the sequence of steps performed by complex commands. The API reference entry for :py:meth:`.InstrumentContext.transfer` also lists the parameters and has more information on their implementation as keyword arguments. .. _param-tip-handling: Tip Handling ============ The ``new_tip`` parameter controls if and when complex commands pick up new tips from the pipette&apos;s tip racks. It has three possible values: .. list-table:: :header-rows: 1 * - Value - Behavior * - ``&quot;once&quot;`` - - Pick up a tip at the start of the command. - Use the tip for all liquid handling. - Drop the tip at the end of the command. * - ``&quot;always&quot;`` - Pick up and drop a tip for each set of aspirate and dispense steps. * - ``&quot;never&quot;`` - Do not pick up or drop tips at all. ``&quot;once&quot;`` is the default behavior for all complex commands. .. versionadded:: 2.0 Tip Handling Requirements ------------------------- ``&quot;once&quot;`` and ``&quot;always&quot;`` require that the pipette has an :ref:`associated tip rack &amp;lt;pipette-tip-racks&amp;gt;`, or the API will raise an error (because it doesn&apos;t know where to pick up a tip from). If the pipette already has a tip attached, the API will also raise an error when it tries to pick up a tip. .. code-block:: python pipette.pick_up_tip() pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;], plate[&quot;B3&quot;]], new_tip=&quot;never&quot;, # &quot;once&quot;, &quot;always&quot;, or None will error ) Conversely, ``&quot;never&quot;`` requires that the pipette has picked up a tip, or the API will raise an error (because it will attempt to aspirate without a tip attached). Avoiding Cross-Contamination ---------------------------- One reason to set ``new_tip=&quot;always&quot;`` is to avoid cross-contamination between wells. However, you should always do a dry run of your protocol to test that the pipette is picking up and dropping tips in the way that your application requires. :py:meth:`~.InstrumentContext.transfer` will pick up a new tip before *every* aspirate when ``new_tip=&quot;always&quot;``. This includes when :ref:`tip refilling &amp;lt;complex-tip-refilling&amp;gt;` requires multiple aspirations from a single source well. :py:meth:`~.InstrumentContext.distribute` and :py:meth:`~.InstrumentContext.consolidate` only pick up one tip, even when ``new_tip=&quot;always&quot;``. For example, this distribute command returns to the source well a second time, because the amount to be distributed (400 µL total plus disposal volume) exceeds the pipette capacity (300 µL):: pipette.distribute( volume=200, source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], new_tip=&quot;always&quot;, ) But it *does not* pick up a new tip after dispensing into B1: .. code-block:: text Picking up tip from A1 of tip rack on 3 Aspirating 220.0 uL from A1 of well plate on 2 at 92.86 uL/sec Dispensing 200.0 uL into B1 of well plate on 2 at 92.86 uL/sec Blowing out at A1 of Opentrons Fixed Trash on 12 Aspirating 220.0 uL from A1 of well plate on 2 at 92.86 uL/sec Dispensing 200.0 uL into B2 of well plate on 2 at 92.86 uL/sec Blowing out at A1 of Opentrons Fixed Trash on 12 Dropping tip into A1 of Opentrons Fixed Trash on 12 If this poses a contamination risk, you can work around it in a few ways: * Use ``transfer()`` with ``new_tip=&quot;always&quot;`` instead. * Set :py:obj:`.well_bottom_clearance` high enough that the tip doesn&apos;t contact liquid in the destination well. * Use :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` instead of complex commands. .. _param-mix-before: Mix Before ========== The ``mix_before`` parameter controls mixing in source wells before each aspiration. Its value must be a :py:class:`tuple` with two numeric values. The first value is the number of repetitions, and the second value is the amount of liquid to mix in µL. For example, this transfer command will mix 50 µL of liquid 3 times before each of its aspirations:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], mix_before=(3, 50), ) .. versionadded:: 2.0 Mixing occurs before every aspiration, including when :ref:`tip refilling &amp;lt;complex-tip-refilling&amp;gt;` is required. .. note:: :py:meth:`~.InstrumentContext.consolidate` ignores any value of ``mix_before``. Mixing on the second and subsequent aspirations of a consolidate command would defeat its purpose: to aspirate multiple times in a row, from different wells, *before* dispensing. .. _param-disposal-volume: Disposal Volume =============== The ``disposal_volume`` parameter controls how much extra liquid is aspirated as part of a :py:meth:`~.InstrumentContext.distribute` command. Including a disposal volume can improve the accuracy of each dispense. The pipette blows out the disposal volume of liquid after dispensing. To skip aspirating and blowing out extra liquid, set ``disposal_volume=0``. By default, ``disposal_volume`` is the :ref:`minimum volume &amp;lt;new-pipette-models&amp;gt;` of the pipette, but you can set it to any amount:: pipette.distribute( volume=100, source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], disposal_volume=10, # reduce from default 20 µL to 10 µL ) .. versionadded:: 2.0 If the amount to aspirate plus the disposal volume exceeds the tip&apos;s capacity, ``distribute()`` will use a :ref:`tip refilling strategy &amp;lt;complex-tip-refilling&amp;gt;`. In such cases, the pipette will aspirate and blow out the disposal volume *for each aspiration*. For example, this command will require tip refilling with a 1000 µL pipette:: pipette.distribute( volume=120, source=reservoir[&quot;A1&quot;], dest=[plate.columns()[0]], disposal_volume=50, ) The amount to dispense in the destination is 960 µL (120 µL for each of 8 wells in the column). Adding the 50 µL disposal volume exceeds the 1000 µL capacity of the tip. The command will be split across two aspirations, each with the full disposal volume of 50 µL. The pipette will dispose *a total of 100 µL* during the command. .. note:: :py:meth:`~.InstrumentContext.transfer` will not aspirate additional liquid if you set ``disposal_volume``. However, it will perform a very small blow out after each dispense. :py:meth:`~.InstrumentContext.consolidate` ignores ``disposal_volume`` completely. .. _param-touch-tip: Touch Tip ========= The ``touch_tip`` parameter accepts a Boolean value. When ``True``, a touch tip step occurs after every aspirate and dispense. For example, this transfer command aspirates, touches the tip at the source, dispenses, and touches the tip at the destination:: pipette.transfer( volume=100, dest=plate[&quot;A1&quot;], source=plate[&quot;B1&quot;], touch_tip=True, ) .. versionadded:: 2.0 Touch tip occurs after every aspiration, including when :ref:`tip refilling &amp;lt;complex-tip-refilling&amp;gt;` is required. This parameter always uses default motion behavior for touch tip. Use the :ref:`touch tip building block command &amp;lt;touch-tip&amp;gt;` if you need to: * Only touch the tip after aspirating or dispensing, but not both. * Control the speed, radius, or height of the touch tip motion. .. _param-air-gap: Air Gap ======= The ``air_gap`` parameter controls how much air to aspirate and hold in the bottom of the tip when it contains liquid. The parameter&apos;s value is the amount of air to aspirate in µL. Air-gapping behavior is different for each complex command. The different behaviors all serve the same purpose, which is to never leave the pipette holding liquid at the very bottom of the tip. This helps keep liquids from seeping out of the pipette. .. list-table:: :header-rows: 1 * - Method - Air-gapping behavior * - ``transfer()`` - - Air gap after each aspiration. - Pipette is empty after dispensing. * - ``distribute()`` - - Air gap after each aspiration. - Air gap after dispensing if the pipette isn&apos;t empty. * - ``consolidate()`` - - Air gap after each aspiration. This may create multiple air gaps within the tip. - Pipette is empty after dispensing. For example, this transfer command will create a 20 µL air gap after each of its aspirations. When dispensing, it will clear the air gap and dispense the full 100 µL of liquid:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=plate[&quot;B1&quot;], air_gap=20, ) .. versionadded:: 2.0 When consolidating, air gaps still occur after every aspiration. In this example, the tip will use 210 µL of its capacity (50 µL of liquid followed by 20 µL of air, repeated three times):: pipette.consolidate( volume=50, source=[plate[&quot;A1&quot;], plate[&quot;A2&quot;], plate[&quot;A3&quot;]], dest=plate[&quot;B1&quot;], air_gap=20, ) .. code-block:: text Picking up tip from A1 of tip rack on 3 Aspirating 50.0 uL from A1 of well plate on 2 at 92.86 uL/sec Air gap Aspirating 20.0 uL from A1 of well plate on 2 at 92.86 uL/sec Aspirating 50.0 uL from A2 of well plate on 2 at 92.86 uL/sec Air gap Aspirating 20.0 uL from A2 of well plate on 2 at 92.86 uL/sec Aspirating 50.0 uL from A3 of well plate on 2 at 92.86 uL/sec Air gap Aspirating 20.0 uL from A3 of well plate on 2 at 92.86 uL/sec Dispensing 210.0 uL into B1 of well plate on 2 at 92.86 uL/sec Dropping tip into A1 of Opentrons Fixed Trash on 12 If adding an air gap would exceed the pipette&apos;s maximum volume, the complex command will use a :ref:`tip refilling strategy &amp;lt;complex-tip-refilling&amp;gt;`. For example, this command uses a 300 µL pipette to transfer 300 µL of liquid plus an air gap:: pipette.transfer( volume=300, source=plate[&quot;A1&quot;], dest=plate[&quot;B1&quot;], air_gap=20, ) As a result, the transfer is split into two aspirates of 150 µL, each with their own 20 µL air gap: .. code-block:: text Picking up tip from A1 of tip rack on 3 Aspirating 150.0 uL from A1 of well plate on 2 at 92.86 uL/sec Air gap Aspirating 20.0 uL from A1 of well plate on 2 at 92.86 uL/sec Dispensing 170.0 uL into B1 of well plate on 2 at 92.86 uL/sec Aspirating 150.0 uL from A1 of well plate on 2 at 92.86 uL/sec Air gap Aspirating 20.0 uL from A1 of well plate on 2 at 92.86 uL/sec Dispensing 170.0 uL into B1 of well plate on 2 at 92.86 uL/sec Dropping tip into A1 of Opentrons Fixed Trash on 12 .. _param-mix-after: Mix After ========= The ``mix_after`` parameter controls mixing in source wells after each dispense. Its value must be a :py:class:`tuple` with two numeric values. The first value is the number of repetitions, and the second value is the amount of liquid to mix in µL. For example, this transfer command will mix 50 µL of liquid 3 times after each of its dispenses:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], mix_after=(3, 50), ) .. versionadded:: 2.0 .. note:: :py:meth:`~.InstrumentContext.distribute` ignores any value of ``mix_after``. Mixing after dispensing would combine (and potentially contaminate) the remaining source liquid with liquid present at the destination. .. _param-blow-out: Blow Out ======== There are two parameters that control whether and where the pipette blows out liquid. The ``blow_out`` parameter accepts a Boolean value. When ``True``, the pipette blows out remaining liquid when the tip is empty or only contains the disposal volume. The ``blowout_location`` parameter controls in which of three locations these blowout actions occur. The default blowout location is the trash. Blowout behavior is different for each complex command. .. list-table:: :header-rows: 1 * - Method - Blowout behavior and location * - ``transfer()`` - - Blow out after each dispense. - Valid locations: ``&quot;trash&quot;``, ``&quot;source well&quot;``, ``&quot;destination well&quot;`` * - ``distribute()`` - - Blow out after the final dispense. - Valid locations: ``&quot;trash&quot;``, ``&quot;source well&quot;`` * - ``consolidate()`` - - Blow out after the only dispense. - Valid locations: ``&quot;trash&quot;``, ``&quot;destination well&quot;`` For example, this transfer command will blow out liquid in the trash twice, once after each dispense into a destination well:: pipette.transfer( volume=100, source=[plate[&quot;A1&quot;], plate[&quot;A2&quot;]], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], blow_out=True, ) .. versionadded:: 2.0 Set ``blowout_location`` when you don&apos;t want to waste any liquid by blowing it out into the trash. For example, you may want to make sure that every last bit of a sample is moved into a destination well. Or you may want to return every last bit of an expensive reagent to the source for use in later pipetting. If you need to blow out in a different well, or at a specific location within a well, use the :ref:`blow out building block command &amp;lt;blow-out&amp;gt;` instead. When setting a blowout location, you *must* also set ``blow_out=True``, or the location will be ignored:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=plate[&quot;B1&quot;], blow_out=True, # required to set location blowout_location=&quot;destination well&quot;, ) .. versionadded:: 2.8 With ``transfer()``, the pipette will not blow out at all if you only set ``blowout_location``. ``blow_out=True`` is also required for distribute commands that blow out by virtue of having a disposal volume:: pipette.distribute( volume=100, source=plate[&quot;A1&quot;], dest=[plate[&quot;B1&quot;], plate[&quot;B2&quot;]], disposal_volume=50, # causes blow out blow_out=True, # still required to set location! blowout_location=&quot;source well&quot;, ) With ``distribute()``, the pipette will still blow out if you only set ``blowout_location``, but in the default location of the trash. .. note:: If the tip already contains liquid before the complex command, the default blowout location will shift away from the trash. ``transfer()`` and ``distribute()`` shift to the source well, and ``consolidate()`` shifts to the destination well. For example, this transfer command will blow out in well B1 because it&apos;s the source:: pipette.pick_up_tip() pipette.aspirate(100, plate[&quot;A1&quot;]) pipette.transfer( volume=100, source=plate[&quot;B1&quot;], dest=plate[&quot;C1&quot;], new_tip=&quot;never&quot;, blow_out=True, # no blowout_location ) pipette.drop_tip() This only occurs when you aspirate and then perform a complex command with ``new_tip=&quot;never&quot;`` and ``blow_out=True``. .. _param-trash: Trash Tips ========== The ``trash`` parameter controls what the pipette does with tips at the end of complex commands. When ``True``, the pipette drops tips into the trash. When ``False``, the pipette returns tips to their original locations in their tip rack. The default is ``True``, so you only have to set ``trash`` when you want the tip-returning behavior:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=plate[&quot;B1&quot;], trash=False, ) .. versionadded:: 2.0</content></file><file name="sources_destinations.rst" type="rst"><content>:og:description: How the Opentrons Python API moves liquids between wells when using complex commands. .. _complex-source-dest: ************************ Sources and Destinations ************************ The :py:meth:`.InstrumentContext.transfer`, :py:meth:`.InstrumentContext.distribute`, and :py:meth:`.InstrumentContext.consolidate` methods form the family of complex liquid handling commands. These methods require ``source`` and ``dest`` (destination) arguments to move liquid from one well, or group of wells, to another. In contrast, the :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` :py:meth:`~.InstrumentContext.aspirate` and :py:meth:`~.InstrumentContext.dispense` only operate in a single location. For example, this command performs a simple transfer between two wells on a plate:: pipette.transfer( volume=100, source=plate[&quot;A1&quot;], dest=plate[&quot;A2&quot;], ) .. versionadded:: 2.0 This page covers the restrictions on sources and destinations for complex commands, their different patterns of aspirating and dispensing, and how to optimize them for different use cases. .. _source-dest-args: Source and Destination Arguments ================================ As noted above, the :py:meth:`~.InstrumentContext.transfer`, :py:meth:`~.InstrumentContext.distribute`, and :py:meth:`~.InstrumentContext.consolidate` methods require ``source`` and ``dest`` (destination) arguments to aspirate and dispense liquid. However, each method handles liquid sources and destinations differently. Understanding how complex commands work with source and destination wells is essential to using these methods effectively. :py:meth:`~.InstrumentContext.transfer` is the most versatile complex liquid handling function, because it has the fewest restrictions on what wells it can operate on. You will likely use transfer commands in many of your protocols. Certain liquid handling cases focus on moving liquid to or from a single well. :py:meth:`~.InstrumentContext.distribute` limits its source to a single well, while :py:meth:`~.InstrumentContext.consolidate` limits its destination to a single well. Distribute commands also make changes to liquid-handling behavior to improve the accuracy of dispensing. The following table summarizes the source and destination restrictions for each method. .. list-table:: :header-rows: 1 * - Method - Accepted wells * - ``transfer()`` - - **Source:** Any number of wells. - **Destination:** Any number of wells. - The larger group of wells must be evenly divisible by the smaller group. * - ``distribute()`` - - **Source:** Exactly one well. - **Destination:** Any number of wells. * - ``consolidate()`` - - **Source:** Any number of wells. - **Destination:** Exactly one well. A single well can be passed by itself or as a list with one item: ``source=plate[&quot;A1&quot;]`` and ``source=[plate[&quot;A1&quot;]]`` are equivalent. The section on :ref:`many-to-many transfers &amp;lt;many-to-many&amp;gt;` below covers how ``transfer()`` works when specifying sources and destinations of different sizes. However, if they don&apos;t meet the even divisibility requirement, the API will raise an error. You can work around such situations by making multiple calls to ``transfer()`` in sequence or by using a :ref:`list of volumes &amp;lt;complex-list-volumes&amp;gt;` to skip certain wells. For distributing and consolidating, the API will not raise an error if you use a list of wells as the argument that is limited to exactly one well. Instead, the API will ignore everything except the first well in the list. For example, the following command will only aspirate from well A1:: pipette.distribute( volume=100, source=[plate[&quot;A1&quot;], plate[&quot;A2&quot;]], # A2 ignored dest=plate.columns()[1], ) On the other hand, a transfer command with the same arguments would aspirate from both A1 and A2. The next section examines the exact order of aspiration and dispensing for all three methods. .. _complex-transfer-patterns: Transfer Patterns ================= Each complex command uses a different pattern of aspiration and dispensing. In addition, when you provide multiple wells as both the source and destination for ``transfer()``, it maps the source list onto the destination list in a certain way. Aspirating and Dispensing ------------------------- ``transfer()`` always alternates between aspirating and dispensing, regardless of how many wells are in the source and destination. Its default behavior is: 1. Pick up a tip. 2. Aspirate from the first source well. 3. Dispense in the first destination well. 4. Repeat the pattern of aspirating and dispensing, as needed. 5. Drop the tip in the trash. .. figure:: ../../img/complex_commands/transfer.png :name: Transfer :scale: 35% :align: center This transfer aspirates six times and dispenses six times. ``distribute()`` always fills the tip with as few aspirations as possible, and then dispenses to the destination wells in order. Its default behavior is: 1. Pick up a tip. 2. Aspirate enough to dispense in all the destination wells. This aspirate includes a disposal volume. 3. Dispense in the first destination well. 4. Continue to dispense in destination wells. 5. Drop the tip in the trash. See :ref:`complex-tip-refilling` below for cases where the total amount to be dispensed is greater than the capacity of the tip. .. figure:: ../../img/complex_commands/robot_distribute.png :name: Distribute :scale: 35% :align: center This distribute aspirates one time and dispenses three times. ``consolidate()`` aspirates multiple times in a row, and then dispenses as few times as possible in the destination well. Its default behavior is: 1. Pick up a tip. 2. Aspirate from the first source well. 3. Continue aspirating from source wells. 4. Dispense in the destination well. 5. Drop the tip in the trash. See :ref:`complex-tip-refilling` below for cases where the total amount to be aspirated is greater than the capacity of the tip. .. figure:: ../../img/complex_commands/robot_consolidate.png :name: Consolidate :scale: 35% :align: center This consolidate aspirates three times and dispenses one time. .. note:: By default, all three commands begin by picking up a tip and conclude by dropping a tip. In general, don&apos;t call :py:meth:`.pick_up_tip` just before a complex command, or the API will raise an error. You can override this behavior with the :ref:`tip handling complex parameter &amp;lt;param-tip-handling&amp;gt;`, by setting ``new_tip=&quot;never&quot;``. .. _many-to-many: Many-to-Many ------------ ``transfer()`` lets you specify both ``source`` and ``dest`` arguments that contain multiple wells. This section covers how the method determines which wells to aspirate from and dispense to in these cases. When the source and destination both contain the same number of wells, the mapping between wells is straightforward. You can imagine writing out the two lists one above each other, with each unique well in the source list paired to a unique well in the destination list. For example, here is the code for using one row as the source and another row as the destination, and the resulting correspondence between wells:: pipette.transfer( volume=50, source=plate.rows()[0], dest=plate.rows()[1], ) .. list-table:: :stub-columns: 1 * - Source - A1 - A2 - A3 - A4 - A5 - A6 - A7 - A8 - A9 - A10 - A11 - A12 * - Destination - B1 - B2 - B3 - B4 - B5 - B6 - B7 - B8 - B9 - B10 - B11 - B12 There&apos;s no requirement that the source and destination lists be mutually exclusive. In fact, this command adapted from the :ref:`tutorial &amp;lt;tutorial&amp;gt;` deliberately uses slices of the same list, saved to the variable ``row``, with the effect that each aspiration happens in the same location as the previous dispense:: row = plate.rows()[0] pipette.transfer( volume=50, source=row[:11], dest=row[1:], ) .. list-table:: :stub-columns: 1 * - Source - A1 - A2 - A3 - A4 - A5 - A6 - A7 - A8 - A9 - A10 - A11 * - Destination - A2 - A3 - A4 - A5 - A6 - A7 - A8 - A9 - A10 - A11 - A12 When the source and destination lists contain different numbers of wells, ``transfer()`` will always aspirate and dispense as many times as there are wells in the *longer* list. The shorter list will be &quot;stretched&quot; to cover the length of the longer list. Here is an example of transferring from 3 wells to a full row of 12 wells:: pipette.transfer( volume=50, source=[plate[&quot;A1&quot;], plate[&quot;A2&quot;], plate[&quot;A3&quot;]], dest=plate.rows()[1], ) .. list-table:: :stub-columns: 1 * - Source - A1 - A1 - A1 - A1 - A2 - A2 - A2 - A2 - A3 - A3 - A3 - A3 * - Destination - B1 - B2 - B3 - B4 - B5 - B6 - B7 - B8 - B9 - B10 - B11 - B12 This is why the longer list must be evenly divisible by the shorter list. Changing the destination in this example to a column instead of a row will cause the API to raise an error, because 8 is not evenly divisible by 3:: pipette.transfer( volume=50, source=[plate[&quot;A1&quot;], plate[&quot;A2&quot;], plate[&quot;A3&quot;]], dest=plate.columns()[3], # labware column 4 ) # error: source and destination lists must be divisible The API raises this error rather than presuming which wells to aspirate from three times and which only two times. If you want to aspirate three times from A1, three times from A2, and two times from A3, use multiple ``transfer()`` commands in sequence:: pipette.transfer(50, plate[&quot;A1&quot;], plate.columns()[3][:3]) pipette.transfer(50, plate[&quot;A2&quot;], plate.columns()[3][3:6]) pipette.transfer(50, plate[&quot;A3&quot;], plate.columns()[3][6:]) Finally, be aware of the ordering of source and destination lists when constructing them with :ref:`well accessor methods &amp;lt;well-accessor-methods&amp;gt;`. For example, at first glance this code may appear to take liquid from each well in the first row of a plate and move it to each of the other wells in the same column:: pipette.transfer( volume=20, source=plate.rows()[0], dest=plate.rows()[1:], ) However, because the well ordering of :py:meth:`.Labware.rows` goes *across* the plate instead of *down* the plate, liquid from A1 will be dispensed in B1–B7, liquid from A2 will be dispensed in B8–C2, etc. The intended task is probably better accomplished by repeating transfers in a ``for`` loop:: for i in range(12): pipette.transfer( volume=20, source=plate.rows()[0][i], dest=plate.columns()[i][1:], ) Here the repeat index ``i`` picks out: - The individual well in the first row, for the source. - The corresponding column, which is sliced to form the destination. .. _complex-optimizing-patterns: Optimizing Patterns ------------------- Choosing the right complex command optimizes gantry movement and helps save time in your protocol. For example, say you want to take liquid from a reservoir and put 50 µL in each well of the first row of a plate. You could use ``transfer()``, like this:: pipette.transfer( volume=50, source=reservoir[&quot;A1&quot;], destination=plate.rows()[0], ) This will produce 12 aspirate steps and 12 dispense steps. The steps alternate, with the pipette moving back and forth between the reservoir and plate each time. Using ``distribute()`` with the same arguments is more optimal in this scenario:: pipette.distribute( volume=50, source=reservoir[&quot;A1&quot;], destination=plate.rows()[0], ) This will produce *just 1* aspirate step and 12 dispense steps (when using a 1000 µL pipette). The pipette will aspirate enough liquid to fill all the wells, plus a disposal volume. Then it will move to A1 of the plate, dispense, move the short distance to A2, dispense, and so on. This greatly reduces gantry movement and the time to perform this action. And even if you&apos;re using a smaller pipette, ``distribute()`` will fill the pipette, dispense as many times as possible, and only then return to the reservoir to refill (see :ref:`complex-tip-refilling` for more information).</content></file></directory><directory name="example_protocols"><file name="dilution_tutorial_flex.py" type="py"><content>from opentrons import protocol_api metadata = { &quot;protocolName&quot;: &quot;Serial Dilution Tutorial – Flex 1-channel&quot;, &quot;description&quot;: &quot;&quot;&quot;This protocol is the outcome of following the Python Protocol API Tutorial located at https://docs.opentrons.com/v2/tutorial.html. It takes a solution and progressively dilutes it by transferring it stepwise across a plate.&quot;&quot;&quot;, &quot;author&quot;: &quot;New API User&quot; } requirements = { &quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;2.16&quot; } def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_flex_96_tiprack_200ul&quot;, &quot;D1&quot;) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, &quot;D2&quot;) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;D3&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) left_pipette = protocol.load_instrument(&quot;flex_1channel_1000&quot;, &quot;left&quot;, tip_racks=[tips]) # distribute diluent left_pipette.transfer(100, reservoir[&quot;A1&quot;], plate.wells()) # loop through each row for i in range(8): # save the destination row to a variable row = plate.rows()[i] # transfer solution to first well in column left_pipette.transfer(100, reservoir[&quot;A2&quot;], row[0], mix_after=(3, 50)) # dilute the sample down the row left_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50))</content></file><file name="dilution_tutorial_multi_flex.py" type="py"><content>from opentrons import protocol_api metadata = { &quot;protocolName&quot;: &quot;Serial Dilution Tutorial – Flex 8-channel&quot;, &quot;description&quot;: &quot;&quot;&quot;This protocol is the outcome of following the Python Protocol API Tutorial located at https://docs.opentrons.com/v2/tutorial.html. It takes a solution and progressively dilutes it by transferring it stepwise across a plate.&quot;&quot;&quot;, &quot;author&quot;: &quot;New API User&quot; } requirements = { &quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;2.16&quot; } def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, &quot;D1&quot;) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, &quot;D2&quot;) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;D3&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) left_pipette = protocol.load_instrument(&quot;flex_8channel_1000&quot;, &quot;right&quot;, tip_racks=[tips]) # distribute diluent left_pipette.transfer(100, reservoir[&quot;A1&quot;], plate.rows()[0]) # no loop, 8-channel pipette # save the destination row to a variable row = plate.rows()[0] # transfer solution to first well in column left_pipette.transfer(100, reservoir[&quot;A2&quot;], row[0], mix_after=(3, 50)) # dilute the sample down the row left_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50))</content></file><file name="dilution_tutorial_multi.py" type="py"><content>from opentrons import protocol_api metadata = { &quot;apiLevel&quot;: &quot;2.16&quot;, &quot;protocolName&quot;: &quot;Serial Dilution Tutorial – OT-2 8-channel&quot;, &quot;description&quot;: &quot;&quot;&quot;This protocol is the outcome of following the Python Protocol API Tutorial located at https://docs.opentrons.com/v2/tutorial.html. It takes a solution and progressively dilutes it by transferring it stepwise across a plate.&quot;&quot;&quot;, &quot;author&quot;: &quot;New API User&quot; } def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, 1) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, 2) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, 3) left_pipette = protocol.load_instrument(&quot;p300_multi_gen2&quot;, &quot;right&quot;, tip_racks=[tips]) # distribute diluent left_pipette.transfer(100, reservoir[&quot;A1&quot;], plate.rows()[0]) # no loop, 8-channel pipette # save the destination row to a variable row = plate.rows()[0] # transfer solution to first well in column left_pipette.transfer(100, reservoir[&quot;A2&quot;], row[0], mix_after=(3, 50)) # dilute the sample down the row left_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50))</content></file><file name="dilution_tutorial.py" type="py"><content>from opentrons import protocol_api metadata = { &quot;apiLevel&quot;: &quot;2.16&quot;, &quot;protocolName&quot;: &quot;Serial Dilution Tutorial – OT-2 single-channel&quot;, &quot;description&quot;: &quot;&quot;&quot;This protocol is the outcome of following the Python Protocol API Tutorial located at https://docs.opentrons.com/v2/tutorial.html. It takes a solution and progressively dilutes it by transferring it stepwise across a plate.&quot;&quot;&quot;, &quot;author&quot;: &quot;New API User&quot; } def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, 1) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, 2) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, 3) left_pipette = protocol.load_instrument(&quot;p300_single_gen2&quot;, &quot;left&quot;, tip_racks=[tips]) # distribute diluent left_pipette.transfer(100, reservoir[&quot;A1&quot;], plate.wells()) # loop through each row for i in range(8): # save the destination row to a variable row = plate.rows()[i] # transfer solution to first well in column left_pipette.transfer(100, reservoir[&quot;A2&quot;], row[0], mix_after=(3, 50)) # dilute the sample down the row left_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50))</content></file></directory><directory name="modules"><file name="absorbance_plate_reader.rst" type="rst"><content>:og:description: How to use the Absorbance Plate Reader Module in a Python protocol. .. _absorbance-plate-reader-module: ****************************** Absorbance Plate Reader Module ****************************** The Absorbance Plate Reader Module is an on-deck microplate spectrophotometer that works with the Flex robot only. The module uses light absorbance to determine sample concentrations in 96-well plates. The Absorbance Plate Reader is represented in code by an :py:class:`.AbsorbanceReaderContext` object, which has methods for moving the module lid with the Flex Gripper, initializing the module to read at a single wavelength or multiple wavelengths, and reading a plate. With the Python Protocol API, you can process plate reader data immediately in your protocol or export it to a CSV for post-run use. This page explains the actions necessary for using the Absorbance Plate Reader. These combine to form the typical reader workflow: 1. Close the lid with no plate inside 2. Initialize the reader 3. Open the lid 4. Move a plate onto the module 5. Close the lid 6. Read the plate Loading and Deck Slots ====================== The Absorbance Plate Reader can only be loaded in slots A3–D3. If you try to load it in any other slot, the API will raise an error. The module&apos;s caddy is designed such that the detection unit is in deck column 3 and the special staging area for the lid/illumination unit is in deck column 4. You can&apos;t load or move other labware on the Absorbance Plate Reader caddy in deck column 4, even while the lid is in the closed position (on top of the detection unit in deck column 3). The examples in this section will use an Absorbance Plate Reader Module loaded as follows:: pr_mod = protocol.load_module( module_name=&quot;absorbanceReaderV1&quot;, location=&quot;D3&quot; ) .. versionadded:: 2.21 Lid Control =========== Flex uses the gripper to move the lid between its two positions. - :py:meth:`~.AbsorbanceReaderContext.open_lid()` moves the lid to the righthand side of the caddy, in deck column 4. - :py:meth:`~.AbsorbanceReaderContext.close_lid()` moves the lid onto the detection unit, in deck column 3. If you call ``open_lid()`` or ``close_lid()`` and the lid is already in the corresponding position, the method will succeed immediately. You can also check the position of the lid with :py:meth:`~.AbsorbanceReaderContext.is_lid_on()`. You need to call ``close_lid()`` before initializing the reader, even if the reader was in the closed position at the start of the protocol. .. warning:: Do not move the lid manually, during or outside of a protocol. The API does not allow manual lid movement because there is a risk of damaging the module. .. _absorbance-initialization: Initialization ============== Initializing the reader prepares it to read a plate later in your protocol. The :py:meth:`.AbsorbanceReaderContext.initialize` method accepts parameters for the number of readings you want to take, the wavelengths to read, and whether you want to compare the reading to a reference wavelength. In the default hardware configuration, the supported wavelengths are 450 nm (blue), 562 nm (green), 600 nm (orange), and 650 nm (red). The module uses these parameters immediately to perform the physical initialization. Additionally, the API preserves these values and uses them when you read the plate later in your protocol. Let&apos;s take a look at examples of how to combine these parameters to prepare different types of readings. The simplest reading measures one wavelength, with no reference wavelength:: pr_mod.initialize(mode=&quot;single&quot;, wavelengths=[450]) .. versionadded:: 2.21 Now the reader is prepared to read at 450 nm. Note that the ``wavelengths`` parameter always takes a list of integer wavelengths, even when only reading a single wavelength. This example can be extended by adding a reference wavelength:: pr_mod.initialize( mode=&quot;single&quot;, wavelengths=[450], reference_wavelength=562 ) When configured this way, the module will read twice. In the :ref:`output data &amp;lt;plate-reader-data&amp;gt;`, the values read for ``reference_wavelength`` will be subtracted from the values read for the single member of ``wavelengths``. This is useful for normalization, or to correct for background interference in wavelength measurements. The reader can also be initialized to take multiple measurements. When ``mode=&quot;multi&quot;``, the ``wavelengths`` list can have up to six elements. This example will initialize the reader to read at three wavelengths:: pr_mod.initialize(mode=&quot;multi&quot;, wavelengths=[450, 562, 600]) You can&apos;t use a reference wavelength when performing multiple measurements. Reading a Plate =============== Use :py:meth:`.AbsorbanceReaderContext.read` to have the module read the plate, using the parameters that you specified during initialization:: pr_data = pr_mod.read() .. versionadded:: 2.21 The ``read()`` method returns the results in a dictionary, which the above example saves to the variable ``pr_data``. If you need to access this data after the conclusion of your protocol, add the ``export_filename`` parameter to instruct the API to output a CSV file, which is available in the Opentrons App by going to your Flex and viewing Recent Protocol Runs:: pr_data = pr_mod.read(export_filename=&quot;plate_data&quot;) In the above example, the API both saves the data to a variable and outputs a CSV file. If you only need the data post-run, you can omit the variable assignment. .. _plate-reader-data: Using Plate Reader Data ======================= There are two ways to use output data from the Absorbance Plate Reader: - Within your protocol as a nested dictionary object. - Outside of your protocol, as a tabular CSV file. The two formats are structured differently, even though they contain the same measurement data. Dictionary Data --------------- The dictionary object returned by ``read()`` has two nested levels. The keys at the top level are the wavelengths you provided to ``initialize()``. The keys at the second level are string names of each of the 96 wells, ``&quot;A1&quot;`` through ``&quot;H12&quot;``. The values at the second level are the measured values for each wells. These values are floating point numbers, representing the optical density (OD) of the samples in each well. OD ranges from 0.0 (low sample concentration) to 4.0 (high sample concentration). The nested dictionary structure allows you to access results by index later in your protocol. This example initializes a multiple read and then accesses different portions of the results:: # initializing and reading pr_mod.initialize(mode=&quot;multi&quot;, wavelengths=[450, 600]) pr_mod.open_lid() protocol.move_labware(plate, pr_mod, use_gripper=True) pr_mod.close_lid() pr_data = pr_mod.read() # accessing results pr_data[450][&quot;A1&quot;] # value for well A1 at 450 nm pr_data[600][&quot;H12&quot;] # value for well H12 at 600 nm pr_data[450] # dict of all wells at 450 nm You can write additional code to transform this data in any way that you need. For example, you could use a list comprehension to create a list of only the 450 nm values for column 1, ordered by well from A1 to H1:: [pr_data[450][w.well_name] for w in plate.columns()[0]] .. _absorbance-csv: CSV data -------- The CSV exported when specifying ``export_filename`` consists of tabular data followed by additional information. Each measurement produces 9 rows in the CSV file, representing the layout of the well plate that has been read. These rows form a table with numeric labels in the first row and alphabetic labels in the first column, as you would see on physical labware. Each &quot;cell&quot; of the table contains the measured OD value for the well (0.0–4.0) in the corresponding position on the plate. Additional information, starting with one blank labware grid, is output at the end of the file. The last few lines of the file list the sample wavelengths, serial number of the module, and timestamps for when measurement started and finished. Each output file for your protocol is available in the Opentrons App by going to your Flex and viewing Recent Protocol Runs. After downloading the file from your Flex, you can read it with any software that reads CSV files, and you can write additional code to parse and act upon its contents. You can also select the output CSV as the value of a CSV runtime parameter in a subsequent protocol. When you :ref:`parse the CSV data &amp;lt;rtp-csv-data&amp;gt;`, make sure to set ``detect_dialect=False``, or the API will raise an error.</content></file><file name="heater_shaker.rst" type="rst"><content>:og:description: How to use the Heater-Shaker Module in a Python protocol, and where it can be safely placed on the deck. .. _heater-shaker-module: ******************** Heater-Shaker Module ******************** The Heater-Shaker Module provides on-deck heating and orbital shaking. The module can heat from 37 to 95 °C, and can shake samples from 200 to 3000 rpm. The Heater-Shaker Module is represented in code by a :py:class:`.HeaterShakerContext` object. For example:: hs_mod = protocol.load_module( module_name=&quot;heaterShakerModuleV1&quot;, location=&quot;D1&quot; ) .. versionadded:: 2.13 Deck Slots ========== The supported deck slot positions for the Heater-Shaker depend on the robot you’re using. .. list-table:: :widths: 30 80 :header-rows: 1 * - Robot Model - Heater-Shaker Deck Placement * - Flex - In any deck slot in column 1 or 3. The module can go in slot A3, but you need to move the trash bin first. * - OT-2 - In deck slot 1, 3, 4, 6, 7, or 10. OT-2 Placement Restrictions =========================== On OT-2, you need to restrict placement of other modules and labware around the Heater-Shaker. On Flex, the module is installed below-deck in a caddy and there is more space between deck slots, so these restrictions don&apos;t apply. In general, it&apos;s best to leave all slots adjacent to the Heater-Shaker empty. If your protocol requires filling those slots, observe the following restrictions to avoid physical crashes involving the Heater-Shaker. Adjacent Modules ---------------- Do not place other modules next to the Heater-Shaker. Keeping adjacent deck slots clear helps prevents collisions during shaking and while opening the labware latch. Loading a module next to the Heater-Shaker on OT-2 will raise a ``DeckConflictError``. Tall Labware ------------ Do not place labware taller than 53 mm to the left or right of the Heater-Shaker. This prevents the Heater-Shaker’s latch from colliding with the adjacent labware. Common labware that exceed the height limit include Opentrons tube racks and Opentrons 1000 µL tip racks. Loading tall labware to the right or left of the Heater-Shaker on OT-2 will raise a ``DeckConflictError``. 8-Channel Pipettes ------------------ You can&apos;t perform pipetting actions in `any` slots adjacent to the Heater-Shaker if you&apos;re using a GEN2 or GEN1 8-channel pipette. This prevents the pipette ejector from crashing on the module housing or labware latch. Using an 8-channel pipette will raise a ``PipetteMovementRestrictedByHeaterShakerError``. There is one exception: to the front or back of the Heater-Shaker, an 8-channel pipette can access tip racks only. Attempting to pipette to non-tip-rack labware will also raise a ``PipetteMovementRestrictedByHeaterShakerError``. Latch Control ============= To add and remove labware from the Heater-Shaker, control the module&apos;s labware latch from your protocol using :py:meth:`.open_labware_latch` and :py:meth:`.close_labware_latch`. Shaking requires the labware latch to be closed, so you may want to issue a close command before the first shake command in your protocol: .. code-block:: python hs_mod.close_labware_latch() hs_mod.set_and_wait_for_shake_speed(500) If the labware latch is already closed, ``close_labware_latch()`` will succeed immediately; you don’t have to check the status of the latch before opening or closing it. To prepare the deck before running a protocol, use the labware latch controls in the Opentrons App or run these methods in Jupyter notebook. Loading Labware =============== Use the Heater-Shaker’s :py:meth:`~.HeaterShakerContext.load_adapter` and :py:meth:`~.HeaterShakerContext.load_labware` methods to specify what you will place on the module. For the Heater-Shaker, use one of the thermal adapters listed below and labware that fits on the adapter. See :ref:`labware-on-adapters` for examples of loading labware on modules. The `Opentrons Labware Library &amp;lt;https://labware.opentrons.com/&amp;gt;`_ includes definitions for both standalone adapters and adapter–labware combinations. These labware definitions help make the Heater-Shaker ready to use right out of the box. .. note:: If you plan to :ref:`move labware &amp;lt;moving-labware&amp;gt;` onto or off of the Heater-Shaker during your protocol, you must use a standalone adapter definition, not an adapter–labware combination definiton. Standalone Adapters ------------------- You can use these standalone adapter definitions to load Opentrons verified or custom labware on top of the Heater-Shaker. .. list-table:: :header-rows: 1 * - Adapter Type - API Load Name * - Opentrons Universal Flat Heater-Shaker Adapter - ``opentrons_universal_flat_adapter`` * - Opentrons 96 PCR Heater-Shaker Adapter - ``opentrons_96_pcr_adapter`` * - Opentrons 96 Deep Well Heater-Shaker Adapter - ``opentrons_96_deep_well_adapter`` * - Opentrons 96 Flat Bottom Heater-Shaker Adapter - ``opentrons_96_flat_bottom_adapter`` For example, these commands load a well plate on top of the flat bottom adapter:: hs_adapter = hs_mod.load_adapter(&quot;opentrons_96_flat_bottom_adapter&quot;) hs_plate = hs_adapter.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;) .. versionadded:: 2.15 The ``load_adapter()`` method. Pre-configured Combinations --------------------------- The Heater-Shaker supports these thermal adapter and labware combinations for backwards compatibility. If your protocol specifies an ``apiLevel`` of 2.15 or higher, you should use the standalone adapter definitions instead. .. list-table:: :header-rows: 1 * - Adapter/Labware Combination - API Load Name * - Opentrons 96 Deep Well Adapter with NEST Deep Well Plate 2 mL - ``opentrons_96_deep_well_adapter_nest_wellplate_2ml_deep`` * - Opentrons 96 Flat Bottom Adapter with NEST 96 Well Plate 200 µL Flat - ``opentrons_96_flat_bottom_adapter_nest_wellplate_200ul_flat`` * - Opentrons 96 PCR Adapter with Armadillo Well Plate 200 µL - ``opentrons_96_pcr_adapter_armadillo_wellplate_200ul`` * - Opentrons 96 PCR Adapter with NEST Well Plate 100 µL - ``opentrons_96_pcr_adapter_nest_wellplate_100ul_pcr_full_skirt`` * - Opentrons Universal Flat Adapter with Corning 384 Well Plate 112 µL Flat - ``opentrons_universal_flat_adapter_corning_384_wellplate_112ul_flat`` This command loads the same physical adapter and labware as the example in the previous section, but it is also compatible with API versions 2.13 and 2.14:: hs_combo = hs_mod.load_labware( &quot;opentrons_96_flat_bottom_adapter_nest_wellplate_200ul_flat&quot; ) .. versionadded:: 2.13 Custom Flat-Bottom Labware -------------------------- Custom flat-bottom labware can be used with the Universal Flat Adapter. See the support article `Requesting a Custom Labware Definition &amp;lt;https://support.opentrons.com/s/article/Requesting-a-custom-labware-definition&amp;gt;`_ if you need assistance creating custom labware definitions for the Heater-Shaker. Heating and Shaking =================== The API treats heating and shaking as separate, independent activities due to the amount of time they take. Increasing or reducing shaking speed takes a few seconds, so the API treats these actions as *blocking* commands. All other commands cannot run until the module reaches the required speed. Heating the module, or letting it passively cool, takes more time than changing the shaking speed. As a result, the API gives you the flexibility to perform other pipetting actions while waiting for the module to reach a target temperature. When holding at temperature, you can design your protocol to run in a blocking or non-blocking manner. .. note:: Since API version 2.13, only the Heater-Shaker Module supports non-blocking command execution. All other modules&apos; methods are blocking commands. Blocking commands ----------------- This example uses a blocking command and shakes a sample for one minute. No other commands will execute until a minute has elapsed. The three commands in this example start the shake, wait for one minute, and then stop the shake:: hs_mod.set_and_wait_for_shake_speed(500) protocol.delay(minutes=1) hs_mod.deactivate_shaker() These actions will take about 65 seconds total. Compare this with similar-looking commands for holding a sample at a temperature for one minute: .. code-block:: python hs_mod.set_and_wait_for_temperature(75) protocol.delay(minutes=1) hs_mod.deactivate_heater() This may take much longer, depending on the thermal block used, the volume and type of liquid contained in the labware, and the initial temperature of the module. Non-blocking commands --------------------- To pipette while the Heater-Shaker is heating, use :py:meth:`~.HeaterShakerContext.set_target_temperature` and :py:meth:`~.HeaterShakerContext.wait_for_temperature` instead of :py:meth:`~.HeaterShakerContext.set_and_wait_for_temperature`: .. code-block:: python hs_mod.set_target_temperature(75) pipette.pick_up_tip() pipette.aspirate(50, plate[&quot;A1&quot;]) pipette.dispense(50, plate[&quot;B1&quot;]) pipette.drop_tip() hs_mod.wait_for_temperature() protocol.delay(minutes=1) hs_mod.deactivate_heater() This example would likely take just as long as the blocking version above; it’s unlikely that one aspirate and one dispense action would take longer than the time for the module to heat. However, be careful when putting a lot of commands between a ``set_target_temperature()`` call and a ``delay()`` call. In this situation, you’re relying on ``wait_for_temperature()`` to resume execution of commands once heating is complete. But if the temperature has already been reached, the delay will begin later than expected and the Heater-Shaker will hold at its target temperature longer than intended. Additionally, if you want to pipette while the module holds a temperature for a certain length of time, you need to track the holding time yourself. One of the simplest ways to do this is with Python’s ``time`` module. First, add ``import time`` at the start of your protocol. Then, use :py:func:`time.monotonic` to set a reference time when the target is reached. Finally, add a delay that calculates how much holding time is remaining after the pipetting actions: .. code-block:: python hs_mod.set_and_wait_for_temperature(75) start_time = time.monotonic() # set reference time pipette.pick_up_tip() pipette.aspirate(50, plate[&quot;A1&quot;]) pipette.dispense(50, plate[&quot;B1&quot;]) pipette.drop_tip() # delay for the difference between now and 60 seconds after the reference time protocol.delay(max(0, start_time+60 - time.monotonic())) hs_mod.deactivate_heater() Provided that the parallel pipetting actions don’t take more than one minute, this code will deactivate the heater one minute after its target was reached. If more than one minute has elapsed, the value passed to ``protocol.delay()`` will equal 0, and the protocol will continue immediately. Deactivating ============ Deactivating the heater and shaker are done separately using the :py:meth:`~.HeaterShakerContext.deactivate_heater` and :py:meth:`~.HeaterShakerContext.deactivate_shaker` methods, respectively. There is no method to deactivate both simultaneously. Call the two methods in sequence if you need to stop both heating and shaking. .. note:: The robot will not automatically deactivate the Heater-Shaker at the end of a protocol. If you need to deactivate the module after a protocol is completed or canceled, use the Heater-Shaker module controls on the device detail page in the Opentrons App or run these methods in Jupyter notebook.</content></file><file name="magnetic_block.rst" type="rst"><content>:og:description: How to use the Magnetic Block with the Flex Gripper in a Python protocol. .. _magnetic-block: ************** Magnetic Block ************** .. note:: The Magnetic Block is compatible with Opentrons Flex only. If you have an OT-2, use the :ref:`Magnetic Module &amp;lt;magnetic-module&amp;gt;`. The Magnetic Block is an unpowered, 96-well plate that holds labware close to its high-strength neodymium magnets. This module is suitable for many magnetic bead-based protocols, but does not move beads up or down in solution. Because the Magnetic Block is unpowered, neither your robot nor the Opentrons App aware of this module. You &quot;control&quot; it via protocols to load labware onto the module and use the Opentrons Flex Gripper to move labware on and off the module. See :ref:`moving-labware` for more information. The Magnetic Block is represented by a :py:class:`~opentrons.protocol_api.MagneticBlockContext` object which lets you load labware on top of the module. .. code-block:: python # Load the Magnetic Block in deck slot D1 magnetic_block = protocol.load_module( module_name=&quot;magneticBlockV1&quot;, location=&quot;D1&quot; ) # Load a 96-well plate on the magnetic block mag_plate = magnetic_block.load_labware( name=&quot;biorad_96_wellplate_200ul_pcr&quot; ) # Use the Gripper to move labware protocol.move_labware(mag_plate, new_location=&quot;B2&quot;, use_gripper=True) .. versionadded:: 2.15</content></file><file name="magnetic_module.rst" type="rst"><content>:og:description: How to engage and disengage the Magnetic Module for the OT-2 in a Python protocol. .. _magnetic-module: *************** Magnetic Module *************** .. note:: The Magnetic Module is compatible with the OT-2 only. If you have a Flex, use the :ref:`Magnetic Block &amp;lt;magnetic-block&amp;gt;`. The Magnetic Module controls a set of permanent magnets which can move vertically to induce a magnetic field in the labware loaded on the module. The Magnetic Module is represented by a :py:class:`.MagneticModuleContext` object, which has methods for engaging (raising) and disengaging (lowering) its magnets. The examples in this section apply to an OT-2 with a Magnetic Module GEN2 loaded in slot 6: .. code-block:: python def run(protocol: protocol_api.ProtocolContext): mag_mod = protocol.load_module( module_name=&quot;magnetic module gen2&quot;, location=&quot;6&quot;) plate = mag_mod.load_labware( name=&quot;nest_96_wellplate_100ul_pcr_full_skirt&quot;) .. versionadded:: 2.3 Loading Labware =============== Like with all modules, use the Magnetic Module’s :py:meth:`~.MagneticModuleContext.load_labware` method to specify what you will place on the module. The Magnetic Module supports 96-well PCR plates and deep well plates. For the best compatibility, use a labware definition that specifies how far the magnets should move when engaging with the labware. The following plates in the `Opentrons Labware Library &amp;lt;https://labware.opentrons.com/&amp;gt;`_ include this measurement: .. list-table:: :widths: 50 50 :header-rows: 1 * - Labware Name - API Load Name * - Bio-Rad 96 Well Plate 200 µL PCR - ``biorad_96_wellplate_200ul_pcr`` * - NEST 96 Well Plate 100 µL PCR Full Skirt - ``nest_96_wellplate_100ul_pcr_full_skirt`` * - NEST 96 Deep Well Plate 2mL - ``nest_96_wellplate_2ml_deep`` * - Thermo Scientific Nunc 96 Well Plate 1300 µL - ``thermoscientificnunc_96_wellplate_1300ul`` * - Thermo Scientific Nunc 96 Well Plate 2000 µL - ``thermoscientificnunc_96_wellplate_2000ul`` * - USA Scientific 96 Deep Well Plate 2.4 mL - ``usascientific_96_wellplate_2.4ml_deep`` To check whether a custom labware definition specifies this measurement, load the labware and query its :py:attr:`~.Labware.magdeck_engage_height` property. If has a numerical value, the labware is ready for use with the Magnetic Module. .. _magnetic-module-engage: Engaging and Disengaging ======================== Raise and lower the module&apos;s magnets with the :py:meth:`~.MagneticModuleContext.engage` and :py:meth:`~.MagneticModuleContext.disengage` functions, respectively. If your loaded labware is fully compatible with the Magnetic Module, you can call ``engage()`` with no argument: .. code-block:: python mag_mod.engage() .. versionadded:: 2.0 This will move the magnets upward to the default height for the labware, which should be close to the bottom of the labware&apos;s wells. If your loaded labware doesn&apos;t specify a default height, this will raise an ``ExceptionInProtocolError``. For certain applications, you may want to move the magnets to a different height. The recommended way is to use the ``height_from_base`` parameter, which represents the distance above the base of the labware (its lowest point, where it rests on the module). Setting ``height_from_base=0`` should move the tops of the magnets level with the base of the labware. Alternatively, you can use the ``offset`` parameter, which represents the distance above *or below* the labware&apos;s default position (close to the bottom of its wells). Like using ``engage()`` with no argument, this will raise an error if there is no default height for the loaded labware. .. note:: There is up to 1 mm of manufacturing variance across Magnetic Module units, so observe the exact position and adjust as necessary before running your protocol. Here are some examples of where the magnets will move when using the different parameters in combination with the loaded NEST PCR plate, which specifies a default height of 20 mm: .. code-block:: python mag_mod.engage(height_from_base=13.5) # 13.5 mm mag_mod.engage(offset=-2) # 15.5 mm Note that ``offset`` takes into account the fact that the magnets&apos; home position is measured as −2.5 mm for GEN2 modules. .. versionadded:: 2.0 .. versionchanged:: 2.2 Added the ``height_from_base`` parameter. When you need to retract the magnets back to their home position, call :py:meth:`~.MagneticModuleContext.disengage`. .. code-block:: python mag_mod.disengage() # -2.5 mm .. versionadded:: 2.0 If at any point you need to check whether the magnets are engaged or not, use the :py:obj:`~.MagneticModuleContext.status` property. This will return either the string ``engaged`` or ``disengaged``, not the exact height of the magnets. .. note:: The OT-2 will not automatically deactivate the Magnetic Module at the end of a protocol. If you need to deactivate the module after a protocol is completed or canceled, use the Magnetic Module controls on the device detail page in the Opentrons App or run ``deactivate()`` in Jupyter notebook. Changes with the GEN2 Magnetic Module ===================================== The GEN2 Magnetic Module uses smaller magnets than the GEN1 version. This change helps mitigate an issue with the magnets attracting beads from their retracted position, but it also takes longer for the GEN2 module to attract beads. The recommended attraction time is 5 minutes for liquid volumes up to 50 µL and 7 minutes for volumes greater than 50 µL. If your application needs additional magnetic strength to attract beads within these timeframes, use the available `Adapter Magnets &amp;lt;https://support.opentrons.com/s/article/Adapter-magnets&amp;gt;`_.</content></file><file name="multiple_same_type.rst" type="rst"><content>:og:description: How to load and control multiple modules of the same type in a Python protocol. .. _moam: ********************************* Multiple Modules of the Same Type ********************************* You can use multiple modules of the same type within a single protocol. The exception is the Thermocycler Module, which has only one supported deck location because of its size. Running protocols with multiple modules of the same type requires version 4.3 or newer of the Opentrons App and robot server. When working with multiple modules of the same type, load them in your protocol according to their USB port number. Deck coordinates are required by the :py:meth:`~.ProtocolContext.load_labware` method, but location does not determine which module loads first. Your robot will use the module with the lowest USB port number *before* using a module of the same type that&apos;s connected to higher numbered USB port. The USB port number (not deck location) determines module load sequence, starting with the lowest port number first. .. Recommend being formal-ish with protocol code samples. .. tabs:: .. tab:: Flex In this example, ``temperature_module_1`` loads first because it&apos;s connected to USB port 2. ``temperature_module_2`` loads next because it&apos;s connected to USB port 6. .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # Load Temperature Module 1 in deck slot D1 on USB port 2 temperature_module_1 = protocol.load_module( module_name=&quot;temperature module gen2&quot;, location=&quot;D1&quot;) # Load Temperature Module 2 in deck slot C1 on USB port 6 temperature_module_2 = protocol.load_module( module_name=&quot;temperature module gen2&quot;, location=&quot;C1&quot;) The Temperature Modules are connected as shown here: .. image:: ../../img/modules/flex-usb-order.png :width: 250 .. tab:: OT-2 In this example, ``temperature_module_1`` loads first because it&apos;s connected to USB port 1. ``temperature_module_2`` loads next because it&apos;s connected to USB port 3. .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # Load Temperature Module 1 in deck slot C1 on USB port 1 temperature_module_1 = protocol.load_module( load_name=&quot;temperature module gen2&quot;, location=&quot;1&quot; ) # Load Temperature Module 2 in deck slot D3 on USB port 2 temperature_module_2 = protocol.load_module( load_name=&quot;temperature module gen2&quot;, location=&quot;3&quot; ) The Temperature Modules are connected as shown here: .. image:: ../../img/modules/multiples_of_a_module.svg Before running your protocol, it&apos;s a good idea to use the module controls in the Opentrons App to check that commands are being sent where you expect. See the support article `Using Modules of the Same Type &amp;lt;https://support.opentrons.com/s/article/Using-modules-of-the-same-type-on-the-OT-2&amp;gt;`_ for more information.</content></file><file name="setup.rst" type="rst"><content>:og:description: How to load Opentrons hardware modules with adapters and labware in a Python protocol. .. _module-setup: ************ Module Setup ************ Loading Modules onto the Deck ============================= Similar to labware and pipettes, you must inform the API about the modules you want to use in your protocol. Even if you don&apos;t use the module anywhere else in your protocol, the Opentrons App and the robot won&apos;t let you start the protocol run until all loaded modules that use power are connected via USB and turned on. Use :py:meth:`.ProtocolContext.load_module` to load a module. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # Load a Heater-Shaker Module GEN1 in deck slot D1. heater_shaker = protocol.load_module( module_name=&quot;heaterShakerModuleV1&quot;, location=&quot;D1&quot;) # Load a Temperature Module GEN2 in deck slot D3. temperature_module = protocol.load_module( module_name=&quot;temperature module gen2&quot;, location=&quot;D3&quot;) After the ``load_module()`` method loads the modules into your protocol, it returns the :py:class:`~opentrons.protocol_api.HeaterShakerContext` and :py:class:`~opentrons.protocol_api.TemperatureModuleContext` objects. .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # Load a Magnetic Module GEN2 in deck slot 1. magnetic_module = protocol.load_module( module_name=&quot;magnetic module gen2&quot;, location=1) # Load a Temperature Module GEN1 in deck slot 3. temperature_module = protocol.load_module( module_name=&quot;temperature module&quot;, location=3) After the ``load_module()`` method loads the modules into your protocol, it returns the :py:class:`~opentrons.protocol_api.MagneticModuleContext` and :py:class:`~opentrons.protocol_api.TemperatureModuleContext` objects. .. versionadded:: 2.0 .. _available_modules: Available Modules ----------------- The first parameter of :py:meth:`.ProtocolContext.load_module` is the module&apos;s *API load name*. The load name tells your robot which module you&apos;re going to use in a protocol. The table below lists the API load names for the currently available modules. .. table:: :widths: 4 4 2 +--------------------+-------------------------------+---------------------------+ | Module | API Load Name | Introduced in API Version | +====================+===============================+===========================+ | Temperature Module | ``temperature module`` | 2.0 | | GEN1 | or ``tempdeck`` | | +--------------------+-------------------------------+---------------------------+ | Temperature Module | ``temperature module gen2`` | 2.3 | | GEN2 | | | +--------------------+-------------------------------+---------------------------+ | Magnetic Module | ``magnetic module`` | 2.0 | | GEN1 | or ``magdeck`` | | +--------------------+-------------------------------+---------------------------+ | Magnetic Module | ``magnetic module gen2`` | 2.3 | | GEN2 | | | +--------------------+-------------------------------+---------------------------+ | Thermocycler | ``thermocycler module`` | 2.0 | | Module GEN1 | or ``thermocycler`` | | +--------------------+-------------------------------+---------------------------+ | Thermocycler | ``thermocycler module gen2`` | 2.13 | | Module GEN2 | or ``thermocyclerModuleV2`` | | +--------------------+-------------------------------+---------------------------+ | Heater-Shaker | ``heaterShakerModuleV1`` | 2.13 | | Module GEN1 | | | +--------------------+-------------------------------+---------------------------+ | Magnetic Block | ``magneticBlockV1`` | 2.15 | | GEN1 | | | +--------------------+-------------------------------+---------------------------+ | Absorbance Plate | ``absorbanceReaderV1`` | 2.21 | | Reader Module | | | +--------------------+-------------------------------+---------------------------+ Some modules were added to our Python API later than others, and others span multiple hardware generations. When writing a protocol that requires a module, make sure your ``requirements`` or ``metadata`` code block specifies an :ref:`API version &amp;lt;v2-versioning&amp;gt;` high enough to support all the module generations you want to use. .. _load-labware-module: Loading Labware onto a Module ============================= Use the ``load_labware()`` method on the module context to load labware on a module. For example, to load the `Opentrons 24 Well Aluminum Block &amp;lt;https://labware.opentrons.com/opentrons_24_aluminumblock_generic_2ml_screwcap?category=aluminumBlock&amp;gt;`_ on top of a Temperature Module:: def run(protocol: protocol_api.ProtocolContext): temp_mod = protocol.load_module( module_name=&quot;temperature module gen2&quot;, location=&quot;D1&quot;) temp_labware = temp_mod.load_labware( name=&quot;opentrons_24_aluminumblock_generic_2ml_screwcap&quot;, label=&quot;Temperature-Controlled Tubes&quot;) .. versionadded:: 2.0 When you load labware on a module, you don’t need to specify the deck slot. In the above example, the ``load_module()`` method already specifies where the module is on the deck: ``location= &quot;D1&quot;``. Any :ref:`custom labware &amp;lt;v2-custom-labware&amp;gt;` added to your Opentrons App is also accessible when loading labware onto a module. You can find and copy its load name by going to its card on the Labware page. .. versionadded:: 2.1 Module and Labware Compatibility -------------------------------- It&apos;s your responsibility to ensure the labware and module combinations you load together work together. The API generally won&apos;t raise a warning or error if you load an unusual combination, like placing a tube rack on a Thermocycler. The API will raise an error if you try to load a labware on an unsupported adapter. When working with custom labware and module adapters, be sure to add stacking offsets for the adapter to your custom labware definition. Additional Labware Parameters ----------------------------- In addition to the mandatory ``load_name`` argument, you can also specify additional parameters. For example, if you specify a ``label``, this name will appear in the Opentrons App and the run log instead of the load name. For labware that has multiple definitions, you can specify ``version`` and ``namespace`` (though most of the time you won&apos;t have to). The :py:meth:`~.ProtocolContext.load_labware` methods of all module contexts accept these additional parameters.</content></file><file name="temperature_module.rst" type="rst"><content>:og:description: How to heat and cool with the Temperature Module in a Python protocol. .. _temperature-module: ****************** Temperature Module ****************** The Temperature Module acts as both a cooling and heating device. It can control the temperature of its deck between 4 °C and 95 °C with a resolution of 1 °C. The Temperature Module is represented in code by a :py:class:`.TemperatureModuleContext` object, which has methods for setting target temperatures and reading the module&apos;s status. This example demonstrates loading a Temperature Module GEN2 and loading a well plate on top of it. .. code-block:: python temp_mod = protocol.load_module( module_name=&quot;temperature module gen2&quot;, location=&quot;D3&quot; ) .. versionadded:: 2.3 Loading Labware =============== Use the Temperature Module’s :py:meth:`~.TemperatureModuleContext.load_adapter` and :py:meth:`~.TemperatureModuleContext.load_labware` methods to specify what you will place on the module. You may use one or both of the methods, depending on the labware you&apos;re using. See :ref:`labware-on-adapters` for examples of loading labware on modules. The `Opentrons Labware Library &amp;lt;https://labware.opentrons.com/&amp;gt;`_ includes definitions for both standalone adapters and adapter–labware combinations. These labware definitions help make the Temperature Module ready to use right out of the box. Standalone Adapters ------------------- You can use these standalone adapter definitions to load Opentrons verified or custom labware on top of the Temperature Module. .. list-table:: :header-rows: 1 * - Adapter Type - API Load Name * - Opentrons Aluminum Flat Bottom Plate - ``opentrons_aluminum_flat_bottom_plate`` * - Opentrons 96 Well Aluminum Block - ``opentrons_96_well_aluminum_block`` * - Opentrons 96 Deep Well Temperature Module Adapter - ``opentrons_96_deep_well_temp_mod_adapter`` For example, these commands load a PCR plate on top of the 96-well block:: temp_adapter = temp_mod.load_adapter( &quot;opentrons_96_well_aluminum_block&quot; ) temp_plate = temp_adapter.load_labware( &quot;nest_96_wellplate_100ul_pcr_full_skirt&quot; ) .. versionadded:: 2.15 The ``load_adapter()`` method. .. note:: You can also load labware directly onto the Temperature Module. In API version 2.14 and earlier, this was the correct way to load labware on top of the flat bottom plate. In API version 2.15 and later, you should load both the adapter and the labware with separate commands. Block-and-tube combinations --------------------------- You can use these combination labware definitions to load various types of tubes into the 24-well thermal block on top of the Temperature Module. There is no standalone definition for the 24-well block. .. list-table:: :header-rows: 1 * - Tube Type - API Load Name * - Generic 2 mL screw cap - ``opentrons_24_aluminumblock_generic_2ml_screwcap`` * - NEST 0.5 mL screw cap - ``opentrons_24_aluminumblock_nest_0.5ml_screwcap`` * - NEST 1.5 mL screw cap - ``opentrons_24_aluminumblock_nest_1.5ml_screwcap`` * - NEST 1.5 mL snap cap - ``opentrons_24_aluminumblock_nest_1.5ml_snapcap`` * - NEST 2 mL screw cap - ``opentrons_24_aluminumblock_nest_2ml_screwcap`` * - NEST 2 mL snap cap - ``opentrons_24_aluminumblock_nest_2ml_snapcap`` For example, this command loads the 24-well block with generic 2 mL tubes:: temp_tubes = temp_mod.load_labware( &quot;opentrons_24_aluminumblock_generic_2ml_screwcap&quot; ) .. versionadded:: 2.0 Block-and-plate combinations ---------------------------- The Temperature Module supports these 96-well block and labware combinations for backwards compatibility. If your protocol specifies an ``apiLevel`` of 2.15 or higher, you should use the standalone 96-well block definition instead. .. list-table:: :header-rows: 1 * - 96-well block contents - API Load Name * - Bio-Rad well plate 200 µL - ``opentrons_96_aluminumblock_biorad_wellplate_200uL`` * - Generic PCR strip 200 µL - ``opentrons_96_aluminumblock_generic_pcr_strip_200uL`` * - NEST well plate 100 µL - ``opentrons_96_aluminumblock_nest_wellplate_100uL`` This command loads the same physical adapter and labware as the example in the Standalone Adapters section above, but it is also compatible with earlier API versions:: temp_combo = temp_mod.load_labware( &quot;opentrons_96_aluminumblock_nest_wellplate_100uL&quot; ) .. versionadded:: 2.0 Temperature Control =================== The primary function of the module is to control the temperature of its deck, using :py:meth:`~.TemperatureModuleContext.set_temperature`, which takes one parameter: ``celsius``. For example, to set the Temperature Module to 4 °C: .. code-block:: python temp_mod.set_temperature(celsius=4) When using ``set_temperature()``, your protocol will wait until the target temperature is reached before proceeding to further commands. In other words, you can pipette to or from the Temperature Module when it is holding at a temperature or idle, but not while it is actively changing temperature. Whenever the module reaches its target temperature, it will hold the temperature until you set a different target or call :py:meth:`~.TemperatureModuleContext.deactivate`, which will stop heating or cooling and will turn off the fan. .. note:: Your robot will not automatically deactivate the Temperature Module at the end of a protocol. If you need to deactivate the module after a protocol is completed or canceled, use the Temperature Module controls on the device detail page in the Opentrons App or run ``deactivate()`` in Jupyter notebook. .. versionadded:: 2.0 Temperature Status ================== If you need to confirm in software whether the Temperature Module is holding at a temperature or is idle, use the :py:obj:`~.TemperatureModuleContext.status` property: .. code-block:: python temp_mod.set_temperature(celsius=90) temp_mod.status # &quot;holding at target&quot; temp_mod.deactivate() temp_mod.status # &quot;idle&quot; If you don&apos;t need to use the status value in your code, and you have physical access to the module, you can read its status and temperature from the LED and display on the module. .. versionadded:: 2.0 Changes with the GEN2 Temperature Module ======================================== All methods of :py:class:`.TemperatureModuleContext` work with both the GEN1 and GEN2 Temperature Module. Physically, the GEN2 module has a plastic insulating rim around the plate, and plastic insulating shrouds designed to fit over Opentrons aluminum blocks. This mitigates an issue where the GEN1 module would have trouble cooling to very low temperatures, especially if it shared the deck with a running Thermocycler.</content></file><file name="thermocycler.rst" type="rst"><content>:og:description: How to control the lid, block, and temperature profile of the Thermocycler Module in a Python protocol. .. _thermocycler-module: ******************* Thermocycler Module ******************* The Thermocycler Module provides on-deck, fully automated thermocycling, and can heat and cool very quickly during operation. The module&apos;s block can reach and maintain temperatures between 4 and 99 °C. The module&apos;s lid can heat up to 110 °C. The Thermocycler is represented in code by a :py:class:`.ThermocyclerContext` object, which has methods for controlling the lid, controlling the block, and setting *profiles* — timed heating and cooling routines that can be repeated automatically. The examples in this section will use a Thermocycler Module GEN2 loaded as follows: .. code-block:: python tc_mod = protocol.load_module(module_name=&quot;thermocyclerModuleV2&quot;) plate = tc_mod.load_labware(name=&quot;opentrons_96_wellplate_200ul_pcr_full_skirt&quot;) .. versionadded:: 2.13 Lid Control =========== The Thermocycler can control the position and temperature of its lid. To change the lid position, use :py:meth:`~.ThermocyclerContext.open_lid` and :py:meth:`~.ThermocyclerContext.close_lid`. When the lid is open, the pipettes can access the loaded labware. You can also control the temperature of the lid. Acceptable target temperatures are between 37 and 110 °C. Use :py:meth:`~.ThermocyclerContext.set_lid_temperature`, which takes one parameter: the target ``temperature`` (in degrees Celsius) as an integer. For example, to set the lid to 50 °C: .. code-block:: python tc_mod.set_lid_temperature(temperature=50) The protocol will only proceed once the lid temperature reaches 50 °C. This is the case whether the previous temperature was lower than 50 °C (in which case the lid will actively heat) or higher than 50 °C (in which case the lid will passively cool). You can turn off the lid heater at any time with :py:meth:`~.ThermocyclerContext.deactivate_lid`. .. note:: Lid temperature is not affected by Thermocycler profiles. Therefore you should set an appropriate lid temperature to hold during your profile *before* executing it. See :ref:`thermocycler-profiles` for more information on defining and executing profiles. .. versionadded:: 2.0 Block Control ============= The Thermocycler can control its block temperature, including holding at a temperature and adjusting for the volume of liquid held in its loaded plate. Temperature ----------- To set the block temperature inside the Thermocycler, use :py:meth:`~.ThermocyclerContext.set_block_temperature`. At minimum you have to specify a ``temperature`` in degrees Celsius: .. code-block:: python tc_mod.set_block_temperature(temperature=4) If you don&apos;t specify any other parameters, the Thermocycler will hold this temperature until a new temperature is set, :py:meth:`~.ThermocyclerContext.deactivate_block` is called, or the module is powered off. .. versionadded:: 2.0 Hold Time --------- You can optionally instruct the Thermocycler to hold its block temperature for a specific amount of time. You can specify ``hold_time_minutes``, ``hold_time_seconds``, or both (in which case they will be added together). For example, this will set the block to 4 °C for 4 minutes and 15 seconds:: tc_mod.set_block_temperature( temperature=4, hold_time_minutes=4, hold_time_seconds=15) .. note :: Your protocol will not proceed to further commands while holding at a temperature. If you don&apos;t specify a hold time, the protocol will proceed as soon as the target temperature is reached. .. versionadded:: 2.0 Block Max Volume ---------------- The Thermocycler&apos;s block temperature controller varies its behavior based on the amount of liquid in the wells of its labware. Accurately specifying the liquid volume allows the Thermocycler to more precisely control the temperature of the samples. You should set the ``block_max_volume`` parameter to the amount of liquid in the *fullest* well, measured in µL. If not specified, the Thermocycler will assume samples of 25 µL. It is especially important to specify ``block_max_volume`` when holding at a temperature. For example, say you want to hold larger samples at a temperature for a short time:: tc_mod.set_block_temperature( temperature=4, hold_time_seconds=20, block_max_volume=80) If the Thermocycler assumes these samples are 25 µL, it may not cool them to 4 °C before starting the 20-second timer. In fact, with such a short hold time they may not reach 4 °C at all! .. versionadded:: 2.0 .. _thermocycler-profiles: Thermocycler Profiles ===================== In addition to executing individual temperature commands, the Thermocycler can automatically cycle through a sequence of block temperatures to perform heat-sensitive reactions. These sequences are called *profiles*, which are defined in the Protocol API as lists of dictionaries. Each dictionary within the profile should have a ``temperature`` key, which specifies the temperature of the step, and either or both of ``hold_time_seconds`` and ``hold_time_minutes``, which specify the duration of the step. For example, this profile commands the Thermocycler to reach 10 °C and hold for 30 seconds, and then to reach 60 °C and hold for 45 seconds: .. code-block:: python profile = [ {&quot;temperature&quot;:10, &quot;hold_time_seconds&quot;:30}, {&quot;temperature&quot;:60, &quot;hold_time_seconds&quot;:45} ] Once you have written the steps of your profile, execute it with :py:meth:`~.ThermocyclerContext.execute_profile`. This function executes your profile steps multiple times depending on the ``repetitions`` parameter. It also takes a ``block_max_volume`` parameter, which is the same as that of the :py:meth:`~.ThermocyclerContext.set_block_temperature` function. For instance, a PCR prep protocol might define and execute a profile like this: .. code-block:: python profile = [ {&quot;temperature&quot;:95, &quot;hold_time_seconds&quot;:30}, {&quot;temperature&quot;:57, &quot;hold_time_seconds&quot;:30}, {&quot;temperature&quot;:72, &quot;hold_time_seconds&quot;:60} ] tc_mod.execute_profile(steps=profile, repetitions=20, block_max_volume=32) In terms of the actions that the Thermocycler performs, this would be equivalent to nesting ``set_block_temperature`` commands in a ``for`` loop: .. code-block:: python for i in range(20): tc_mod.set_block_temperature(95, hold_time_seconds=30, block_max_volume=32) tc_mod.set_block_temperature(57, hold_time_seconds=30, block_max_volume=32) tc_mod.set_block_temperature(72, hold_time_seconds=60, block_max_volume=32) However, this code would generate 60 lines in the protocol&apos;s run log, while executing a profile is summarized in a single line. Additionally, you can set a profile once and execute it multiple times (with different numbers of repetitions and maximum volumes, if needed). .. note:: Temperature profiles only control the temperature of the `block` in the Thermocycler. You should set a lid temperature before executing the profile using :py:meth:`~.ThermocyclerContext.set_lid_temperature`. .. versionadded:: 2.0 Auto-sealing Lids ================= Starting in robot software version 8.2.0, you can use the Opentrons Tough PCR Auto-sealing Lid to reduce evaporation on the Thermocycler. The auto-sealing lids are designed for automated use with the Flex Gripper, although you can move them manually if needed. They also work with the Opentrons Flex Deck Riser adapter, which keeps lids away from the unsterilized deck and provides better access for the gripper. Use the following API load names for the auto-sealing lid and deck riser: .. list-table:: :header-rows: 1 * - Labware - API load name * - Opentrons Tough PCR Auto-sealing Lid - ``opentrons_tough_pcr_auto_sealing_lid`` * - Opentrons Flex Deck Riser - ``opentrons_flex_deck_riser`` Load the riser directly onto the deck with :py:meth:`.ProtocolContext.load_adapter`. Load the auto-sealing lid onto a compatible location (the deck, the riser, or another lid) with the appropriate ``load_labware()`` method. You can create a stack of up to five auto-sealing lids. If you try to stack more than five lids, the API will raise an error. Setting up the riser and preparing a lid to use on the Thermocycler generally consists of the following steps: 1. Load the riser on the deck. 2. Load the lids onto the adapter. 3. Load or move a PCR plate onto the Thermocycler. 4. Move a lid onto the PCR plate. 5. Close the Thermocycler. The following code sample shows how to perform these steps, using the riser and three auto-sealing lids. In a full protocol, you would likely have additional steps, such as pipetting to or from the PCR plate. .. code-block:: python # load riser riser = protocol.load_adapter( load_name=&quot;opentrons_flex_deck_riser&quot;, location=&quot;A2&quot; ) # load three lids lid_1 = riser.load_labware(&quot;opentrons_tough_pcr_auto_sealing_lid&quot;) lid_2 = lid_1.load_labware(&quot;opentrons_tough_pcr_auto_sealing_lid&quot;) lid_3 = lid_2.load_labware(&quot;opentrons_tough_pcr_auto_sealing_lid&quot;) # load plate on Thermocycler plate = protocol.load_labware( load_name=&quot;opentrons_96_wellplate_200ul_pcr_full_skirt&quot;, location=tc_mod ) # move lid to PCR plate protocol.move_labware(labware=lid_3, new_location=plate, use_gripper=True) # close Thermocycler tc_mod.close_lid() .. warning:: When using the auto-sealing lids, `do not` affix a rubber automation seal to the inside of the Thermocycler lid. The Thermocycler will not close properly. When you&apos;re finished with a lid, use the gripper to dispose of it in either the waste chute or a trash bin:: tc_mod.open_lid() protocol.move_labware(labware=lid_3, new_location=trash, use_gripper=True) .. versionadded:: 2.16 :py:class:`.TrashBin` and :py:class:`.WasteChute` objects can accept lids. You can then move the PCR plate off of the Thermocycler. The Flex Gripper can&apos;t move a plate that has a lid on top of it. Always move the lid first, then the plate. Changes with the GEN2 Thermocycler Module ========================================= All methods of :py:class:`.ThermocyclerContext` work with both the GEN1 and GEN2 Thermocycler. One practical difference is that the GEN2 module has a plate lift feature to make it easier to remove the plate manually or with the Opentrons Flex Gripper. To activate the plate lift, press the button on the Thermocycler for three seconds while the lid is open. If you need to do this in the middle of a run, call :py:meth:`~.ProtocolContext.pause`, lift and move the plate, and then resume the run.</content></file></directory><directory name="parameters"><file name="choosing.rst" type="rst"><content>:og:description: Advice on choosing effective parameters in Opentrons Python protocols. .. _good-rtps: ************************ Choosing Good Parameters ************************ The first decision you need to make when adding parameters to your protocol is &quot;What should be parameterized?&quot; Your goals in adding parameters should be the following: 1. **Add flexibility.** Accommodate changes from run to run or from lab to lab. 2. **Work efficiently.** Don&apos;t burden run setup with too many choices or confusing options. 3. **Avoid errors.** Ensure that every combination of parameters produces an analyzable, runnable protocol. The trick to choosing good parameters is reasoning through the choices the protocol&apos;s users may make. If any of them lead to nonsensical outcomes or errors, adjust the parameters — or how your protocol :ref:`uses parameter values &amp;lt;using-rtp&amp;gt;` — to avoid those situations. Build on a Task =============== Consider what scientific task is at the heart of your protocol, and build parameters that contribute to, rather than diverge from it. For example, it makes sense to add a parameter for number of samples to a DNA prep protocol that uses a particular reagent kit. But it wouldn&apos;t make sense to add a parameter for *which reagent kit* to use for DNA prep. That kind of parameter would affect so many aspects of the protocol that it would make more sense to maintain a separate protocol for each kit. Also consider how a small number of parameters can combine to produce many useful outputs. Take the serial dilution task from the :ref:`tutorial` as an example. We could add just three parameters to it: number of dilutions, dilution factor, and number of rows. Now that single protocol can produce a whole plate that gradually dilutes, a 2×4 grid that rapidly dilutes, and *thousands* of other combinations. Consider Contradictions ======================= Here&apos;s a common time-saving use of parameters: your protocol requires a 1-channel pipette and an 8-channel pipette, but it doesn&apos;t matter which mount they&apos;re attached to. Without parameters, you would have to assign the mounts in your protocol. Then if the robot is set up in the reverse configuration, you&apos;d have to either physically swap the pipettes or modify your protocol. One way to get this information is to ask which mount the 1-channel pipette is on, and which mount the 8-channel pipette is on. But if a technician answers &quot;left&quot; to both questions — even by accident — the API will raise an error, because you can&apos;t load two pipettes on a single mount. It&apos;s no better to flip things around by asking which pipette is on the left mount, and which pipette is on the right mount. Now the technician can say that both mounts have a 1-channel pipette. This is even more dangerous, because it *might not* raise any errors in analysis. The protocol could run &quot;successfully&quot; on a robot with two 1-channel pipettes, but produce completely unintended results. The best way to avoid these contradictions is to collapse the two questions into one, with limited choices. Where are the pipettes mounted? Either the 1-channel is on the left and the 8-channel on the right, or the 8-channel is on the left and the 1-channel is on the right. This approach is best for several reasons: - It avoids analysis errors. - It avoids potentially dangerous execution errors. - It only requires answering one question instead of two. - The :ref:`phrasing of the question and answer &amp;lt;rtp-style&amp;gt;` makes it clear that the protocol requires exactly one of each pipette type. Set Boundaries ============== Numerical parameters support minimum and maximum values, which you should set to avoid incorrect inputs that are outside of your protocol&apos;s possibile actions. Consider our earlier example of parameterizing serial dilution. Each of the three numerical parameters have logical upper and lower bounds, which we need to enforce to get sensible results. - *Number of dilutions* must be between 0 and 11 on a 96-well plate. And it may make sense to require at least 1 dilution. - *Dilution factor* is a ratio, which we can express as a decimal number that must be between 0 and 1. - *Number of rows* must be between 1 and 8 on a 96-well plate. What if you wanted to perform a dilution with 20 repetitions? It&apos;s possible with two 96-well plates, or with a 384-well plate. You could set the maximum for the number of dilutions to 24 and allow for these possibilities — either switching the plate type or loading an additional plate based on the provided value. But what if the technician wanted to do just 8 repetitions on a 384-well plate? That would require an additional parameter, an additional choice by the technician, and additional logic in your protocol code. It&apos;s up to you as the protocol author to decide if adding more parameters will make protocol setup overly difficult. Sometimes it&apos;s more efficient to work with two or three simple protocols rather than one that&apos;s long and complex.</content></file><file name="defining.rst" type="rst"><content>:og:description: Define and set possible values for parameters in Opentrons Python protocols. .. _defining-rtp: ******************* Defining Parameters ******************* To use parameters, you need to define them in :ref:`a separate function &amp;lt;add-parameters&amp;gt;` within your protocol. Each parameter definition has two main purposes: to specify acceptable values, and to inform the protocol user what the parameter does. Depending on the :ref:`type of parameter &amp;lt;rtp-types&amp;gt;`, you&apos;ll need to specify some or all of the following. .. list-table:: :header-rows: 1 * - Attribute - Details * - ``variable_name`` - - A unique name for :ref:`referencing the parameter value &amp;lt;using-rtp&amp;gt;` elsewhere in the protocol. - Must meet the usual requirements for `naming objects in Python &amp;lt;https://docs.python.org/3/reference/lexical_analysis.html#identifiers&amp;gt;`__. * - ``display_name`` - - A label for the parameter shown in the Opentrons App or on the touchscreen. - Maximum 30 characters. * - ``description`` - - An optional longer explanation of what the parameter does, or how its values will affect the execution of the protocol. - Maximum 100 characters. * - ``default`` - - The value the parameter will have if the technician makes no changes to it during run setup. * - ``minimum`` and ``maximum`` - - For numeric parameters only. - Allows free entry of any value within the range (inclusive). - Both values are required. - Can&apos;t be used at the same time as ``choices``. * - ``choices`` - - For numeric or string parameters. - Provides a fixed list of values to choose from. - Each choice has its own display name and value. - Can&apos;t be used at the same time as ``minimum`` and ``maximum``. * - ``units`` - - Optional, for numeric parameters with ``minimum`` and ``maximum`` only. - Displays after the number during run setup. - Does not affect the parameter&apos;s value or protocol execution. - Maximum 10 characters. .. _add-parameters: The ``add_parameters()`` Function ================================= All parameter definitions are contained in a Python function, which must be named ``add_parameters`` and takes a single argument. Define ``add_parameters()`` before the ``run()`` function that contains protocol commands. The examples on this page assume the following definition, which uses the argument name ``parameters``. The type specification of the argument is optional. .. code-block:: def add_parameters(parameters: protocol_api.Parameters): Within this function definition, call methods on ``parameters`` to define parameters. The next section demonstrates how each type of parameter has its own method. .. _rtp-types: Types of Parameters =================== The API supports four types of parameters that correspond to Python built-in types: Boolean (:py:class:`bool`), integer (:py:class:`int`), floating point number (:py:class:`float`), and string (:py:class:`str`). It is not possible to mix types within a single parameter. In addition, starting in version 2.20, the API supports CSV files as parameters. All data contained in CSV parameters, including numeric data, is initially interpreted as strings. See :ref:`rtp-csv-data` for more information. Boolean Parameters ------------------ Boolean parameters are ``True`` or ``False`` only. .. code-block:: parameters.add_bool( variable_name=&quot;dry_run&quot;, display_name=&quot;Dry Run&quot;, description=&quot;Skip incubation delays and shorten mix steps.&quot;, default=False ) During run setup, the technician can toggle between the two values. In the Opentrons App, Boolean parameters appear as a toggle switch. On the touchscreen, they appear as *On* or *Off*, for ``True`` and ``False`` respectively. .. versionadded:: 2.18 Integer Parameters ------------------ Integer parameters either accept a range of numbers or a list of numbers. You must specify one or the other; you can&apos;t create an open-ended prompt that accepts any integer. To specify a range, include ``minimum`` and ``maximum``. .. code-block:: parameters.add_int( variable_name=&quot;volume&quot;, display_name=&quot;Aspirate volume&quot;, description=&quot;How much to aspirate from each sample.&quot;, default=20, minimum=10, maximum=100, unit=&quot;µL&quot; ) During run setup, the technician can enter any integer value from the minimum up to the maximum. Entering a value outside of the range will show an error. At that point, they can correct their custom value or restore the default value. To specify a list of numbers, include ``choices``. Each choice is a dictionary with entries for display name and value. The display names let you briefly explain the effect each choice will have. .. code-block:: parameters.add_int( variable_name=&quot;volume&quot;, display_name=&quot;Aspirate volume&quot;, description=&quot;How much to aspirate from each sample.&quot;, default=20, choices=[ {&quot;display_name&quot;: &quot;Low (10 µL)&quot;, &quot;value&quot;: 10}, {&quot;display_name&quot;: &quot;Medium (20 µL)&quot;, &quot;value&quot;: 20}, {&quot;display_name&quot;: &quot;High (50 µL)&quot;, &quot;value&quot;: 50}, ] ) During run setup, the technician can choose from a menu of the provided choices. .. versionadded:: 2.18 Float Parameters ---------------- Float parameters either accept a range of numbers or a list of numbers. You must specify one or the other; you can&apos;t create an open-ended prompt that accepts any floating point number. Specifying a range or list is done exactly the same as in the integer examples above. The only difference is that all values must be floating point numbers. .. code-block:: parameters.add_float( variable_name=&quot;volume&quot;, display_name=&quot;Aspirate volume&quot;, description=&quot;How much to aspirate from each sample.&quot;, default=5.0, choices=[ {&quot;display_name&quot;: &quot;Low (2.5 µL)&quot;, &quot;value&quot;: 2.5}, {&quot;display_name&quot;: &quot;Medium (5 µL)&quot;, &quot;value&quot;: 5.0}, {&quot;display_name&quot;: &quot;High (10 µL)&quot;, &quot;value&quot;: 10.0}, ] ) .. versionadded:: 2.18 String Parameters ----------------- String parameters only accept a list of values. You can&apos;t currently prompt for free text entry of a string value. To specify a list of strings, include ``choices``. Each choice is a dictionary with entries for display name and value. Only the display name will appear during run setup. A common use for string display names is to provide an easy-to-read version of an API load name. You can also use them to briefly explain the effect each choice will have. .. code-block:: parameters.add_str( variable_name=&quot;pipette&quot;, display_name=&quot;Pipette type&quot;, choices=[ {&quot;display_name&quot;: &quot;1-Channel 50 µL&quot;, &quot;value&quot;: &quot;flex_1channel_50&quot;}, {&quot;display_name&quot;: &quot;8-Channel 50 µL&quot;, &quot;value&quot;: &quot;flex_8channel_50&quot;}, ], default=&quot;flex_1channel_50&quot;, ) During run setup, the technician can choose from a menu of the provided choices. .. versionadded:: 2.18 CSV Parameters -------------- CSV parameters accept any valid comma-separated file. You don&apos;t need to specify the format of the data. Due to this flexibility, CSV parameters do not have default values. Separately provide standard operating procedures or template files to the scientists and technicians who will create the tabular data your protocol relies on. Briefly describe the purpose of your CSV parameter when defining it. .. code-block:: parameters.add_csv_file( variable_name=&quot;cherrypicking_wells&quot;, display_name=&quot;Cherrypicking wells&quot;, description=&quot;Table of labware, wells, and volumes to transfer.&quot; ) During run setup, the technician can use the Flex touchscreen to choose a CSV file. They can choose from files on an attached USB drive, or from files already associated with the protocol and stored on the robot. Or in the Opentrons App, they can choose any file on their computer. .. note:: The touchscreen and app currently limit you to selecting one CSV file per run. To match this limitation, the API will raise an error if you define more than one CSV parameter. .. versionadded:: 2.20</content></file><file name="style.rst" type="rst"><content>:og:description: Style and usage guidance for parameters in Opentrons Python protocols. .. _rtp-style: ********************* Parameter Style Guide ********************* It&apos;s important to write clear names and descriptions when you :ref:`define parameters &amp;lt;defining-rtp&amp;gt;` in your protocols. Clarity improves the user experience for the technicians who run your protocols. They rely on your parameter names and descriptions to understand how the robot will function when running your protocol. Adopting the advice of this guide will help make your protocols clear, consistent, and ultimately easy to use. It also aligns them with protocols in the `Opentrons Protocol Library &amp;lt;https://library.opentrons.com&amp;gt;`_, which can help others access and replicate your science. General Guidance ================ **Parameter names are nouns.** Parameters should be discrete enough that you can describe them in a single word or short noun phrase. ``display_name`` is limited to 30 characters, and you can add more context in the description. Don&apos;t ask questions or put other sentence punctuation in parameter names. For example: .. list-table:: * - ✅ Dry run - ❌ Dry run? * - ✅ Sample count - ❌ How many samples? * - ✅ Number of samples - ❌ Number of samples to process. **Parameter descriptions explain actions.** In one or two clauses or sentences, state when and how the parameter value is used in the protocol. Don&apos;t merely restate the parameter name. Punctuate descriptions as sentences, even if they aren&apos;t complete sentences. For example: .. list-table:: :header-rows: 1 :widths: 1 3 * - Parameter name - Parameter description * - Dry run - - ✅ Skip incubation delays and shorten mix steps. - ❌ Whether to do a dry run. * - Aspirate volume - - ✅ How much to aspirate from each sample. - ❌ Volume that the pipette will aspirate * - Dilution factor - - ✅ Each step uses this ratio of total liquid to original solution. Express the ratio as a decimal. - ❌ total/diluent ratio for the process Not every parameter requires a description! For example, in a protocol that uses only one pipette, it would be difficult to explain a parameter named &quot;Pipette type&quot; without repeating yourself. In a protocol that offers parameters for two different pipettes, it may be useful to summarize what steps each pipette performs. **Use sentence case for readability**. Sentence case means adding a capital letter to *only* the first word of the name and description. This gives your parameters a professional appearance. Keep proper names capitalized as they would be elsewhere in a sentence. For example: .. list-table:: * - ✅ Number of samples - ❌ number of samples * - ✅ Temperature Module slot - ❌ Temperature module slot * - ✅ Dilution factor - ❌ Dilution Factor **Use numerals for all numbers.** In a scientific context, this includes single-digit numbers. Additionally, punctuate numbers according to the needs of your protocol&apos;s users. If you plan to share your protocol widely, consider using American English number punctuation (comma for thousands separator; period for decimal separator). **Order choices logically.** Place items within the ``choices`` attribute in the order that makes sense for your application. Numeric choices should either ascend or descend. Consider an offset parameter with choices. Sorting according to value is easy to use in either direction, but sorting by absolute value is difficult: .. list-table:: * - ✅ -3, -2, -1, 0, 1, 2, 3 - ❌ 0, 1, -1, 2, -2, 3, -3 * - ✅ 3, 2, 1, 0, -1, -2, -3 - String choices may have an intrinsic ordering. If they don&apos;t, fall back to alphabetical order. .. list-table:: :header-rows: 1 * - Parameter name - Parameter description * - Liquid color - - ✅ Red, Orange, Yellow, Green, Blue, Violet - ❌ Blue, Green, Orange, Red, Violet, Yellow * - Tube brand - - ✅ Eppendorf, Falcon, Generic, NEST - ❌ Falcon, NEST, Eppendorf, Generic Type-Specific Guidance ====================== Booleans -------- The ``True`` value of a Boolean corresponds to the word *On* and the ``False`` value corresponds to the word *Off*. **Avoid double negatives.** These are difficult to understand and may lead to a technician making an incorrect choice. Remember that negation can be part of a word&apos;s meaning! For example, it&apos;s difficult to reason about what will happen when a parameter named &quot;Deactivate module&quot; is set to &quot;Off&quot;. **When in doubt, clarify in the description.** If you feel like you need to add extra clarity to your Boolean choices, use the phrase &quot;When on&quot; or &quot;When off&quot; at the beginning of your description. For example, a parameter named &quot;Dry run&quot; could have the description &quot;When on, skip protocol delays and return tips instead of trashing them.&quot; Number Choices -------------- **Don&apos;t repeat text in choices.** Rely on the name and description to indicate what the number refers to. It&apos;s OK to add units to the display names of numeric choices, because the ``unit`` attribute is ignored when you specify ``choices``. .. list-table:: :header-rows: 1 * - Parameter name - Parameter description * - Number of columns - - ✅ 1, 2, 3 - ❌ 1 column, 2 columns, 3 columns * - Aspirate volume - - ✅ 10 µL, 20 µL, 50 µL - ✅ Low (10 µL), Medium (20 µL), High (50 µL) - ❌ Low volume, Medium volume, High volume **Use a range instead of choices when all values are acceptable.** It&apos;s faster and easier to enter a numeric value than to choose from a long list. For example, a &quot;Number of columns&quot; parameter that accepts any number 1 through 12 should specify a ``minimum`` and ``maximum``, rather than ``choices``. However, if the application requires that the parameter only accepts even numbers, you need to specify choices (2, 4, 6, 8, 10, 12). Strings ------- **Avoid strings that are synonymous with &quot;yes&quot; and &quot;no&quot;.** When presenting exactly two string choices, consider their meaning. Can they be rephrased in terms of &quot;yes/no&quot;, &quot;true/false&quot;, or &quot;on/off&quot;? If no, then a string parameter is appropriate. If yes, it&apos;s better to use a Boolean, which appears in run setup as a toggle rather than a dropdown menu. - ✅ Blue, Red - ✅ Left-to-right, Right-to-left - ❌ Include, Exclude - ❌ Yes, No</content></file><file name="use_case_cherrypicking.rst" type="rst"><content>:og:description: How to use a CSV parameter to perform cherrypicking in an Opentrons Python protocol. .. _use-case-cherrypicking: ********************************** Parameter Use Case – Cherrypicking ********************************** A common liquid handling task is `cherrypicking`: pipetting liquid from only certain wells on a source plate and placing them in order on a destination plate. This use case demonstrates how to use a CSV runtime parameter to automate this process and to customize it on every run — without having to modify the Python protocol itself. In this simple example, the CSV will only control: - Source slot - Source well - Volume to transfer The destination labware and well order will remain fixed, to focus on using these three pieces of data with the :py:meth:`.transfer` function. In actual use, you can further customize pipetting behavior by adding more runtime parameters or by adding columns to your CSV file. Preparing the CSV ================= To get started, let&apos;s set up the CSV parameter. The data format we expect for this protocol is simple enough to fully explain in the parameter&apos;s description. .. code-block:: python def add_parameters(parameters): parameters.add_csv_file( variable_name=&quot;cherrypicking_wells&quot;, display_name=&quot;Cherrypicking wells&quot;, description=( &quot;Table with three columns:&quot; &quot; source slot, source well,&quot; &quot; and volume to transfer in µL.&quot; ) ) Here is an example of a CSV file that fits this format, specifying three wells across two plates: .. code-block:: text source slot,source well,volume D1,A1,50 D1,C4,30 D2,H1,50 The protocol will rely on the data being structured exactly this way, with a header row and the three columns in this order. The technician would select this, or another file with the same structure, during run setup. Our protocol will use the information contained in the selected CSV for loading labware in the protocol and performing the cherrypicking transfers. Parsing the CSV =============== We&apos;ll use the Python API&apos;s :py:meth:`.parse_as_csv` method to allow easy access to different portions of the CSV data at different points in the protocol:: def run(protocol): well_data = protocol.params.cherrypicking_wells.parse_as_csv() Now ``well_data`` is a list with four elements, one for each row in the file. We&apos;ll use the rows in a ``for`` loop later in the protocol, when it&apos;s time to transfer liquid. Loading Source Labware ====================== We&apos;ll use the data from the ``source slot`` column as part of loading the source labware. Let&apos;s assume that we always use Opentrons Tough PCR plates for both source and destination plates. Then we need to determine the locations for loading source plates from the first column of the CSV. This will have three steps: - Using a list comprehension to get data from the ``source slot`` column. - Deduplicating the items in the column. - Looping over the unique items to load the plates. First, we&apos;ll get all of the data from the first column of the CSV, using a list comprehension. Then we&apos;ll take a slice of the resulting list to remove the header:: source_slots = [row[0] for row in well_data][1:] # [&apos;D1&apos;, &apos;D1&apos;, &apos;D2&apos;] Next, we&apos;ll get the unique items in the list by converting it to a :py:obj:`set` and back to a list:: unique_source_slots = list(set(source_slots)) # [&apos;D1&apos;, &apos;D2&apos;] Finally, we&apos;ll loop over those slot names to load labware:: for slot in unique_source_slots:: protocol.load_labware( load_name=&quot;opentrons_96_wellplate_200ul_pcr_full_skirt&quot;, location=slot ) Note that loading labware in a loop like this doesn&apos;t assign each labware instance to a variable. That&apos;s fine, because we&apos;ll use :py:obj:`.ProtocolContext.deck` to refer to them by slot name later on. The entire start of the ``run()`` function, including a pipette and fixed labware (i.e., labware not affected by the CSV runtime parameter) will look like this: .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def add_parameters(parameters): parameters.add_csv_file( variable_name=&quot;cherrypicking_wells&quot;, display_name=&quot;Cherrypicking wells&quot;, description=( &quot;Table with three columns:&quot; &quot; source slot, source well,&quot; &quot; and volume to transfer in µL.&quot; ) ) def run(protocol: protocol_api.ProtocolContext): well_data = protocol.params.cherrypicking_wells.parse_as_csv() source_slots = [row[0] for row in well_data][1::] unique_source_slots = list(set(source_slots)) # load tip rack in deck slot C1 tiprack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;C1&quot; ) # attach pipette to left mount pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack] ) # load trash bin trash = protocol.load_trash_bin(&quot;A3&quot;) # load destination plate in deck slot C2 dest_plate = protocol.load_labware( load_name=&quot;opentrons_96_wellplate_200ul_pcr_full_skirt&quot;, location=&quot;C2&quot; ) # load source plates based on CSV data for slot in unique_source_slots: protocol.load_labware( load_name=&quot;opentrons_96_wellplate_200ul_pcr_full_skirt&quot;, location=slot ) Picking the Cherries ==================== Now it&apos;s time to transfer liquid based on the data in each row of the CSV. Once again we&apos;ll start by slicing off the header row of ``well_data``. Each remaining row has the source slot, source well, and volume data that we can directly pass to :py:meth:`.transfer`. We also need to specify the destination well. We want the destinations to proceed in order according to :py:meth:`.Labware.wells`. To track this all in a single loop, we&apos;ll wrap our CSV data in an :py:obj:`.enumerate` object to provide an index that increments each time through the loop. All together, the transfer loop looks like this:: for index, row in enumerate(well_data[1::]): # get source location from CSV source_slot = row[0] source_well = row[1] source_location = protocol.deck[source_slot][source_well] # get volume as a number transfer_volume = float(row[2]) # get destination location from loop index dest_location = dest_plate.wells()[index] # perform parameterized transfer pipette.transfer( volume=transfer_volume, source=source_location, dest=dest_location ) Let&apos;s unpack this. For each time through the loop, we build the source location from the first (``row[0]``) and second (``row[1]``) item in the row list. We then construct a complete location with respect to ``protocol.deck``. Next, we get the volume for the transfer. All CSV data is treated as strings, so we have to cast it to a floating point number. The last piece of information needed is the destination well. We take the index of the current iteration through the loop, and use that same index with respect to the ordered list of all wells on the destination plate. With all the information gathered and stored in variables, all that&apos;s left is to pass that information as the arguments of ``transfer()``. With our example file, this will execute three transfers. By using a different CSV at run time, this code could complete up to 96 transfers (at which point it would run out of both tips and destination wells). For more complex transfer behavior — such as adjusting location within the well — you could extend the CSV format and the associated code to work with additional data. And check out the `verified cherrypicking protocol &amp;lt;https://library.opentrons.com/p/flex-custom-parameters-cherrypicking&amp;gt;`_ in the Opentrons Protocol Library for further automation based on CSV data, including loading different types of plates, automatically loading tip racks, and more.</content></file><file name="use_case_dry_run.rst" type="rst"><content>:og:description: How to set up and use a dry run parameter in an Opentrons Python protocol. .. _use-case-dry-run: **************************** Parameter Use Case – Dry Run **************************** When testing out a new protocol, it&apos;s common to perform a dry run to watch your robot go through all the steps without actually handling samples or reagents. This use case explores how to add a single Boolean parameter for whether you&apos;re performing a dry run. The code examples will show how this single value can control: - Skipping module actions and long delays. - Reducing mix repetitions to save time. - Returning tips (that never touched any liquid) to their racks. To keep things as simple as possible, this use case only focuses on setting up and using the value of the dry run parameter, which could be just one of many parameters in a complete protocol. Dry Run Definition ================== First, we need to set up the dry run parameter. We want to set up a simple yes/no choice for the technician running the protocol, so we&apos;ll use a Boolean parameter:: def add_parameters(parameters): parameters.add_bool( variable_name=&quot;dry_run&quot;, display_name=&quot;Dry Run&quot;, description=( &quot;Skip delays,&quot; &quot; shorten mix steps,&quot; &quot; and return tips to their racks.&quot; ), default=False ) This parameter is set to ``False`` by default, assuming that most runs will be live runs. In other words, during run setup the technician will have to change the parameter setting to perform a dry run. If they leave it as is, the robot will perform a live run. Additionally, since &quot;dry run&quot; can have different meanings in different contexts, it&apos;s important to include a ``description`` that indicates exactly what the parameter will control — in this case, three things. The following sections will show how to accomplish each of those when the dry run parameter is set to ``True``. Skipping Delays =============== Many protocols have built-in delays, either for a module to work or to let a reaction happen passively. Lengthy delays just get in the way when verifying a protocol with a dry run. So wherever the protocol calls for a delay, we can check the value of ``protocol.params.dry_run`` and make the protocol behave accordingly. To start, let&apos;s consider a simple :py:meth:`.delay` command. We can wrap it in an ``if`` statement such that the delay will only execute when the run is *not* a dry run:: if protocol.params.dry_run is False: protocol.delay(minutes=5) You can extend this approach to more complex situations, like module interactions. For example, in a protocol that moves a plate to the Thermocycler for an incubation, you&apos;ll want to perform all the movement steps — opening and closing the module lid, and moving the plate to and from the block — but skip the heating and cooling time. The simplest way to do this is, like in the delay example above, to wrap each skippable command:: protocol.move_labware(labware=plate, new_location=tc_mod, use_gripper=True) if protocol.params.dry_run is False: tc_mod.set_block_temperature(4) tc_mod.set_lid_temperature(100) tc_mod.close_lid() pcr_profile = [ {&quot;temperature&quot;: 68, &quot;hold_time_seconds&quot;: 180}, {&quot;temperature&quot;: 98, &quot;hold_time_seconds&quot;: 180}, ] if protocol.params.dry_run is False: tc_mod.execute_profile( steps=pcr_profile, repetitions=1, block_max_volume=50 ) tc_mod.open_lid() Shortening Mix Steps ==================== Similar to delays, mix steps can take a long time because they are inherently repetitive actions. Mixing ten times takes ten times as long as mixing once! To save time, set a mix repetitions variable based on the value of ``protocol.params.dry_run`` and pass that to :py:meth:`.mix`:: if protocol.params.dry_run is True: mix_reps = 1 else: mix_reps = 10 pipette.mix(repetitions=mix_reps, volume=50, location=plate[&quot;A1&quot;].bottom()) Note that this checks whether the dry run parameter is ``True``. If you prefer to set up all your ``if`` statements to check whether it&apos;s ``False``, you can reverse the logic:: if protocol.params.dry_run is False: mix_reps = 10 else: mix_reps = 1 Returning Tips ============== Tips used in a dry run should be reusable — for another dry run, if nothing else. It doesn&apos;t make sense to dispose of them in a trash container, unless you specifically need to test movement to the trash. You can choose whether to use :py:meth:`.drop_tip` or :py:meth:`.return_tip` based on the value of ``protocol.params.dry_run``. If the protocol doesn&apos;t have too many tip drop actions, you can use an ``if`` statement each time:: if protocol.params.dry_run is True: pipette.return_tip() else: pipette.drop_tip() However, repeating this block every time you handle tips could significantly clutter your code. Instead, you could define it as a function:: def return_or_drop(pipette): if protocol.params.dry_run is True: pipette.return_tip() else: pipette.drop_tip() Then call that function throughout your protocol:: pipette.pick_up_tip() return_or_drop(pipette) .. note:: It&apos;s generally better to define a standalone function, rather than adding a method to the :py:class:`.InstrumentContext` class. This makes your custom, parameterized commands stand out from API methods in your code. Additionally, if your protocol uses enough tips that you have to replenish tip racks, you&apos;ll need separate behavior for dry runs and live runs. In a live run, once you&apos;ve used all the tips, the rack is empty, because the tips are in the trash. In a dry run, once you&apos;ve used all the tips in a rack, the rack is *full*, because you returned the tips. The API has methods to handle both of these situations. To continue using the same tip rack without physically replacing it, call :py:meth:`.reset_tipracks`. In the live run, move the empty tip rack off the deck and move a full one into place:: if protocol.params.dry_run is True: pipette.reset_tipracks() else: protocol.move_labware( labware=tips_1, new_location=chute, use_gripper=True ) protocol.move_labware( labware=tips_2, new_location=&quot;C3&quot;, use_gripper=True ) You can modify this code for similar cases. You may be moving tip racks by hand, rather than with the gripper. Or you could even mix the two, moving the used (but full) rack off-deck by hand — instead of dropping it down the chute, spilling all the tips — and have the gripper move a new rack into place. Ultimately, it&apos;s up to you to fine-tune your dry run behavior, and communicate it to your protocol&apos;s users with your parameter descriptions.</content></file><file name="use_case_sample_count.rst" type="rst"><content>:og:description: How to set up and use a sample count parameter in an Opentrons Python protocol. .. _use-case-sample-count: ********************************* Parameter Use Case – Sample Count ********************************* Choosing how many samples to process is important for efficient automation. This use case explores how a single parameter for sample count can have pervasive effects throughout a protocol. The examples are adapted from an actual parameterized protocol for DNA prep. The sample code will use 8-channel pipettes to process 8, 16, 24, or 32 samples. At first glance, it might seem like sample count would primarily affect liquid transfers to and from sample wells. But when using the Python API&apos;s full range of capabilities, it affects: - How many tip racks to load. - The initial volume and placement of reagents. - Pipetting to and from samples. - If and when tip racks need to be replaced. To keep things as simple as possible, this use case only focuses on setting up and using the value of the sample count parameter, which is just one of several parameters present in the full protocol. From Samples to Columns ======================= First of all, we need to set up the sample count parameter so it&apos;s both easy for technicians to understand during protocol setup and easy for us to use in the protocol&apos;s ``run()`` function. We want to limit the number of samples to 8, 16, 24, or 32, so we&apos;ll use an integer parameter with choices:: def add_parameters(parameters): parameters.add_int( variable_name=&quot;sample_count&quot;, display_name=&quot;Sample count&quot;, description=&quot;Number of input DNA samples.&quot;, default=24, choices=[ {&quot;display_name&quot;: &quot;8&quot;, &quot;value&quot;: 8}, {&quot;display_name&quot;: &quot;16&quot;, &quot;value&quot;: 16}, {&quot;display_name&quot;: &quot;24&quot;, &quot;value&quot;: 24}, {&quot;display_name&quot;: &quot;32&quot;, &quot;value&quot;: 32}, ] ) All of the possible values are multiples of 8, because the protocol will use an 8-channel pipette to process an entire column of samples at once. Considering how 8-channel pipettes access wells, it may be more useful to operate with a *column count* in code. We can set a ``column_count`` very early in the ``run()`` function by accessing the value of ``params.sample_count`` and dividing it by 8:: def run(protocol): column_count = protocol.params.sample_count // 8 Most examples below will use ``column_count``, rather than redoing (and retyping!) this calculation multiple times. Loading Tip Racks ================= Tip racks come first in most protocols. To ensure that the protocol runs to completion, we need to load enough tip racks to avoid running out of tips. We could load as many tip racks as are needed for our maximum number of samples, but that would be suboptimal. Run setup is faster when the technician doesn&apos;t have to load extra items onto the deck. So it&apos;s best to examine the protocol&apos;s steps and determine how many racks are needed for each value of ``sample_count``. In the case of this DNA prep protocol, we can create formulas for the number of 200 µL and 50 µL tip racks needed. The following factors go into these computations: - 50 µL tips - 1 fixed action that picks up once per protocol. - 7 variable actions that pick up once per sample column. - 200 µL tips - 2 fixed actions that pick up once per protocol. - 11 variable actions that pick up once per sample column. Since each tip rack has 12 columns, divide the number of pickup actions by 12 to get the number of racks needed. And we always need to round up — performing 13 pickups requires 2 racks. The :py:func:`math.ceil` method rounds up to the nearest integer. We&apos;ll add ``from math import ceil`` at the top of the protocol and then calculate the number of tip racks as follows:: tip_rack_50_count = ceil((1 + 7 * column_count) / 12) tip_rack_200_count = ceil((2 + 13 * column_count) / 12) Running the numbers shows that the maximum combined number of tip racks is 7. Now we have to decide where to load up to 7 racks, working around the modules and other labware on the deck. Assuming we&apos;re running this protocol on a Flex with staging area slots, they&apos;ll all fit! (If you don&apos;t have staging area slots, you can load labware off-deck instead.) We&apos;ll reserve these slots for the different size racks:: tip_rack_50_slots = [&quot;B3&quot;, &quot;C3&quot;, &quot;B4&quot;] tip_rack_200_slots = [&quot;A2&quot;, &quot;B2&quot;, &quot;A3&quot;, &quot;A4&quot;] Finally, we can combine this information to call :py:meth:`~.ProtocolContext.load_labware`. Depending on the number of racks needed, we&apos;ll slice that number of elements from the slot list and use a `list comprehension &amp;lt;https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions&amp;gt;`__ to gather up the loaded tip racks. For the 50 µL tips, this would look like:: tip_racks_50 = [ protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_50ul&quot;, location=slot ) for slot in tip_rack_50_slots[:tip_rack_50_count] ] Then we can associate those lists of tip racks directly with each pipette as we load them. All together, the start of our ``run()`` function looks like this:: # calculate column count from sample count column_count = protocol.params.sample_count // 8 # calculate number of required tip racks tip_rack_50_count = ceil((1 + 7 * column_count) / 12) tip_rack_200_count = ceil((2 + 13 * column_count) / 12) # assign tip rack locations (maximal case) tip_rack_50_slots = [&quot;B3&quot;, &quot;C3&quot;, &quot;B4&quot;] tip_rack_200_slots = [&quot;A2&quot;, &quot;B2&quot;, &quot;A3&quot;, &quot;A4&quot;] # create lists of loaded tip racks # limit to number of needed racks for each type tip_racks_50 = [ protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_50ul&quot;, location=slot ) for slot in tip_rack_50_slots[:tip_rack_50_count] ] tip_racks_200 = [ protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=slot ) for slot in tip_rack_200_slots[:tip_rack_200_count] ] pipette_50 = protocol.load_instrument( instrument_name=&quot;flex_8channel_50&quot;, mount=&quot;right&quot;, tip_racks=tip_racks_50 ) pipette_1000 = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=tip_racks_200 ) This code will load as few as 3 tip racks and as many as 7, and associate them with the correct pipettes — all based on a single choice from a dropdown menu at run setup. Loading Liquids =============== Next come the reagents, samples, and the labware that holds them. The required volume of each reagent is dependent on the sample count. While the full protocol defines more than ten liquids, we&apos;ll show three reagents plus the samples here. First, let&apos;s load a reservoir and :ref:`define &amp;lt;defining-liquids&amp;gt;` the three example liquids. Definitions only specify the name, description, and display color, so our sample count parameter doesn&apos;t come into play yet:: # labware to hold reagents reservoir = protocol.load_labware( load_name=&quot;nest_12_reservoir_15ml&quot;, location=&quot;C2&quot; ) # reagent liquid definitions ampure_liquid = protocol.define_liquid( name=&quot;AMPure&quot;, description=&quot;AMPure Beads&quot;, display_color=&quot;#704848&quot; ) tagstop_liquid = protocol.define_liquid( name=&quot;TAGSTOP&quot;, description=&quot;Tagmentation Stop&quot;, display_color=&quot;#FF0000&quot; ) twb_liquid = protocol.define_liquid( name=&quot;TWB&quot;, description=&quot;Tagmentation Wash Buffer&quot;, display_color=&quot;#FFA000&quot; ) Now we&apos;ll bring sample count into consideration as we :ref:`load the liquids &amp;lt;loading-liquids&amp;gt;`. The application requires the following volumes for each column of samples: .. list-table:: :header-rows: 1 * - Liquid - | Volume | (µL per column) * - AMPure Beads - 180 * - Tagmentation Stop - 10 * - Tagmentation Wash Buffer - 900 To calculate the total volume for each liquid, we&apos;ll multiply these numbers by ``column_count`` and by 1.1 (to ensure that the pipette can aspirate the required volume without drawing in air at the bottom of the well). This calculation can be done inline as the ``volume`` value of :py:meth:`~.Well.load_liquid`:: reservoir[&quot;A1&quot;].load_liquid( liquid=ampure_liquid, volume=180 * column_count * 1.1 ) reservoir[&quot;A2&quot;].load_liquid( liquid=tagstop_liquid, volume=10 * column_count * 1.1 ) reservoir[&quot;A4&quot;].load_liquid( liquid=twb_liquid, volume=900 * column_count * 1.1 ) Now, for example, the volume of AMPure beads to load will vary from 198 µL for a single sample column up to 792 µL for four columns. .. tip:: Does telling a technician to load 792 µL of a liquid seem overly precise? Remember that you can perform any calculation you like to set the value of ``volume``! For example, you could round the AMPure volume up to the nearest 10 µL:: volume=ceil((180 * column_count * 1.1) / 10) * 10 Finally, it&apos;s good practice to label the wells where the samples reside. The sample plate starts out atop the Heater-Shaker Module: .. code-block:: hs_mod = protocol.load_module( module_name=&quot;heaterShakerModuleV1&quot;, location=&quot;D1&quot; ) hs_adapter = hs_mod.load_adapter(name=&quot;opentrons_96_pcr_adapter&quot;) sample_plate = hs_adapter.load_labware( name=&quot;opentrons_96_wellplate_200ul_pcr_full_skirt&quot;, label=&quot;Sample Plate&quot;, ) Now we can construct a ``for`` loop to label each sample well with ``load_liquid()``. The simplest way to do this is to combine our original *sample count* with the fact that the :py:meth:`.Labware.wells()` accessor returns wells top-to-bottom, left-to-right:: # define sample liquid sample_liquid = protocol.define_liquid( name=&quot;Samples&quot;, description=None, display_color=&quot;#52AAFF&quot; ) # load 40 µL in each sample well for w in range(protocol.params.sample_count): sample_plate.wells()[w].load_liquid(liquid=sample_liquid, volume=40) Processing Samples ================== When it comes time to process the samples, we&apos;ll return to working by column, since the protocol uses an 8-channel pipette. There are many pipetting stages in the full protocol, but this section will examine just the stage for adding the Tagmentation Stop liquid. The same techniques would apply to similar stages. For pipetting in the original sample locations, we&apos;ll command the 50 µL pipette to move to some or all of A1–A4 on the sample plate. Similar to when we loaded tip racks earlier, we can use ``column_count`` to slice a list containing these well names, and then iterate over that list with a ``for`` loop:: for w in [&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;][:column_count]: pipette_50.pick_up_tip() pipette_50.aspirate(volume=13, location=reservoir[&quot;A2&quot;].bottom()) pipette_50.dispense(volume=3, location=reservoir[&quot;A2&quot;].bottom()) pipette_50.dispense(volume=10, location=sample_plate[w].bottom()) pipette_50.move_to(location=sample_plate[w].bottom()) pipette_50.mix(repetitions=10, volume=20) pipette_50.blow_out(location=sample_plate[w].top(z=-2)) pipette_50.drop_tip() Each time through the loop, the pipette will fill from the same well of the reservoir and then dispense (and mix and blow out) in a different column of the sample plate. Later steps of the protocol will move intermediate samples to the middle of the plate (columns 5–8) and final samples to the right side of the plate (columns 9–12). When moving directly from one set of columns to another, we have to track *both lists* with the ``for`` loop. The :py:func:`zip` function lets us pair up the lists of well names and step through them in parallel:: for initial, intermediate in zip( [&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;][:column_count], [&quot;A5&quot;, &quot;A6&quot;, &quot;A7&quot;, &quot;A8&quot;][:column_count], ): pipette_50.pick_up_tip() pipette_50.aspirate(volume=13, location=sample_plate[initial]) pipette_50.dispense(volume=13, location=sample_plate[intermediate]) pipette_50.drop_tip() This will transfer from column 1 to 5, 2 to 6, and so on — depending on the number of samples chosen during run setup. Replenishing Tips ================= For the higher values of ``protocol.params.sample_count``, the protocol will load tip racks in the staging area slots (column 4). Since pipettes can&apos;t reach these slots, we need to move these tip racks into the working area (columns 1–3) before issuing a pipetting command that targets them, or the API will raise an error. A protocol without parameters will always run out of tips at the same time — just add a :py:meth:`.move_labware` command when that happens. But as we saw in the Processing Samples section above, our parameterized protocol will go through tips at a different rate depending on the sample count. In our simplified example, we know that when the sample count is 32, the first 200 µL tip rack will be exhausted after three stages of pipetting using the 1000 µL pipette. So, after that step, we could add:: if protocol.params.sample_count == 32: protocol.move_labware( labware=tip_racks_200[0], new_location=chute, use_gripper=True, ) protocol.move_labware( labware=tip_racks_200[-1], new_location=&quot;A2&quot;, use_gripper=True, ) This will replace the first 200 µL tip rack (in slot A2) with the last 200 µL tip rack (in the staging area). However, in the full protocol, sample count is not the only parameter that affects the rate of tip use. It would be unwieldy to calculate in advance all the permutations of when tip replenishment is necessary. Instead, before each stage of the protocol, we could use :py:obj:`.Well.has_tip()` to check whether the first tip rack is empty. If the *last well* of the rack is empty, we can assume that the entire rack is empty and needs to be replaced:: if tip_racks_200[0].wells()[-1].has_tip is False: # same move_labware() steps as above For a protocol that uses tips at a faster rate than this one — such that it might exhaust a tip rack in a single ``for`` loop of pipetting steps — you may have to perform such checks even more frequently. You can even define a function that counts tips or performs ``has_tip`` checks in combination with picking up a tip, and use that instead of :py:meth:`.pick_up_tip` every time you pipette. The built-in capabilities of Python and the methods of the Python Protocol API give you the flexibility to add this kind of smart behavior to your protocols.</content></file><file name="using_values.rst" type="rst"><content>:og:description: Access parameter values in Opentrons Python protocols. .. _using-rtp: **************** Using Parameters **************** Once you&apos;ve :ref:`defined parameters &amp;lt;defining-rtp&amp;gt;`, their values are accessible anywhere within the ``run()`` function of your protocol. The ``params`` Object ===================== Protocols with parameters have a :py:obj:`.ProtocolContext.params` object, which contains the values of all parameters as set during run setup. Each attribute of ``params`` corresponds to the ``variable_name`` of a parameter. For example, consider a protocol that defines the following three parameters: - ``add_bool`` with ``variable_name=&quot;dry_run&quot;`` - ``add_int`` with ``variable_name=&quot;sample_count&quot;`` - ``add_float`` with ``variable_name=&quot;volume&quot;`` Then ``params`` will gain three attributes: ``params.dry_run``, ``params.sample_count``, and ``params.volume``. You can use these attributes anywhere you want to access their values, including directly as arguments of methods. .. code-block:: if protocol.params.dry_run is False: pipette.mix(repetitions=10, volume=protocol.params.volume) You can also save parameter values to variables with names of your choosing. .. _using-rtp-types: Parameter Types =============== Each attribute of ``params`` has the type corresponding to its parameter definition (except CSV parameters; see :ref:`rtp-csv-data` below). Keep in mind the parameter&apos;s type when using its value in different contexts. Say you wanted to add a comment to the run log, stating how many samples the protocol will process. Since ``sample_count`` is an ``int``, you&apos;ll need to cast it to a ``str`` or the API will raise an error. .. code-block:: protocol.comment( &quot;Processing &quot; + str(protocol.params.sample_count) + &quot; samples.&quot; ) Also be careful with ``int`` types when performing calculations: dividing an ``int`` by an ``int`` with the ``/`` operator always produces a ``float``, even if there is no remainder. The :ref:`sample count use case &amp;lt;use-case-sample-count&amp;gt;` converts a sample count to a column count by dividing by 8 — but it uses the ``//`` integer division operator, so the result can be used for creating ranges, slicing lists, and as ``int`` argument values without having to cast it in those contexts. .. _rtp-csv-data: Manipulating CSV Data ===================== CSV parameters have their own :py:class:`.CSVParameter` type, since they don&apos;t correspond to a built-in Python type. This class has properties and methods that let you access the CSV data in one of three ways: as a file handler, as a string, or as nested lists. The :py:obj:`.CSVParameter.file` parameter provides a read-only `file handler object &amp;lt;https://docs.python.org/3/glossary.html#term-file-object&amp;gt;`_ that points to your CSV data. You can pass this object to functions of the built-in :py:obj:`csv` module, or to other modules you import, such as ``pandas``. The :py:obj:`.CSVParameter.contents` parameter returns the entire contents of the CSV file as a single string. You then need to parse the data yourself to extract the information you need. The :py:meth:`.CSVParameter.parse_as_csv` method returns CSV data in a structured format. Specifically, it is a list of lists of strings. This lets you access any &quot;cell&quot; of your tabular data by row and column index. This example parses a runtime parameter named ``csv_data``, stores the parsed data as ``parsed_csv``, and then accesses different portions of the data:: parsed_csv = protocol.params.csv_data.parse_as_csv() parsed_csv[0] # first row (header, if present) parsed_csv[1][2] # second row, third column [row[1] for row in parsed_csv] # second column .. versionadded:: 2.20 Like all Python lists, the lists representing your CSVs are zero-indexed. .. tip:: CSV parameters don&apos;t have default values. Accessing CSV data in any of the above ways will prevent protocol analysis from completing until you select a CSV file and confirm all runtime parameter values during run setup. You can use a try–except block to work around this and provide the data needed for protocol analysis. First, add ``from opentrons.protocol_api import RuntimeParameterRequiredError`` at the top of your protocol. Then catch the error like this:: try: parsed_csv = protocol.params.csv_data.parse_as_csv() except RuntimeParameterRequiredError: parsed_csv = [ [&quot;source slot&quot;, &quot;source well&quot;, &quot;volume&quot;], [&quot;D1&quot;, &quot;A1&quot;, &quot;50&quot;], [&quot;D2&quot;, &quot;B1&quot;, &quot;50&quot;], ] Limitations =========== Since ``params`` is only available within the ``run()`` function, there are certain aspects of a protocol that parameter values can&apos;t affect. These include, but are not limited to the following: .. list-table:: :header-rows: 1 * - Information - Location * - ``import`` statements - At the beginning of the protocol. * - Robot type (Flex or OT-2) - In the ``requirements`` dictionary. * - API version - In the ``requirements`` or ``metadata`` dictionary. * - Protocol name - In the ``metadata`` dictionary. * - Protocol description - In the ``metadata`` dictionary. * - Protocol author - In the ``metadata`` dictionary. * - Other runtime parameters - In the ``add_parameters()`` function. * - Non-nested function definitions - Anywhere outside of ``run()``. Additionally, keep in mind that updated parameter values are applied by reanalyzing the protocol. This means you can&apos;t depend on updated values for any action that takes place *prior to reanalysis*. An example of such an action is applying labware offset data. Say you have a parameter that changes the type of well plate you load in a particular slot:: # within add_parameters() parameters.add_str( variable_name=&quot;plate_type&quot;, display_name=&quot;Well plate type&quot;, choices=[ {&quot;display_name&quot;: &quot;Corning&quot;, &quot;value&quot;: &quot;corning_96_wellplate_360ul_flat&quot;}, {&quot;display_name&quot;: &quot;NEST&quot;, &quot;value&quot;: &quot;nest_96_wellplate_200ul_flat&quot;}, ], default=&quot;corning_96_wellplate_360ul_flat&quot;, ) # within run() plate = protocol.load_labware( load_name=protocol.params.plate_type, location=&quot;D2&quot; ) When performing run setup, you&apos;re prompted to apply offsets before selecting parameter values. This is your only opportunity to apply offsets, so they&apos;re applied for the default parameter values — in this case, the Corning plate. If you then change the &quot;Well plate type&quot; parameter to the NEST plate, the NEST plate will have default offset values (0.0 on all axes). You can fix this by running Labware Position Check, since it takes place after reanalysis, or by using :py:meth:`.Labware.set_offset` in your protocol.</content></file></directory><directory name="pipettes"><file name="characteristics.rst" type="rst"><content>:og:description: Details on Opentrons pipette movement and flow rates. .. _pipette-characteristics: *********************** Pipette Characteristics *********************** Each Opentrons pipette has different capabilities, which you&apos;ll want to take advantage of in your protocols. This page covers some fundamental pipette characteristics. :ref:`new-multichannel-pipettes` gives examples of how multi-channel pipettes move around the deck by using just one of their channels as a reference point. Taking this into account is important for commanding your pipettes to perform actions in the correct locations. :ref:`new-plunger-flow-rates` discusses how quickly each type of pipette can handle liquids. The defaults are designed to operate quickly, based on the pipette&apos;s hardware and assuming that you&apos;re handling aqueous liquids. You can speed up or slow down a pipette&apos;s flow rate to suit your protocol&apos;s needs. Finally, the volume ranges of pipettes affect what you can do with them. The volume ranges for current pipettes are listed on the :ref:`Loading Pipettes &amp;lt;loading-pipettes&amp;gt;` page. The :ref:`ot2-pipette-generations` section of this page describes how the API behaves when running protocols that specify older OT-2 pipettes. .. _new-multichannel-pipettes: Multi-Channel Movement ====================== All :ref:`building block &amp;lt;v2-atomic-commands&amp;gt;` and :ref:`complex commands &amp;lt;v2-complex-commands&amp;gt;` work with single- and multi-channel pipettes. To keep the protocol API consistent when using single- and multi-channel pipettes, location arguments of pipetting commands use the pipette&apos;s *primary channel*. For multi-channel pipettes picking up tips with all of their channels, the back-left channel is considered primary. When using fewer channels, the ``start`` parameter of the :py:meth:`.InstrumentContext.configure_nozzle_layout` method can change the pipette&apos;s primary channel. See :ref:`partial-tip-pickup` for more information. With a pipette&apos;s default settings, you can generally access the wells indicated in the table below. Moving to any other well may cause the pipette to crash. .. list-table:: :header-rows: 1 * - Channels - 96-well plate - 384-well plate * - 1 - Any well, A1–H12 - Any well, A1–P24 * - 8 - A1–A12 - A1–B24 * - 96 - A1 only - A1–B2 Also, you should apply any location offset, such as :py:meth:`.Well.top` or :py:meth:`.Well.bottom`, to the well accessed by the primary channel. Since all of the pipette&apos;s channels move together, each channel will have the same offset relative to the well that it is over. Finally, because each multi-channel pipette has only one motor, they always aspirate and dispense on all channels simultaneously. 8-Channel, 96-Well Plate Example -------------------------------- To demonstrate these concepts, let&apos;s write a protocol that uses a Flex 8-Channel Pipette and a 96-well plate. We&apos;ll then aspirate and dispense a liquid to different locations on the same well plate. To start, let&apos;s load a pipette in the right mount and add our labware. .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;:&quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # Load a tiprack for 1000 µL tips tiprack1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D1&quot;) # Load a 96-well plate plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;C1&quot;) # Load an 8-channel pipette on the right mount right = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;right&quot;, tip_racks=[tiprack1]) After loading our instruments and labware, let&apos;s tell the robot to pick up a pipette tip from location ``A1`` in ``tiprack1``:: right.pick_up_tip() With the backmost pipette channel above location A1 on the tip rack, all eight channels are above the eight tip rack wells in column 1. After picking up a tip, let&apos;s tell the robot to aspirate 300 µL from the well plate at location ``A2``:: right.aspirate(volume=300, location=plate[&quot;A2&quot;]) With the backmost pipette tip above location A2 on the well plate, all eight channels are above the eight wells in column 2. Finally, let&apos;s tell the robot to dispense 300 µL into the well plate at location ``A3``:: right.dispense(volume=300, location=plate[&quot;A3&quot;].top()) With the backmost pipette tip above location A3, all eight channels are above the eight wells in column 3. The pipette will dispense liquid into all the wells simultaneously. 8-Channel, 384-Well Plate Example --------------------------------- In general, you should specify wells in the first row of a well plate when using multi-channel pipettes. An exception to this rule is when using 384-well plates. The greater well density means the nozzles of a multi-channel pipette can only access every other well in a column. Specifying well A1 accesses every other well starting with the first (rows A, C, E, G, I, K, M, and O). Similarly, specifying well B1 also accesses every other well, but starts with the second (rows B, D, F, H, J, L, N, and P). To demonstrate these concepts, let&apos;s write a protocol that uses a Flex 8-Channel Pipette and a 384-well plate. We&apos;ll then aspirate and dispense a liquid to different locations on the same well plate. To start, let&apos;s load a pipette in the right mount and add our labware. .. code-block:: python def run(protocol: protocol_api.ProtocolContext): # Load a tiprack for 200 µL tips tiprack1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D1&quot;) # Load a well plate plate = protocol.load_labware( load_name=&quot;corning_384_wellplate_112ul_flat&quot;, location=&quot;D2&quot;) # Load an 8-channel pipette on the right mount right = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;right&quot;, tip_racks=[tiprack1]) After loading our instruments and labware, let&apos;s tell the robot to pick up a pipette tip from location ``A1`` in ``tiprack1``:: right.pick_up_tip() With the backmost pipette channel above location A1 on the tip rack, all eight channels are above the eight tip rack wells in column 1. After picking up a tip, let&apos;s tell the robot to aspirate 100 µL from the well plate at location ``A1``:: right.aspirate(volume=100, location=plate[&quot;A1&quot;]) The eight pipette channels will only aspirate from every other well in the column: A1, C1, E1, G1, I1, K1, M1, and O1. Finally, let&apos;s tell the robot to dispense 100 µL into the well plate at location ``B1``:: right.dispense(volume=100, location=plate[&quot;B1&quot;]) The eight pipette channels will only dispense into every other well in the column: B1, D1, F1, H1, J1, L1, N1, and P1. .. _new-plunger-flow-rates: Pipette Flow Rates ================== Measured in µL/s, the flow rate determines how much liquid a pipette can aspirate, dispense, and blow out. Opentrons pipettes have their own default flow rates. The API lets you change the flow rate on a loaded :py:class:`.InstrumentContext` by altering the :py:obj:`.InstrumentContext.flow_rate` properties listed below. * Aspirate: ``InstrumentContext.flow_rate.aspirate`` * Dispense: ``InstrumentContext.flow_rate.dispense`` * Blow out: ``InstrumentContext.flow_rate.blow_out`` These flow rate properties operate independently. This means you can specify different flow rates for each property within the same protocol. For example, let&apos;s load a simple protocol and set different flow rates for the attached pipette. .. code-block:: python def run(protocol: protocol_api.ProtocolContext): tiprack1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D1&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack1]) plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D3&quot;) pipette.pick_up_tip() Let&apos;s tell the robot to aspirate, dispense, and blow out the liquid using default flow rates. Notice how you don&apos;t need to specify a ``flow_rate`` attribute to use the defaults:: pipette.aspirate(200, plate[&quot;A1&quot;]) # 716 µL/s pipette.dispense(200, plate[&quot;A2&quot;]) # 716 µL/s pipette.blow_out() # 716 µL/s Now let&apos;s change the flow rates for each action:: pipette.flow_rate.aspirate = 50 pipette.flow_rate.dispense = 100 pipette.flow_rate.blow_out = 300 pipette.aspirate(200, plate[&quot;A1&quot;]) # 50 µL/s pipette.dispense(200, plate[&quot;A2&quot;]) # 100 µL/s pipette.blow_out() # 300 µL/s These flow rates will remain in effect until you change the ``flow_rate`` attribute again *or* call ``configure_for_volume()``. Calling ``configure_for_volume()`` always resets all pipette flow rates to the defaults for the mode that it sets. .. TODO add mode ranges and flow defaults to sections below .. note:: In API version 2.13 and earlier, :py:obj:`.InstrumentContext.speed` offered similar functionality to ``.flow_rate``. It attempted to set the plunger speed in mm/s. Due to technical limitations, that speed could only be approximate. You must use ``.flow_rate`` in version 2.14 and later, and you should consider replacing older code that sets ``.speed``. .. versionadded:: 2.0 Flex Pipette Flow Rates ----------------------- The following table provides data on the default aspirate, dispense, and blowout flow rates (in µL/s) for Flex pipettes. Default flow rates for each pipette-tip combination are the same across all three actions. .. Excludes low-vol 96 channel. Not yet released. +-----------------------------+-------------------+------------------------+ | Pipette Model | Tip Capacity (µL) | Default Flow Rate (µL) | +=============================+===================+========================+ | 1- and 8-channel (50 µL) | 50 | 35 | +-----------------------------+-------------------+------------------------+ | 1- and 8-channel (1000 µL) | 50 | 478 | + +-------------------+------------------------+ | | 200 | 716 | + +-------------------+------------------------+ | | 1000 | 716 | +-----------------------------+-------------------+------------------------+ | 96-channel (5-1000 µL) | 50 | 6 | + +-------------------+------------------------+ | | 200 | 80 | + +-------------------+------------------------+ | | 1000 | 160 | +-----------------------------+-------------------+------------------------+ Additionally: - When using a 50 µL pipette, you should only use 50 µL tips. - All Flex pipettes have a well bottom clearance of 1 mm for aspirate and dispense actions. .. _ot2-flow-rates: OT-2 Pipette Flow Rates ----------------------- The following table provides data on the default aspirate, dispense, and blowout flow rates (in µL/s) for OT-2 GEN2 pipettes. Default flow rates are the same across all three actions. .. list-table:: :header-rows: 1 * - Pipette Model - Volume (µL) - Flow Rates (µL/s) * - P20 Single-Channel GEN2 - 1–20 - * API v2.6 or higher: 7.56 * API v2.5 or lower: 3.78 * - P300 Single-Channel GEN2 - 20–300 - * API v2.6 or higher: 92.86 * API v2.5 or lower: 46.43 * - P1000 Single-Channel GEN2 - 100–1000 - * API v2.6 or higher: 274.7 * API v2.5 or lower: 137.35 * - P20 Multi-Channel GEN2 - 1–20 - 7.6 * - P300 Multi-Channel GEN2 - 20–300 - 94 Additionally, all OT-2 GEN2 pipettes have a default head speed of 400 mm/s and a well bottom clearance of 1 mm for aspirate and dispense actions. .. _ot2-pipette-generations: OT-2 Pipette Generations ======================== The OT-2 works with the GEN1 and GEN2 pipette models. The newer GEN2 pipettes have different volume ranges than the older GEN1 pipettes. With some exceptions, the volume ranges for GEN2 pipettes overlap those used by the GEN1 models. If your protocol specifies a GEN1 pipette, but you have a GEN2 pipette with a compatible volume range, you can still run your protocol. The OT-2 will consider the GEN2 pipette to have the same minimum volume as the GEN1 pipette. The following table lists the volume compatibility between the GEN2 and GEN1 pipettes. .. list-table:: :header-rows: 1 * - GEN2 Pipette - GEN1 Pipette - GEN1 Volume * - P20 Single-Channel GEN2 - P10 Single-Channel GEN1 - 1-10 µL * - P20 Multi-Channel GEN2 - P10 Multi-Channel GEN1 - 1-10 µL * - P300 Single-Channel GEN2 - P300 Single-Channel GEN1 - 30-300 µL * - P300 Multi-Channel GEN2 - P300 Multi-Channel GEN1 - 20-200 µL * - P1000 Single-Channel GEN2 - P1000 Single-Channel GEN1 - 100-1000 µL The single- and multi-channel P50 GEN1 pipettes are the exceptions here. If your protocol uses a P50 GEN1 pipette, there is no backward compatibility with a related GEN2 pipette. To replace a P50 GEN1 with a corresponding GEN2 pipette, edit your protocol to load a P20 Single-Channel GEN2 (for volumes below 20 µL) or a P300 Single-Channel GEN2 (for volumes between 20 and 50 µL).</content></file><file name="loading.rst" type="rst"><content>:og:description: How to load Opentrons pipettes and add tip racks to them in a Python protocol. .. _new-create-pipette: .. _loading-pipettes: **************** Loading Pipettes **************** When writing a protocol, you must inform the Protocol API about the pipettes you will be using on your robot. The :py:meth:`.ProtocolContext.load_instrument` function provides this information and returns an :py:class:`.InstrumentContext` object. As noted above, you call the :py:meth:`~.ProtocolContext.load_instrument` method to load a pipette. This method also requires the :ref:`pipette&apos;s API load name &amp;lt;new-pipette-models&amp;gt;`, its left or right mount position, and (optionally) a list of associated tip racks. Even if you don&apos;t use the pipette anywhere else in your protocol, the Opentrons App and the robot won&apos;t let you start the protocol run until all pipettes loaded by ``load_instrument()`` are attached properly. .. _new-pipette-models: API Load Names ============== The pipette&apos;s API load name (``instrument_name``) is the first parameter of the ``load_instrument()`` method. It tells your robot which attached pipette you&apos;re going to use in a protocol. The tables below list the API load names for the currently available Flex and OT-2 pipettes. .. tabs:: .. tab:: Flex Pipettes +-------------------------+---------------+-------------------------+ | Pipette Model | Volume (µL) | API Load Name | +=========================+===============+===+=====================+ | Flex 1-Channel Pipette | 1–50 | ``flex_1channel_50`` | + +---------------+-------------------------+ | | 5–1000 | ``flex_1channel_1000`` | +-------------------------+---------------+-------------------------+ | Flex 8-Channel Pipette | 1–50 | ``flex_8channel_50`` | + +---------------+-------------------------+ | | 5–1000 | ``flex_8channel_1000`` | +-------------------------+---------------+-------------------------+ | Flex 96-Channel Pipette | 5–1000 | ``flex_96channel_1000`` | +-------------------------+---------------+-------------------------+ .. tab:: OT-2 Pipettes +-----------------------------+--------------------+-----------------------+ | Pipette Model | Volume (µL) | API Load Name | +=============================+====================+=======================+ | P20 Single-Channel GEN2 | 1-20 | ``p20_single_gen2`` | +-----------------------------+ +-----------------------+ | P20 Multi-Channel GEN2 | | ``p20_multi_gen2`` | +-----------------------------+--------------------+-----------------------+ | P300 Single-Channel GEN2 | 20-300 | ``p300_single_gen2`` | +-----------------------------+ +-----------------------+ | P300 Multi-Channel GEN2 | | ``p300_multi_gen2`` | +-----------------------------+--------------------+-----------------------+ | P1000 Single-Channel GEN2 | 100-1000 | ``p1000_single_gen2`` | +-----------------------------+--------------------+-----------------------+ See the :ref:`OT-2 Pipette Generations &amp;lt;ot2-pipette-generations&amp;gt;` section if you&apos;re using GEN1 pipettes on an OT-2. The GEN1 family includes the P10, P50, and P300 single- and multi-channel pipettes, along with the P1000 single-channel model. Loading Flex 1- and 8-Channel Pipettes ====================================== This code sample loads a Flex 1-Channel Pipette in the left mount and a Flex 8-Channel Pipette in the right mount. Both pipettes are 1000 µL. Each pipette uses its own 1000 µL tip rack. .. code-block:: Python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;:&quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): tiprack1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D1&quot;) tiprack2 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;C1&quot;) left = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack1]) right = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;right&quot;, tip_racks=[tiprack2]) If you&apos;re writing a protocol that uses the Flex Gripper, you might think that this would be the place in your protocol to declare that. However, the gripper doesn&apos;t require ``load_instrument``! Whether your gripper requires a protocol is determined by the presence of :py:meth:`.ProtocolContext.move_labware` commands. See :ref:`moving-labware` for more details. Loading a Flex 96-Channel Pipette ================================= This code sample loads the Flex 96-Channel Pipette. Because of its size, the Flex 96-Channel Pipette requires the left *and* right pipette mounts. You cannot use this pipette with 1- or 8-Channel Pipette in the same protocol or when these instruments are attached to the robot. Load the 96-channel pipette as follows: .. code-block:: python def run(protocol: protocol_api.ProtocolContext): pipette = protocol.load_instrument( instrument_name=&quot;flex_96channel_1000&quot; ) In protocols specifying API version 2.15, also include ``mount=&quot;left&quot;`` as a parameter of ``load_instrument()``. .. versionadded:: 2.15 .. versionchanged:: 2.16 The ``mount`` parameter is optional. Loading OT-2 Pipettes ===================== This code sample loads a P1000 Single-Channel GEN2 pipette in the left mount and a P300 Single-Channel GEN2 pipette in the right mount. Each pipette uses its own 1000 µL tip rack. .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): tiprack1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_1000ul&quot;, location=1) tiprack2 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_1000ul&quot;, location=2) left = protocol.load_instrument( instrument_name=&quot;p1000_single_gen2&quot;, mount=&quot;left&quot;, tip_racks=[tiprack1]) right = protocol.load_instrument( instrument_name=&quot;p300_multi_gen2&quot;, mount=&quot;right&quot;, tip_racks=[tiprack1]) .. versionadded:: 2.0 .. _pipette-tip-racks: Adding Tip Racks ================ The ``load_instrument()`` method includes the optional argument ``tip_racks``. This parameter accepts a list of tip rack labware objects, which lets you to specify as many tip racks as you want. You can also edit a pipette&apos;s tip racks after loading it by setting its :py:obj:`.InstrumentContext.tip_racks` property. .. note:: Some methods, like :py:meth:`.configure_nozzle_layout`, reset a pipette&apos;s tip racks. See :ref:`partial-tip-pickup` for more information. The advantage of using ``tip_racks`` is twofold. First, associating tip racks with your pipette allows for automatic tip tracking throughout your protocol. Second, it removes the need to specify tip locations in the :py:meth:`.InstrumentContext.pick_up_tip` method. For example, let&apos;s start by loading loading some labware and instruments like this:: def run(protocol: protocol_api.ProtocolContext): tiprack_left = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D1&quot;) tiprack_right = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) left_pipette = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;left&quot;) right_pipette = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;right&quot;, tip_racks=[tiprack_right]) Let&apos;s pick up a tip with the left pipette. We need to specify the location as an argument of ``pick_up_tip()``, since we loaded the left pipette without a ``tip_racks`` argument. .. code-block:: python left_pipette.pick_up_tip(tiprack_left[&quot;A1&quot;]) left_pipette.drop_tip() But now you have to specify ``tiprack_left`` every time you call ``pick_up_tip``, which means you&apos;re doing all your own tip tracking:: left_pipette.pick_up_tip(tiprack_left[&quot;A2&quot;]) left_pipette.drop_tip() left_pipette.pick_up_tip(tiprack_left[&quot;A3&quot;]) left_pipette.drop_tip() However, because you specified a tip rack location for the right pipette, the robot will automatically pick up from location ``A1`` of its associated tiprack:: right_pipette.pick_up_tip() right_pipette.drop_tip() Additional calls to ``pick_up_tip`` will automatically progress through the tips in the right rack:: right_pipette.pick_up_tip() # picks up from A2 right_pipette.drop_tip() right_pipette.pick_up_tip() # picks up from A3 right_pipette.drop_tip() .. versionadded:: 2.0 See also :ref:`v2-atomic-commands` and :ref:`v2-complex-commands`. .. _pipette-trash-containers: Adding Trash Containers ======================= The API automatically assigns a :py:obj:`.trash_container` to pipettes, if one is available in your protocol. The ``trash_container`` is where the pipette will dispose tips when you call :py:meth:`.drop_tip` with no arguments. You can change the trash container, if you don&apos;t want to use the default. One example of when you might want to change the trash container is a Flex protocol that goes through a lot of tips. In a case where the protocol uses two pipettes, you could load two trash bins and assign one to each pipette:: left_pipette = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;left&quot; ) right_pipette = protocol.load_instrument( instrument_name=&quot;flex_8channel_50&quot;, mount=&quot;right&quot; ) left_trash = load_trash_bin(&quot;A3&quot;) right_trash = load_trash_bin(&quot;B3&quot;) left_pipette.trash_container = left_trash right_pipette.trash_container = right_trash Another example is a Flex protocol that uses a waste chute. Say you want to only dispose labware in the chute, and you want the pipette to drop tips in a trash bin. You can implicitly get the trash bin to be the pipette&apos;s ``trash_container`` based on load order, or you can ensure it by setting it after all the load commands:: pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot; ) chute = protocol.load_waste_chute() # default because loaded first trash = protocol.load_trash_bin(&quot;A3&quot;) pipette.trash_container = trash # overrides default .. versionadded:: 2.0 .. versionchanged:: 2.16 Added support for ``TrashBin`` and ``WasteChute`` objects. .. _lpd: Liquid Presence Detection ========================= Liquid presence detection is a pressure-based feature that allows Opentrons Flex pipettes to detect the presence or absence of liquids in a well, reservoir, tube, or other container. It gives you the ability to identify, avoid, and recover from liquid-related protocol errors. When detecting liquid, the pipette slowly moves a fresh, empty tip downward from the top of the well until it contacts the liquid. The downward probing motion can take anywhere from 5 to 50 seconds, depending on the depth of the well and how much liquid it contains. For example, it will take much less time to detect liquid in a full flat well plate than in an empty (or nearly empty) large tube. You can enable this feature for an entire protocol run or toggle it on and off as required. Consider the amount of time automatic detection will add to your protocol. If you only need to detect liquid infrequently, use the :ref:`corresponding building block commands &amp;lt;detect-liquid-presence&amp;gt;` instead. Automatic liquid presence detection is disabled by default. Pipette Compatibility --------------------- Liquid presence detection works with Flex 1-, 8-, and 96-channel pipettes only. 1-channel pipettes have one pressure sensor. The 8-channel pipette pressure sensors are on channels 1 and 8 (positions A1 and H1). The 96-channel pipette pressure sensors are on channels 1 and 96 (positions A1 and H12). Other channels on multi-channel pipettes do not have sensors and cannot detect liquid. Enabling Globally ----------------- To automatically use liquid presence detection, add the optional Boolean argument ``liquid_presence_detection=True`` to :py:meth:`.ProtocolContext.load_instrument` in your protocol. The robot will check for liquid on every aspiration. You can also turn this feature off and back on again later in a protocol. This example enables liquid presence detection on the 8-channel pipette used in the sample protocol at the top of the page. .. code-block:: python right = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;right&quot;, tip_racks=[tiprack2], liquid_presence_detection=True ) .. note:: Accurate liquid detection requires fresh, dry pipette tips. Protocols using this feature must discard used tips after an aspirate/dispense cycle and pick up new tips before the next cycle. :ref:`Complex commands &amp;lt;v2-complex-commands&amp;gt;` may include aspirate steps after a tip is already wet. When global liquid detection is enabled, use :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` to ensure that your protocol picks up a tip immediately before aspiration. The API will not raise an error during liquid detection if a tip is empty but wet. It will raise an error if liquid detection is active and your protocol attempts to aspirate with liquid in the tip. Let&apos;s take a look at how all this works. With automatic liquid detection enabled, tell the robot to pick up a clean tip, aspirate 100 µL from a reservoir, and dispense that volume into a well plate: .. code-block:: python right.pick_up_tip() right.aspirate(100, reservoir[&quot;A1&quot;]) # checks for liquid right.dispense(100, plate[&quot;A1&quot;]) Liquid detection takes place prior to aspiration. Upon detecting a liquid, the pipette stops, raises itself above the liquid&apos;s surface, and then aspirates according to your protocol. Checking for a liquid adds time to your protocol run, so be aware of that before using it. If Flex doesn&apos;t detect liquid, it raises an error and stops the protocol until the problem is resolved. However, aspiration isn&apos;t required for liquid level detection. Two standalone methods, :py:meth:`.detect_liquid_presence` and :py:meth:`.require_liquid_presence`, let you add liquid detection to a protocol with or without aspirating. Automatic detection is the same as calling ``require_liquid_presence()`` before every aspiration. See :ref:`detect-liquid-presence` and :ref:`require-liquid-presence` for details. .. versionadded:: 2.20 Activating and Deactivating --------------------------- You can turn liquid presence detection off and on throughout a protocol. To turn it off, set ``pipette.liquid_presence_detection=False`` at the point in a protocol where it needs to be disabled, usually between picking up a new tip and aspirating a liquid. This overrides the global argument, ``liquid_presence_detection=True`` that we set on :py:meth:`~.ProtocolContext.load_instrument`. Let&apos;s try this after picking up a new tip. .. code-block:: python right.pick_up_tip() right.liquid_presence_detection = False # Turns off liquid presence detection. right.aspirate(100, reservoir[&quot;A2&quot;]) # Aspirates immediately. From now on, the pipette will not check for liquid until you turn this feature back on. To reactivate, set ``liquid_presence_detection=True`` at the point later in the protocol where it needs to be enabled, usually between picking up a new tip and aspirating a liquid. .. code-block:: python right.pick_up_tip() right.liquid_presence_detection = True # Turns on liquid presence detection. right.aspirate(100, reservoir[&quot;A3&quot;]) # Detects liquid before aspirating. The robot will continue to check for liquid until this feature is disabled again, or an empty well is detected (and the robot raises an error), or the protocol completes. .. versionadded:: 2.20</content></file><file name="partial_tip_pickup.rst" type="rst"><content>:og:description: How to change the number of tips an Opentrons pipette uses. .. _partial-tip-pickup: ****************** Partial Tip Pickup ****************** By default, multi-channel pipettes always use all of their nozzles to pick up tips and handle liquids: an 8-channel pipette picks up 8 tips at once, and a 96-channel pipette picks up 96 tips at once. Partial tip pickup lets you configure a multi-channel pipette to use fewer tips. This expands the liquid handling capabilities of your robot without having to physically switch pipettes, and is especially useful for the Flex 96-Channel Pipette, which occupies both pipette mounts. Before getting started with partial tip pickup, make sure your protocol specifies an API version that supports the configuration you need. .. list-table:: :header-rows: 1 * - Pipette - Partial configuration - Minimum API version * - Flex 96-Channel Pipette - Column - 2.16 * - Flex 96-Channel Pipette - Single, row - 2.20 * - Flex 8-Channel Pipettes - Single, partial column - 2.20 * - OT-2 Multi-Channel Pipettes - Single, partial column - 2.20 .. _nozzle-layouts: Nozzle Layouts ============== Use the :py:meth:`.configure_nozzle_layout` method to choose how many tips a pipette will pick up. The method&apos;s required ``style`` parameter only accepts special layout constants. You must import these constants at the top of your protocol, or you won&apos;t be able to configure the pipette for partial tip pickup. At minimum, import the API from the ``opentrons`` package:: from opentrons import protocol_api This import statement lets you configure a layout with a parameter like ``style=protocol_api.COLUMN``. For greater convenience, also import the individual layout constants that you plan to use in your protocol:: from opentrons.protocol_api import COLUMN, ALL This more specific import statement lets you configure a layout with a parameter like ``style=COLUMN``. However, you wouldn&apos;t be able to set ``style=ROW`` without also importing that constant. The examples in the sections below use the shorter style and show the other required parameters of ``configure_nozzle_layout()``. Column Layout ------------- Here is the start of a protocol that imports the ``COLUMN`` and ``ALL`` layout constants, loads a 96-channel pipette, and sets it to pick up a single column of tips. .. code-block:: python :substitutions: from opentrons import protocol_api from opentrons.protocol_api import COLUMN, ALL requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): partial_rack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D3&quot; ) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument(&quot;flex_96channel_1000&quot;) pipette.configure_nozzle_layout( style=COLUMN, start=&quot;A12&quot;, tip_racks=[partial_rack] ) .. versionadded:: 2.16 Let&apos;s unpack some of the details of this code. First, we&apos;ve given a special name to the tip rack, ``partial_rack``. You can name your tip racks whatever you like, but if you&apos;re using a 96-channel pipette for full pickup and partial pickup in the same protocol, you&apos;ll need to keep them separate. See :ref:`partial-tip-rack-adapters` below. Next, we load the 96-channel pipette. Note that :py:meth:`.load_instrument` only has a single argument. The 96-channel pipette occupies both mounts, so ``mount`` is omissible. The ``tip_racks`` argument is always optional. But it would have no effect to declare it here, because every call to ``configure_nozzle_layout()`` resets the pipette&apos;s :py:obj:`.InstrumentContext.tip_racks` property. Finally, we configure the nozzle layout, with three arguments. - The ``style`` parameter directly accepts the ``COLUMN`` constant, since we imported it at the top of the protocol. - The ``start`` parameter accepts a nozzle name, representing the primary nozzle in the layout, as a string. ``&quot;A12&quot;`` tells the pipette to use its rightmost column of nozzles for pipetting. - The ``tip_racks`` parameter tells the pipette which racks to use for tip tracking, just like :ref:`adding tip racks &amp;lt;pipette-tip-racks&amp;gt;` when loading a pipette. In this configuration, pipetting actions will use a single column:: pipette.pick_up_tip() # picks up A1-H1 from tip rack pipette.drop_tip() pipette.pick_up_tip() # picks up A2-H2 from tip rack .. warning:: :py:meth:`.InstrumentContext.pick_up_tip` always accepts a ``location`` argument, regardless of nozzle configuration. Do not pass a value that would lead the pipette to line up over more unused tips than specified by the current layout. For example, setting ``COLUMN`` layout and then calling ``pipette.pick_up_tip(tip_rack[&quot;A2&quot;])`` on a full tip rack will lead to unexpected pipetting behavior and potential crashes. Row Layout ---------- Here is the start of a protocol that imports the ``ROW`` and ``ALL`` layout constants, loads a 96-channel pipette, and sets it to pick up a single row of tips. .. code-block:: python :substitutions: from opentrons import protocol_api from opentrons.protocol_api import ROW, ALL requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): partial_rack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D3&quot; ) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument(&quot;flex_96channel_1000&quot;) pipette.configure_nozzle_layout( style=ROW, start=&quot;H1&quot;, tip_racks=[partial_rack] ) .. versionadded:: 2.20 Setting ``start=&quot;H1&quot;`` means the pipette will use its frontmost nozzles to pick up tips, starting from the back of the tip rack:: pipette.pick_up_tip() # picks up A1-A12 from tip rack pipette.drop_tip() pipette.pick_up_tip() # picks up B1-B12 from tip rack You can also set ``start=&quot;A1&quot;`` to use the backmost nozzles and pick up from the front of the tip rack. .. note:: Consider the placement of your tip rack when choosing the ``start`` value for row pickup. The pipette cannot pick up from back to front (``start=&quot;H1&quot;``) on tip racks in row A of the deck, nor can it pick up from front to back (``start=&quot;A1&quot;``) on tip racks in row D of the deck. This is because the pipette can&apos;t move far enough backward or forward, respectively, to align over those tips. Use a different ``start`` value, or load the tip rack in row B or C. Single Layout ------------- Single-tip pickup is available on both 8-channel and 96-channel pipettes. 8-channel pipettes can pick up a single tip with either the front or back nozzle. 96-channel pipettes can pick up a single tip with any of the corner nozzles. .. note:: Remember that only the A1 and H12 nozzles of the 96-channel pipette contain pressure sensors. Avoid using the A12 and H1 nozzles for single-tip pickup if you need to detect liquid presence within wells. The ``start`` parameter sets the first and only nozzle used in the configuration. It also affects the order in which the pipette picks up tips. When using automatic tip tracking, single-tip configurations always consume all tips within a single column before proceeding to another column. .. list-table:: :header-rows: 1 * - Pipette type - ``start`` well - Pickup order * - 8-channel - A1 - | Front to back, left to right | (H1 through A1, H2 through A2, …) * - 8-channel - H1 - | Back to front, left to right | (A1 through H1, A2 through H2, …) * - 96-channel - A1 - | Front to back, right to left | (H12 through A12, H11 through A11, …) * - 96-channel - H1 - | Back to front, right to left | (A12 through H12, A11 through H11, …) * - 96-channel - A12 - | Front to back, left to right | (H1 through A1, H2 through A2, …) * - 96-channel - H12 - | Back to front, left to right | (A1 through H1, A2 through H2, …) .. warning:: In certain conditions, tips in adjacent columns may cling to empty nozzles during single-tip pickup. You can avoid this by overriding automatic tip tracking to pick up tips row by row, rather than column by column. The code sample below demonstrates how to pick up tips this way. However, as with all partial tip layouts, be careful that you don&apos;t place the pipette in a position where it overlaps more tips than intended. Here is the start of a protocol that imports the ``SINGLE`` and ``ALL`` layout constants, loads an 8-channel pipette, and sets it to pick up a single tip. .. code-block:: python :substitutions: from opentrons import protocol_api from opentrons.protocol_api import SINGLE, ALL requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): partial_rack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D3&quot; ) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_8channel_1000&quot;, mount=&quot;left&quot; ) pipette.configure_nozzle_layout( style=SINGLE, start=&quot;H1&quot; ) .. versionadded:: 2.20 To pick up tips row by row, first construct a list of all wells in the tip rack ordered from A1, A2 … H11, H12. One way to do this is to use :py:func:`sum` to flatten the list of lists returned by :py:meth:`.Labware.rows`:: tips_by_row = sum(partial_rack.rows(), []) Then ``pop`` items from the front of the list (index 0) and pass them as the ``location`` of :py:meth:`.pick_up_tip`:: # pick up A1 from tip rack pipette.pick_up_tip(location=tips_by_row.pop(0)) pipette.drop_tip() # pick up A2 from tip rack pipette.pick_up_tip(location=tips_by_row.pop(0)) Partial Column Layout --------------------- Partial column pickup is available on 8-channel pipettes only. Partial columns contain 2 to 7 consecutive tips in a single column. The pipette always picks up partial columns with its frontmost nozzles (``start=&quot;H1&quot;``). To specify the number of tips to pick up, add the ``end`` parameter when calling :py:meth:`.configure_nozzle_layout`. Use the chart below to determine the ending nozzle (G1 through B1) for your desired number of tips. .. list-table:: :stub-columns: 1 * - Number of tips - 2 - 3 - 4 - 5 - 6 - 7 * - ``end`` nozzle - G1 - F1 - E1 - D1 - C1 - B1 When picking up 3, 5, 6, or 7 tips, extra tips will be left at the front of each column. You can use these tips with a different nozzle configuration, or you can manually re-rack them at the end of your protocol for future use. .. warning:: In certain conditions, tips in adjacent columns may cling to empty nozzles during partial-column pickup. You can avoid this by overriding automatic tip tracking to pick up tips row by row, rather than column by column. The code sample below demonstrates how to pick up tips this way. However, as with all partial tip layouts, be careful that you don&apos;t place the pipette in a position where it overlaps more tips than intended. Here is the start of a protocol that imports the ``PARTIAL_COLUMN`` and ``ALL`` layout constants, loads an 8-channel pipette, and sets it to pick up four tips: .. code-block:: python :substitutions: from opentrons import protocol_api from opentrons.protocol_api import PARTIAL_COLUMN, ALL requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): partial_rack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;B2&quot; ) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument(&quot;flex_8channel_1000&quot;, mount=&quot;left&quot;) pipette.configure_nozzle_layout( style=PARTIAL_COLUMN, start=&quot;H1&quot;, end=&quot;E1&quot; ) .. versionadded:: 2.20 When pipetting in partial column configuration, remember that *the frontmost channel of the pipette is its primary channel*. To pick up tips across the back half of the rack, then across the front half of the rack, construct a list of that includes all and only the wells in row D and row H:: tips_by_row = partial_rack.rows_by_name()[&quot;D&quot;] + partial_rack.rows_by_name()[&quot;H&quot;] Then ``pop`` items from the front of the list (index 0) and pass them as the ``location`` of :py:meth:`.pick_up_tip`:: # pick up A1-D1 from tip rack pipette.pick_up_tip(location=tips_by_row.pop(0)) pipette.drop_tip() # pick up A2-D2 from tip rack pipette.pick_up_tip(location=tips_by_row.pop(0)) To use the same configuration as above to transfer liquid from wells A1–D1 to wells A2–D2 on a plate, you must use the wells in row D as the source and destination targets:: # pipette in 4-nozzle partial column layout pipette.transfer( volume=100, source=plate[&quot;D1&quot;], # aspirate from A1-D1 dest=plate[&quot;D2&quot;], # dispense into A2-D2 ) .. warning:: Do not move the pipette to row A of labware when in ``PARTIAL_COLUMN`` configuration! This is different than when pipetting to a full column, either with the 8-channel pipette in ``ALL`` configuration or with the 96-channel pipette in ``COLUMN`` configuration. If you pipette to row A, the frontmost tip will move to row A and the other tips — further back in the layout — will hang over the back edge of the labware. They will not enter the correct wells and they will likely cause a crash. .. _partial-tip-rack-adapters: Tip Rack Adapters ================= You can use both partial and full tip pickup in the same protocol. When using both with a 96-channel pipette, you must load some tip racks directly on the deck, and some tip racks in a tip rack adapter. Do not use a tip rack adapter when performing partial tip pickup with a 96-channel pipette. Instead, place the tip rack on the deck. During partial tip pickup, the 96-channel pipette lowers onto the tip rack in an offset position. If the tip rack were in its adapter, the pipette could collide with the adapter&apos;s posts, which protrude above the top of the tip rack. If you configure the 96-channel pipette for partial pickup and then call ``pick_up_tip()`` on a tip rack that&apos;s loaded onto an adapter, the API will raise an error. On the other hand, you must use the tip rack adapter for full rack pickup. If the 96-channel pipette is in a full layout, either by default or by configuring ``style=ALL``, and you then call ``pick_up_tip()`` on a tip rack that&apos;s not in an adapter, the API will raise an error. When switching between full and partial pickup, you may want to organize your tip racks into lists, depending on whether they&apos;re loaded on adapters or not. .. code-block:: python tips_1 = protocol.load_labware( &quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;C1&quot; ) tips_2 = protocol.load_labware( &quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;D1&quot; ) tips_3 = protocol.load_labware( &quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;C3&quot;, adapter=&quot;opentrons_flex_96_tiprack_adapter&quot; ) tips_4 = protocol.load_labware( &quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;D3&quot;, adapter=&quot;opentrons_flex_96_tiprack_adapter&quot; ) partial_tip_racks = [tips_1, tips_2] full_tip_racks = [tips_3, tips_4] .. Tip:: It&apos;s also good practice to keep separate lists of tip racks when using multiple partial tip pickup configurations (e.g., using both column 1 and column 12 in the same protocol). This improves positional accuracy when picking up tips. Additionally, use Labware Position Check in the Opentrons App to ensure that the partial configuration is well-aligned to the rack. Now, when you configure the nozzle layout, you can reference the appropriate list as the value of ``tip_racks``:: pipette.configure_nozzle_layout( style=COLUMN, start=&quot;A12&quot;, tip_racks=partial_tip_racks ) # partial pipetting commands go here pipette.configure_nozzle_layout( style=ALL, tip_racks=full_tip_racks ) pipette.pick_up_tip() # picks up full rack in C3 This keeps tip tracking consistent across each type of pickup. And it reduces the risk of errors due to the incorrect presence or absence of a tip rack adapter. Tip Pickup and Conflicts ======================== During partial tip pickup, the pipette moves into spaces above adjacent slots. To avoid crashes, the API prevents you from performing partial tip pickup in locations where the pipette could collide with the outer edges of the robot or labware in the working area. The current nozzle layout, pickup or pipetting location, and adjacent labware determine whether a particular pipetting action is safe to perform. The API will raise errors for potential crashes when using a partial nozzle configuration. Nevertheless, it&apos;s a good idea to do the following when working with partial tip pickup: - Plan your deck layout carefully. Make a diagram and visualize everywhere the pipette will travel. - Simulate your protocol and compare the output to your expectations of where the pipette will travel. - Perform a dry run with only tip racks on the deck. Have the Emergency Stop Pendant handy in case you see an impending crash. Deck Extents ------------ When using partial nozzle configurations around the back, right, and front edges of the deck, there are limitations on how far the pipette can move beyond the outer edge of the deck slot. The API will raise an error if you try to pipette beyond these outer `extents` of the working area. .. tip:: There are no extents-related limitations on slots B1, B2, C1, and C2. When performing partial pickup and pipetting in these slots, you only have to consider :ref:`possible labware conflicts &amp;lt;partial-labware-conflicts&amp;gt;`. One way to think of deck extents is in terms of where you can pick up tips or pipette to a 96-well plate loaded in a given slot. These limitations only apply when using a layout that places the pipette further towards the windows of the robot than an ``ALL`` layout would. For example, using a ``ROW`` layout with the frontmost nozzles of the 96-channel pipette, it will never move farther forward than the H row of a labware in slots D1–D3. But using a ``ROW`` layout with the backmost nozzles would bring it farther forward — it could collide with the front window, except that the API prevents it. The following table summarizes the limitations in place along each side of the deck. .. list-table:: :header-rows: 1 * - Deck slots - Nozzle configuration - Inaccessible wells * - A1–D1 (left edge) - Rightmost column - None (all wells accessible) * - A1–A3 (back edge) - Frontmost row - Rows A–G * - A3–D3 (right edge) - Leftmost column - Columns 11–12 * - D1–D3 (front edge) - Backmost row - Rows F–H To visualize these limitations, the below deck map shades all wells that have a single limitation in light blue, and all wells that have two limitations in dark blue. .. image:: ../../img/partial-pickup-deck-extents.png Multiple limitations occur when you use a ``SINGLE`` configuration that uses the innermost corner nozzle, with respect to the pipette&apos;s position on the deck. For example, using nozzle A1 on the 96-channel pipette has multiple limitations in slot D3. Additionally, column A of plates loaded on a Thermocycler Module is inaccessible by the rightmost nozzles of the 96-channel pipette. Although the API treats such plates as being in slot A1, the physical location of a plate on the Thermocycler is slightly further left than a plate loaded directly on the slot. .. _partial-labware-conflicts: Arranging Labware ----------------- For column pickup, Opentrons recommends using the nozzles in column 12 of the pipette:: pipette.configure_nozzle_layout( style=COLUMN, start=&quot;A12&quot;, ) .. note:: When using a column 1 layout, the pipette can&apos;t reach the rightmost portion of labware in slots A3–D3. Any well that is within 29 mm of the right edge of the slot may be inaccessible. Use a column 12 layout if you need to pipette in that area. When using column 12, the pipette overhangs space to the left of wherever it is picking up tips or pipetting. For this reason, it&apos;s a good idea to organize tip racks front to back on the deck. If you place them side by side, the rack to the right will be inaccessible. For example, let&apos;s load three tip racks in the front left corner of the deck:: tips_C1 = protocol.load_labware(&quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;C1&quot;) tips_D1 = protocol.load_labware(&quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;D1&quot;) tips_D2 = protocol.load_labware(&quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;D2&quot;) Now the pipette will be able to access the racks in column 1 only. ``pick_up_tip(tips_D2[&quot;A1&quot;])`` will raise an error due to the tip rack immediately to its left, in slot D1. There a couple of ways to avoid this error: - Load the tip rack in a different slot, with no tall labware to its left. - Use all the tips in slot D1 first, and then use :py:meth:`.move_labware` to make space for the pipette before picking up tips from D2. You would get a similar error trying to aspirate from or dispense into a well plate in slot D3, since there is a tip rack to the left. .. tip:: When using column 12 nozzles for partial tip pickup and pipetting, generally organize your deck with the shortest labware on the left side of the deck, and the tallest labware on the right side. Similarly, when using the frontmost row of nozzles for partial tip pickup and pipetting, organize your deck with the shortest labware towards the back of the deck, and the tallest labware towards the front of the deck.</content></file><file name="volume_modes.rst" type="rst"><content>:og:description: How to work with very small volumes of liquid on Opentrons Flex. .. _pipette-volume-modes: Volume Modes ============ The Flex 1-Channel 50 µL and Flex 8-Channel 50 µL pipettes must operate in a low-volume mode to accurately dispense very small volumes of liquid. Set the volume mode by calling :py:meth:`.InstrumentContext.configure_for_volume` with the amount of liquid you plan to aspirate, in µL:: pipette50.configure_for_volume(1) pipette50.pick_up_tip() pipette50.aspirate(1, plate[&quot;A1&quot;]) .. versionadded:: 2.15 Passing different values to ``configure_for_volume()`` changes the minimum and maximum volume of Flex 50 µL pipettes as follows: .. list-table:: :header-rows: 1 :widths: 2 3 3 * - Value - Minimum Volume (µL) - Maximum Volume (µL) * - 1–4.9 - 1 - 30 * - 5–50 - 5 - 50 .. note:: The pipette must not contain liquid when you call ``configure_for_volume()``, or the API will raise an error. Also, if the pipette is in a well location that may contain liquid, it will move upward to ensure it is not immersed in liquid before changing its mode. Calling ``configure_for_volume()`` *before* ``pick_up_tip()`` helps to avoid this situation. In a protocol that handles many different volumes, it&apos;s a good practice to call ``configure_for_volume()`` once for each :py:meth:`.transfer` or :py:meth:`.aspirate`, specifying the volume that you are about to handle. When operating with a list of volumes, nest ``configure_for_volume()`` inside a ``for`` loop to ensure that the pipette is properly configured for each volume: .. code-block:: python volumes = [1, 2, 3, 4, 1, 5, 2, 8] sources = plate.columns()[0] destinations = plate.columns()[1] for i in range(8): pipette50.configure_for_volume(volumes[i]) pipette50.pick_up_tip() pipette50.aspirate(volume=volumes[i], location=sources[i]) pipette50.dispense(location=destinations[i]) pipette50.drop_tip() If you know that all your liquid handling will take place in a specific mode, then you can call ``configure_for_volume()`` just once with a representative volume. Or if all the volumes correspond to the pipette&apos;s default mode, you don&apos;t have to call ``configure_for_volume()`` at all.</content></file></directory><file name="adapting_ot2_flex.rst" type="rst"><content>:og:description: How to adapt an OT-2 Python protocol to run on Opentrons Flex. .. _adapting-ot2-protocols: ******************************** Adapting OT-2 Protocols for Flex ******************************** Python protocols designed to run on the OT-2 can&apos;t be directly run on Flex without some modifications. This page describes the minimal steps that you need to take to get OT-2 protocols analyzing and running on Flex. Adapting a protocol for Flex lets you have parity across different Opentrons robots in your lab, or you can extend older protocols to take advantage of new features only available on Flex. Depending on your application, you may need to do additional verification of your adapted protocol. Examples on this page are in tabs so you can quickly move back and forth to see the differences between OT-2 and Flex code. Metadata and Requirements ========================= Flex requires you to specify an ``apiLevel`` of 2.15 or higher. If your OT-2 protocol specified ``apiLevel`` in the ``metadata`` dictionary, it&apos;s best to move it to the ``requirements`` dictionary. You can&apos;t specify it in both places, or the API will raise an error. .. note:: Consult the :ref:`list of changes in API versions &amp;lt;version-notes&amp;gt;` to see what effect raising the ``apiLevel`` will have. If you increased it by multiple minor versions to get your protocol running on Flex, make sure that your protocol isn&apos;t using removed commands or commands whose behavior has changed in a way that may affect your scientific results. You also need to specify ``&quot;robotType&quot;: &quot;Flex&quot;``. If you omit ``robotType`` in the ``requirements`` dictionary, the API will assume the protocol is designed for the OT-2. .. tabs:: .. tab:: Original OT-2 code .. code-block:: python :substitutions: from opentrons import protocol_api metadata = { &quot;protocolName&quot;: &quot;My Protocol&quot;, &quot;description&quot;: &quot;This protocol uses the OT-2&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot; } .. tab:: Updated Flex code .. code-block:: python :substitutions: from opentrons import protocol_api metadata = { &quot;protocolName&quot;: &quot;My Protocol&quot;, &quot;description&quot;: &quot;This protocol uses the Flex&quot;, } requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} Pipettes and Tip-rack Load Names ================================ Flex uses different types of pipettes and tip racks than OT-2, which have their own load names in the API. If possible, load Flex pipettes of the same capacity or larger than the OT-2 pipettes. See the :ref:`list of pipette API load names &amp;lt;new-pipette-models&amp;gt;` for the valid values of ``instrument_name`` in Flex protocols. And check `Labware Library &amp;lt;https://labware.opentrons.com&amp;gt;`_ or the Opentrons App for the load names of Flex tip racks. .. note:: If you use smaller capacity tips than in the OT-2 protocol, you may need to make further adjustments to avoid running out of tips. Also, the protocol may have more steps and take longer to execute. This example converts OT-2 code that uses a P300 Single-Channel GEN2 pipette and 300 µL tips to Flex code that uses a Flex 1-Channel 1000 µL pipette and 1000 µL tips. .. tabs:: .. tab:: Original OT-2 code .. code-block:: python def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, 1) left_pipette = protocol.load_instrument( &quot;p300_single_gen2&quot;, &quot;left&quot;, tip_racks=[tips] ) .. tab:: Updated Flex code .. code-block:: python def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_flex_96_tiprack_1000ul&quot;, &quot;D1&quot;) left_pipette = protocol.load_instrument( &quot;flex_1channel_1000&quot;, &quot;left&quot;, tip_racks[tips] ) Trash Container =============== OT-2 protocols always have a :py:obj:`.fixed_trash` in slot 12. In Flex protocols specifying API version 2.16 or later, you need to :ref:`load a trash bin &amp;lt;configure-trash-bin&amp;gt;`. Put it in slot A3 to match the physical position of the OT-2 fixed trash:: trash = protocol.load_trash_bin(&quot;A3&quot;) Deck Slot Labels ================ It&apos;s good practice to update numeric labels for :ref:`deck slots &amp;lt;deck-slots&amp;gt;` (which match the labels on an OT-2) to coordinate ones (which match the labels on Flex). This is an optional step, since the two formats are interchangeable. For example, the code in the previous section changed the location of the tip rack from ``1`` to ``&quot;D1&quot;``. Module Load Names ================= If your OT-2 protocol uses older generations of the Temperature Module or Thermocycler Module, update the load names you pass to :py:meth:`.load_module` to ones compatible with Flex: * ``temperature module gen2`` * ``thermocycler module gen2`` or ``thermocyclerModuleV2`` The Heater-Shaker Module only has one generation, ``heaterShakerModuleV1``, which is compatible with Flex and OT-2. The Magnetic Module is not compatible with Flex. For protocols that load ``magnetic module``, ``magdeck``, or ``magnetic module gen2``, you will need to make further modifications to use the :ref:`Magnetic Block &amp;lt;magnetic-block&amp;gt;` and Flex Gripper instead. This will require reworking some of your protocol steps, and you should verify that your new protocol design achieves similar results. This simplified example, taken from a DNA extraction protocol, shows how using the Flex Gripper and the Magnetic Block can save time. Instead of pipetting an entire plate&apos;s worth of liquid from the Heater-Shaker to the Magnetic Module and then engaging the module, the gripper moves the plate to the Magnetic Block in one step. .. tabs:: .. tab:: Original OT-2 code .. code-block:: python hs_mod.set_and_wait_for_shake_speed(2000) protocol.delay(minutes=5) hs_mod.deactivate_shaker() for i in sample_plate.wells(): # mix, transfer, and blow-out all samples pipette.pick_up_tip() pipette.aspirate(100,hs_plate[i]) pipette.dispense(100,hs_plate[i]) pipette.aspirate(100,hs_plate[i]) pipette.air_gap(10) pipette.dispense(pipette.current_volume,mag_plate[i]) pipette.aspirate(50,hs_plate[i]) pipette.air_gap(10) pipette.dispense(pipette.current_volume,mag_plate[i]) pipette.blow_out(mag_plate[i].bottom(0.5)) pipette.drop_tip() mag_mod.engage() # perform elution steps .. tab:: Updated Flex code .. code-block:: python hs_mod.set_and_wait_for_shake_speed(2000) protocol.delay(minutes=5) hs_mod.deactivate_shaker() # move entire plate # no pipetting from Heater-Shaker needed hs_mod.open_labware_latch() protocol.move_labware(sample_plate, mag_block, use_gripper=True) # perform elution steps</content></file><file name="conf.py" type="py"><content>#!/usr/bin/env python3 # -*- coding: utf-8 -*- # # Opentrons API documentation build configuration file, created by # sphinx-quickstart on Thu Oct 27 12:10:26 2016. # # This file is execfile()d with the current directory set to its # containing dir. # # Note that not all possible configuration values are present in this # autogenerated file. # # All configuration values have a default; values that are commented out # serve to show the default. # If extensions (or modules to document with autodoc) are in another directory, # add these directories to sys.path here. If the directory is relative to the # documentation root, use os.path.abspath to make it absolute, like shown here. # import os import sys import json import pkgutil sys.path.insert(0, os.path.abspath(&apos;../..&apos;)) sys.path.insert(0, os.path.abspath(&apos;../sphinxext&apos;)) # -- General configuration ------------------------------------------------ # If your documentation needs a minimal Sphinx version, state it here. # # needs_sphinx = &apos;1.0&apos; # Add any Sphinx extension module names here, as strings. They can be # extensions coming with Sphinx (named &apos;sphinx.ext.*&apos;) or your custom # ones. extensions = [ &apos;sphinx.ext.autodoc&apos;, &apos;sphinx.ext.autosummary&apos;, &apos;sphinx.ext.coverage&apos;, &apos;sphinx.ext.doctest&apos;, &apos;sphinx.ext.imgmath&apos;, &apos;sphinx.ext.intersphinx&apos;, &apos;sphinx.ext.napoleon&apos;, &apos;sphinxext.opengraph&apos;, &apos;sphinx_tabs.tabs&apos;, # todo(mm, 2021-09-30): Remove numpydoc when we&apos;re done transitioning to # Google-style docstrings. github.com/Opentrons/opentrons/issues/7051 &apos;numpydoc&apos; ] intersphinx_mapping = {&apos;python&apos;: (&apos;https://docs.python.org/3&apos;, None)} # Add any paths that contain templates here, relative to this directory. templates_path = [&apos;../templates&apos;, &apos;../templates/v2&apos;] # The suffix(es) of source filenames. # You can specify multiple suffix as a list of string: # # source_suffix = [&apos;.rst&apos;, &apos;.md&apos;] source_suffix = &apos;.rst&apos; # The encoding of source files. # # source_encoding = &apos;utf-8-sig&apos; # The master toctree document. master_doc = &apos;index&apos; # General information about the project. project = &apos;Python Protocol API v2&apos; copyright = &apos;2010–23, Opentrons&apos; author = &apos;Opentrons Labworks&apos; # The version info for the project you&apos;re documenting, acts as replacement for # |version| and |release|, also used in various other places throughout the # built documents. # # todo(mm, 2021-09-30): Depending on where these show up, would it be more correct # to use the latest-supported *apiLevel* instead of the *Python package version*? sys.path.append(os.path.join(os.path.dirname(__file__), &apos;..&apos;, &apos;..&apos;, &apos;..&apos;, &apos;scripts&apos;)) import python_build_utils sys.path = sys.path[:-1] _vers = python_build_utils.get_version(&apos;api&apos;, &apos;robot-stack&apos;) # The short X.Y version. version = &apos;.&apos;.join(_vers.split(&apos;.&apos;)[:2]) # The full version, including alpha/beta/rc tags. release = _vers # setup the code block substitution extension to auto-update apiLevel extensions += [&apos;sphinx-prompt&apos;, &apos;sphinx_substitution_extensions&apos;] # use rst_prolog to hold the subsitution # update the apiLevel value whenever a new minor version is released rst_prolog = f&quot;&quot;&quot; .. |apiLevel| replace:: 2.22 .. |release| replace:: {release} &quot;&quot;&quot; # The language for content autogenerated by Sphinx. Refer to documentation # for a list of supported languages. # # This is also used if you do content translation via gettext catalogs. # Usually you set &quot;language&quot; from the command line for these cases. language = &apos;en&apos; # There are two options for replacing |today|: either, you set today to some # non-false value, then it is used: # # today = &apos;&apos; # # Else, today_fmt is used as the format for a strftime call. # # today_fmt = &apos;%B %d, %Y&apos; # List of patterns, relative to source directory, that match files and # directories to ignore when looking for source files. # This patterns also effect to html_static_path and html_extra_path exclude_patterns = [] # The reST default role (used for this markup: `text`) to use for all # documents. # # default_role = None # If true, &apos;()&apos; will be appended to :func: etc. cross-reference text. # # add_function_parentheses = True # If true, the current module name will be prepended to all description # unit titles (such as .. function::). # # add_module_names = True # If true, sectionauthor and moduleauthor directives will be shown in the # output. They are ignored by default. # # show_authors = False # The name of the Pygments (syntax highlighting) style to use. pygments_style = &apos;murphy&apos; # A list of ignored prefixes for module index sorting. # modindex_common_prefix = [] # If true, keep warnings as &quot;system message&quot; paragraphs in the built documents. # keep_warnings = False # If true, `todo` and `todoList` produce output, else they produce nothing. todo_include_todos = False # -- Options for HTML output ---------------------------------------------- # The theme to use for HTML and HTML Help pages. See the documentation for # a list of builtin themes. # html_theme = &apos;alabaster&apos; # Theme options are theme-specific and customize the look and feel of a theme # further. For a list of options available for each theme, see the # documentation. # html_theme_options = { &apos;travis_button&apos;: False, &apos;font_size&apos;: &apos;14px&apos;, &apos;font_family&apos;: &quot;&apos;Open Sans&apos;, sans-serif&quot;, &apos;head_font_family&apos;: &quot;&apos;AkkoPro-Regular&apos;, &apos;Open Sans&apos;&quot;, &apos;sidebar_collapse&apos;: &apos;True&apos;, &apos;fixed_sidebar&apos;: &apos;True&apos;, &apos;sidebar_width&apos;: &apos;270px&apos;, &apos;github_user&apos;: &apos;opentrons&apos;, &apos;github_repo&apos;: &apos;opentrons&apos;, &apos;github_button&apos;: True, # &apos;analytics_id&apos;: &apos;UA-83820700-1&apos;, &apos;description&apos;: &apos;Python Protocol API&apos;, &apos;link&apos;: &apos;#006FFF&apos;, &apos;link_hover&apos;: &apos;#05C1B3&apos;, &apos;sidebar_list&apos;: &apos;#05C1B3&apos;, &apos;sidebar_link_underscore&apos;: &apos;#DDDDDD&apos;, } # Add any paths that contain custom themes here, relative to this directory. # html_theme_path = [] # The name for this set of Sphinx documents. # &quot;&amp;lt;project&amp;gt; v&amp;lt;release&amp;gt; documentation&quot; by default. # html_title = &apos;Opentrons Python API V2 Documentation&apos; # A shorter title for the navigation bar. Default is the same as html_title. # # html_short_title = None # The name of an image file (relative to this directory) to place at the top # of the sidebar. # # html_logo = &apos;../img/logo.png&apos; # The name of an image file (relative to this directory) to use as a favicon of # the docs. This file should be a Windows icon file (.ico) being 16x16 or # 32x32 pixels large. # html_favicon = &apos;../img/OTfavicon.ico&apos; # Add any paths that contain custom static files (such as style sheets) here, # relative to this directory. They are copied after the builtin static files, # so a file named &quot;default.css&quot; will overwrite the builtin &quot;default.css&quot;. html_static_path = [&apos;../static&apos;] # Add any extra paths that contain custom files (such as robots.txt or # .htaccess) here, relative to this directory. These files are copied # directly to the root of the documentation. # # html_extra_path = [] # If not None, a &apos;Last updated on:&apos; timestamp is inserted at every page # bottom, using the given strftime format. # The empty string is equivalent to &apos;%b %d, %Y&apos;. # # html_last_updated_fmt = None # If true, SmartyPants will be used to convert quotes and dashes to # typographically correct entities. # # html_use_smartypants = True # Custom sidebar templates, maps document names to template names. # Use separate sidebar nav overrides to force (for apiv2) or ignore # (apiv1) the apiv2 hidden toctree elements (our sphinx overrides css # forces the body toctrees hidden using css) html_sidebars = { &apos;*&apos;: [ &apos;about.html&apos;, &apos;toc-with-nav.html&apos;, &apos;relations.html&apos;, &apos;searchbox.html&apos; ] } # Additional templates that should be rendered to pages, maps page names to # template names. # # html_additional_pages = {&apos;index&apos;: &apos;v2/index.html&apos;} # If false, no module index is generated. # # html_domain_indices = True # If false, no index is generated. # # html_use_index = True # If true, the index is split into individual pages for each letter. # # html_split_index = False # If true, links to the reST sources are added to the pages. # # html_show_sourcelink = True # If true, &quot;Created using Sphinx&quot; is shown in the HTML footer. Default is True. # # html_show_sphinx = True # If true, &quot;(C) Copyright ...&quot; is shown in the HTML footer. Default is True. # # html_show_copyright = True # If true, an OpenSearch description file will be output, and all pages will # contain a &amp;lt;link&amp;gt; tag referring to it. The value of this option must be the # base URL from which the finished HTML is served. # # html_use_opensearch = &apos;&apos; # This is the file name suffix for HTML files (e.g. &quot;.xhtml&quot;). # html_file_suffix = None # Language to be used for generating the HTML full-text search index. # Sphinx supports the following languages: # &apos;da&apos;, &apos;de&apos;, &apos;en&apos;, &apos;es&apos;, &apos;fi&apos;, &apos;fr&apos;, &apos;h&apos;, &apos;it&apos;, &apos;ja&apos; # &apos;nl&apos;, &apos;no&apos;, &apos;pt&apos;, &apos;ro&apos;, &apos;r&apos;, &apos;sv&apos;, &apos;tr&apos;, &apos;zh&apos; # # html_search_language = &apos;en&apos; # A dictionary with options for the search language support, empty by default. # &apos;ja&apos; uses this config value. # &apos;zh&apos; user can custom change `jieba` dictionary path. # # html_search_options = {&apos;type&apos;: &apos;default&apos;} # The name of a javascript file (relative to the configuration directory) that # implements a search results scorer. If empty, the default will be used. # # html_search_scorer = &apos;scorer.js&apos; # Output file base name for HTML help builder. htmlhelp_basename = &apos;OpentronsAPIV2doc&apos; # -- Options for LaTeX output --------------------------------------------- latex_elements = { # The paper size (&apos;letterpaper&apos; or &apos;a4paper&apos;). # # &apos;papersize&apos;: &apos;letterpaper&apos;, # The font size (&apos;10pt&apos;, &apos;11pt&apos; or &apos;12pt&apos;). # # &apos;pointsize&apos;: &apos;10pt&apos;, # Additional stuff for the LaTeX preamble. # # &apos;preamble&apos;: r&apos;\setlistdepth{15}&apos;, # Enable Greek symbol encoding for our sweet mus # &apos;fontenc&apos;: r&apos;\usepackage[LGR,T1]{fontenc}&apos;, # Latex figure (float) alignment # &apos;figure_align&apos;: &apos;H&apos;, &apos;maxlistdepth&apos;: &apos;10&apos;, } # Grouping the document tree into LaTeX files. List of tuples # (source start file, target name, title, # author, documentclass [howto, manual, or own class]). latex_documents = [ (master_doc, &apos;OpentronsPythonAPIV2.tex&apos;, &apos;Opentrons Python API V2 Documentation&apos;, &apos;Opentrons Labworks&apos;, &apos;howto&apos;), ] # The name of an image file (relative to this directory) to place at the top of # the title page. # latex_logo = &apos;../img/logo.png&apos; #latex_toplevel_sectioning = &apos;section&apos; # For &quot;manual&quot; documents, if this is true, then toplevel headings are parts, # not chapters. # # latex_use_parts = False # If true, show page references after internal links. # latex_show_pagerefs = True # If true, show URL addresses after external links. # latex_show_urls = &apos;footnote&apos; # Documents to append as an appendix to all manuals. # # latex_appendices = [] # It false, will not define \strong, \code, itleref, \crossref ... but only # \sphinxstrong, ..., \sphinxtitleref, ... To help avoid clash with user added # packages. # # latex_keep_old_macro_names = True # If false, no module index is generated. # # latex_domain_indices = True # -- Options for manual page output --------------------------------------- # One entry per manual page. List of tuples # (source start file, name, description, authors, manual section). man_pages = [] # If true, show URL addresses after external links. # # man_show_urls = False # -- Options for Texinfo output ------------------------------------------- # Grouping the document tree into Texinfo files. List of tuples # (source start file, target name, title, author, # dir menu entry, description, category) texinfo_documents = [] numpydoc_show_class_members = False # TODO: fix invalid :any: references suppress_warnings = [] # Documents to append as an appendix to all manuals. # # texinfo_appendices = [] # If false, no module index is generated. # # texinfo_domain_indices = True # How to display URL addresses: &apos;footnote&apos;, &apos;no&apos;, or &apos;inline&apos;. # # texinfo_show_urls = &apos;footnote&apos; # If true, do not generate a @detailmenu in the &quot;Top&quot; node&apos;s menu. # # texinfo_no_detailmenu = False # -- Options for Opengraph tags ------------------------------------------- ogp_site_url = &quot;https://docs.opentrons.com/v2/&quot; ogp_site_name = &quot;Opentrons Python Protocol API&quot; ogp_image = &quot;_static/PythonAPI.png&quot; ogp_description_length = 170 ogp_enable_meta_description = False # -- Options for tabs ----------------------------------------------------- sphinx_tabs_disable_tab_closing = True # -- Suppress autodoc warnings -------------------------------------------- # Ignore warnings for deliberately missing/undocumented things that appear # in automatically generated type signatures. # # The goal here is to pass through any warnings for bad targets of MANUALLY # created links. nitpick_ignore_regex = [ (&quot;py:class&quot;, r&quot;.*Optional\[.*&quot;), # any Optional with bad members (&quot;py:class&quot;, r&quot;.*commands\.types.*&quot;), (&quot;py:class&quot;, r&quot;.*hardware_control.*&quot;), (&quot;py:class&quot;, r&quot;.*legacy_broker.*&quot;), (&quot;py:class&quot;, r&quot;.*protocol_api\.core.*&quot;), (&quot;py:class&quot;, r&quot;.*api_support.*&quot;), (&quot;py:class&quot;, r&quot;.*duration\.estimator.*&quot;), (&quot;py:class&quot;, r&quot;.*protocols\.types.*&quot;), (&quot;py:class&quot;, r&quot;.*protocol_api\.deck.*&quot;), (&quot;py:class&quot;, r&quot;.*protocol_api\.config.*&quot;), (&quot;py:class&quot;, r&quot;.*opentrons_shared_data.*&quot;), (&quot;py:class&quot;, r&quot;.*protocol_api._parameters.Parameters.*&quot;), (&quot;py:class&quot;, r&quot;.*RobotContext&quot;), # shh it&apos;s a secret (for now) (&quot;py:class&quot;, r&quot;.*FlexStackerContext&quot;), # ssh it&apos;s a secret (for now) ( &quot;py:class&quot;, r&quot;.*AbstractLabware|APIVersion|LabwareLike|LoadedCoreMap|ModuleTypes|NoneType|OffDeckType|ProtocolCore|WellCore&quot;, ), # laundry list of not fully qualified things ]</content></file><file name="deck_slots.rst" type="rst"><content>:og:description: How to specify deck slots in the Python Protocol API. .. _deck-slots: ********** Deck Slots ********** Deck slots are where you place hardware items on the deck surface of your Opentrons robot. In the API, you load the corresponding items into your protocol with methods like :py:obj:`.ProtocolContext.load_labware`, :py:obj:`.ProtocolContext.load_module`, or :py:obj:`.ProtocolContext.load_trash_bin`. When you call these methods, you need to specify which slot to load the item in. Physical Deck Labels ==================== Flex uses a coordinate labeling system for slots A1 (back left) through D4 (front right). Columns 1 through 3 are in the *working area* and are accessible by pipettes and the gripper. Column 4 is in the *staging area* and is only accessible by the gripper. For more information on staging area slots, see :ref:`deck-configuration` below. .. image:: ../img/flex-deck.svg :width: 80% OT-2 uses a numeric labeling system for slots 1 (front left) through 11 (back center). The back right slot is occupied by the fixed trash. .. image:: ../img/OT-2-deck.svg :width: 55% API Deck Labels =============== The API accepts values that correspond to the physical deck slot labels on a Flex or OT-2 robot. Specify a slot in either format: * A coordinate like ``&quot;A1&quot;``. This format must be a string. * A number like ``&quot;10&quot;`` or ``10``. This format can be a string or an integer. As of API version 2.15, the Flex and OT-2 formats are interchangeable. You can use either format, regardless of which robot your protocol is for. You could even mix and match formats within a protocol, although this is not recommended. For example, these two ``load_labware()`` commands are equivalent: .. code-block:: python protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;A1&quot;) .. versionadded:: 2.15 .. code-block:: python protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, 10) .. versionadded:: 2.0 Both of these commands would require you to load the well plate in the back left slot of the robot. The correspondence between deck labels is based on the relative locations of the slots. The full list of slot equivalencies is as follows: .. list-table:: :stub-columns: 1 * - Flex - A1 - A2 - A3 - B1 - B2 - B3 - C1 - C2 - C3 - D1 - D2 - D3 * - OT-2 - 10 - 11 - Trash - 7 - 8 - 9 - 4 - 5 - 6 - 1 - 2 - 3 .. TODO staging slots and error handling of A4–D4 in OT-2 protocols Slots A4, B4, C4, and D4 on Flex have no equivalent on OT-2. .. _deck-configuration: Deck Configuration ================== A Flex running robot system version 7.1.0 or higher lets you specify its deck configuration on the touchscreen or in the Opentrons App. This tells the robot the positions of unpowered *deck fixtures*: items that replace standard deck slots. The following table lists currently supported deck fixtures and their allowed deck locations. .. list-table:: :header-rows: 1 * - Fixture - Slots * - Staging area slots - A3–D3 * - Trash bin - A1–D1, A3-D3 * - Waste chute - D3 Which fixtures you need to configure depend on both load methods and the effects of other methods called in your protocol. The following sections explain how to configure each type of fixture. .. _configure-staging-area-slots: Staging Area Slots ------------------ Slots A4 through D4 are the staging area slots. Pipettes can&apos;t reach the staging area, but these slots are always available in the API for loading and moving labware. Using a slot in column 4 as the ``location`` argument of :py:meth:`~.ProtocolContext.load_labware` or the ``new_location`` argument of :py:meth:`.move_labware` will require the corresponding staging area slot in the robot&apos;s deck configuration:: plate_1 = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;C3&quot; ) # no staging slots required plate_2 = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D4&quot; ) # one staging slot required protocol.move_labware( labware=plate_1, new_location=&quot;C4&quot; ) # two staging slots required .. versionadded:: 2.16 Since staging area slots also include a standard deck slot in column 3, they are physically incompatible with powered modules in the same row of column 3. For example, if you try to load a module in C3 and labware in C4, the API will raise an error:: temp_mod = protocol.load_module( module_name=&quot;temperature module gen2&quot;, location=&quot;C3&quot; ) staging_plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;C4&quot; ) # deck conflict error It is possible to use slot D4 along with the waste chute. See the :ref:`Waste Chute &amp;lt;configure-waste-chute&amp;gt;` section below for details. .. _configure-trash-bin: Trash Bin --------- In version 2.15 of the API, Flex can only have a single trash bin in slot A3. You do not have to (and cannot) load the trash in version 2.15 protocols. Starting in API version 2.16, you must load trash bin fixtures in your protocol in order to use them. Use :py:meth:`.load_trash_bin` to load a movable trash bin. This example loads a single bin in the default location:: default_trash = protocol.load_trash_bin(location = &quot;A3&quot;) .. versionadded:: 2.16 Call ``load_trash_bin()`` multiple times to add more than one bin. See :ref:`pipette-trash-containers` for more information on using pipettes with multiple trash bins. .. _configure-waste-chute: Waste Chute ----------- The waste chute accepts various materials from Flex pipettes or the Flex Gripper and uses gravity to transport them outside of the robot for disposal. Pipettes can dispose of liquid or drop tips into the chute. The gripper can drop tip racks and other labware into the chute. To use the waste chute, first use :py:meth:`.load_waste_chute` to load it in slot D3:: chute = protocol.load_waste_chute() .. versionadded:: 2.16 The ``load_waste_chute()`` method takes no arguments, since D3 is the only valid location for the chute. However, there are multiple variant configurations of the waste chute, depending on how other methods in your protocol use it. The waste chute is installed either on a standard deck plate adapter or on a deck plate adapter with a staging area. If any :py:meth:`~.ProtocolContext.load_labware` or :py:meth:`.move_labware` calls in your protocol reference slot D4, you have to use the deck plate adapter with staging area. The waste chute has a removable cover with a narrow opening which helps prevent aerosols and droplets from contaminating the working area. 1- and 8-channel pipettes can dispense liquid, blow out, or drop tips through the opening in the cover. Any of the following require you to remove the cover. - :py:meth:`.dispense`, :py:meth:`.blow_out`, or :py:meth:`.drop_tip` with a 96-channel pipette. - :py:meth:`.move_labware` with the chute as ``new_location`` and ``use_gripper=True``. If your protocol *does not* call any of these methods, your deck configuration should include the cover. In total, there are four possible deck configurations for the waste chute. - Waste chute only - Waste chute with cover - Waste chute with staging area slot - Waste chute with staging area slot and cover Deck Conflicts ============== A deck conflict check occurs when preparing to run a Python protocol on a Flex running robot system version 7.1.0 or higher. The Opentrons App and touchscreen will prevent you from starting the protocol run until any conflicts are resolved. You can resolve them one of two ways: - Physically move hardware around the deck, and update the deck configuration. - Alter your protocol to work with the current deck configuration, and resend the protocol to your Flex.</content></file><file name="index.rst" type="rst"><content>:og:description: The Opentrons Python Protocol API is a Python framework that makes it easy to write automated biology lab protocols that use Opentrons robots and hardware modules. ======= Welcome ======= .. toctree:: self tutorial versioning new_labware moving_labware new_modules deck_slots new_pipette new_atomic_commands new_complex_commands robot_position runtime_parameters new_advanced_running new_examples adapting_ot2_flex new_protocol_api The Opentrons Python Protocol API is a Python framework designed to make it easy to write automated biology lab protocols. Python protocols can control Opentrons Flex and OT-2 robots, their pipettes, and optional hardware modules. We&apos;ve designed the API to be accessible to anyone with basic Python and wet-lab skills. As a bench scientist, you should be able to code your protocols in a way that reads like a lab notebook. You can write a fully functional protocol just by listing the equipment you&apos;ll use (modules, labware, and pipettes) and the exact sequence of movements the robot should make. As a programmer, you can leverage the full power of Python for advanced automation in your protocols. Perform calculations, manage external data, use built-in and imported Python modules, and more to implement your custom lab workflow. Getting Started --------------- **New to Python protocols?** Check out the :ref:`tutorial` to learn about the different parts of a protocol file and build a working protocol from scratch. If you want to **dive right into code**, take a look at our :ref:`new-examples` and the comprehensive :ref:`protocol-api-reference`. When you&apos;re ready to **try out a protocol**, download the `Opentrons App &amp;lt;https://www.opentrons.com/ot-app&amp;gt;`__, import the protocol file, and run it on your robot. .. _overview-section-v2: How the API Works ----------------- The design goal of this API is to make code readable and easy to understand. A protocol, in its most basic form: 1. Provides some information about who made the protocol and what it is for. 2. Specifies which type of robot the protocol should run on. 3. Tells the robot where to find labware, pipettes, and (optionally) hardware modules. 4. Commands the robot to manipulate its attached hardware. For example, if we wanted to transfer liquid from well A1 to well B1 on a plate, our protocol would look like: .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api # metadata metadata = { &quot;protocolName&quot;: &quot;My Protocol&quot;, &quot;author&quot;: &quot;Name &amp;lt;opentrons@example.com&amp;gt;&quot;, &quot;description&quot;: &quot;Simple protocol to get started using the Flex&quot;, } # requirements requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} # protocol run function def run(protocol: protocol_api.ProtocolContext): # labware plate = protocol.load_labware( &quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot; ) tiprack = protocol.load_labware( &quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot; ) trash = protocol.load_trash_bin(location=&quot;A3&quot;) # pipettes left_pipette = protocol.load_instrument( &quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack] ) # commands left_pipette.pick_up_tip() left_pipette.aspirate(100, plate[&quot;A1&quot;]) left_pipette.dispense(100, plate[&quot;B2&quot;]) left_pipette.drop_tip() This example proceeds completely linearly. Following it line-by-line, you can see that it has the following effects: 1. Gives the name, contact information, and a brief description for the protocol. 2. Indicates the protocol should run on a Flex robot, using API version |apiLevel|. 3. Tells the robot that there is: a. A 96-well flat plate in slot D1. b. A rack of 300 µL tips in slot D2. c. A 1-channel 1000 µL pipette attached to the left mount, which should pick up tips from the aforementioned rack. 4. Tells the robot to act by: a. Picking up the first tip from the tip rack. b. Aspirating 100 µL of liquid from well A1 of the plate. c. Dispensing 100 µL of liquid into well B1 of the plate. d. Dropping the tip in the trash. .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api # metadata metadata = { &quot;protocolName&quot;: &quot;My Protocol&quot;, &quot;author&quot;: &quot;Name &amp;lt;opentrons@example.com&amp;gt;&quot;, &quot;description&quot;: &quot;Simple protocol to get started using the OT-2&quot;, } # requirements requirements = {&quot;robotType&quot;: &quot;OT-2&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} # protocol run function def run(protocol: protocol_api.ProtocolContext): # labware plate = protocol.load_labware( &quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;1&quot; ) tiprack = protocol.load_labware( &quot;opentrons_96_tiprack_300ul&quot;, location=&quot;2&quot; ) # pipettes left_pipette = protocol.load_instrument( &quot;p300_single&quot;, mount=&quot;left&quot;, tip_racks=[tiprack] ) # commands left_pipette.pick_up_tip() left_pipette.aspirate(100, plate[&quot;A1&quot;]) left_pipette.dispense(100, plate[&quot;B2&quot;]) left_pipette.drop_tip() This example proceeds completely linearly. Following it line-by-line, you can see that it has the following effects: 1. Gives the name, contact information, and a brief description for the protocol. 2. Indicates the protocol should run on an OT-2 robot, using API version |apiLevel|. 3. Tells the robot that there is: a. A 96-well flat plate in slot 1. b. A rack of 300 µL tips in slot 2. c. A single-channel 300 µL pipette attached to the left mount, which should pick up tips from the aforementioned rack. 4. Tells the robot to act by: a. Picking up the first tip from the tip rack. b. Aspirating 100 µL of liquid from well A1 of the plate. c. Dispensing 100 µL of liquid into well B1 of the plate. d. Dropping the tip in the trash. There is much more that Opentrons robots and the API can do! The :ref:`v2-atomic-commands`, :ref:`v2-complex-commands`, and :ref:`new_modules` pages cover many of these functions. More Resources -------------- Opentrons App +++++++++++++ The `Opentrons App &amp;lt;https://opentrons.com/ot-app/&amp;gt;`__ is the easiest way to run your Python protocols. The app runs on the latest versions of macOS, Windows, and Ubuntu. Support +++++++ Questions about setting up your robot, using Opentrons software, or troubleshooting? Check out our `support articles &amp;lt;https://support.opentrons.com/s/&amp;gt;`_ or `contact Opentrons Support directly &amp;lt;mailto:support@opentrons.com&amp;gt;`_. Custom Protocol Service +++++++++++++++++++++++ Don&apos;t have the time or resources to write your own protocols? Our `custom protocol development service &amp;lt;https://opentrons.com/instrument-services/&amp;gt;`_ can get you set up in two weeks. Contributing ++++++++++++ Opentrons software, including the Python API and this documentation, is open source. If you have an improvement or an interesting idea, you can create an issue on GitHub by following our `guidelines`__. __ https://github.com/Opentrons/opentrons/blob/edge/CONTRIBUTING.md#opening-issues That guide also includes more information on how to `directly contribute code`__. __ https://github.com/Opentrons/opentrons/blob/edge/CONTRIBUTING.md</content></file><file name="moving_labware.rst" type="rst"><content>:og:description: How to move labware, with the Flex Gripper or manually, in a Python protocol. .. _moving-labware: ************** Moving Labware ************** You can move an entire labware (and all of its contents) from one deck slot to another at any point during your protocol. On Flex, you can either use the gripper or move the labware manually. On OT-2, you can can only move labware manually, since it doesn&apos;t have a gripper instrument. Basic Movement ============== Use the :py:meth:`.ProtocolContext.move_labware` method to initiate a move, regardless of whether it uses the gripper. .. code-block:: python :substitutions: def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;D1&quot;) protocol.move_labware(labware=plate, new_location=&quot;D2&quot;) .. versionadded:: 2.15 The required arguments of ``move_labware()`` are the ``labware`` you want to move and its ``new_location``. You don&apos;t need to specify where the move begins, since that information is already stored in the :py:class:`~opentrons.protocol_api.labware.Labware` object — ``plate`` in this example. The destination of the move can be any empty deck slot, or a module that&apos;s ready to have labware added to it (see :ref:`movement-modules` below). Movement to an occupied location, including the labware&apos;s current location, will raise an error. When the move step is complete, the API updates the labware&apos;s location, so you can move the plate multiple times:: protocol.move_labware(labware=plate, new_location=&quot;D2&quot;) protocol.move_labware(labware=plate, new_location=&quot;D3&quot;) For the first move, the API knows to find the plate in its initial load location, slot D1. For the second move, the API knows to find the plate in D2. .. _automatic-manual-moves: Automatic vs Manual Moves ========================= There are two ways to move labware: - Automatically, with the Opentrons Flex Gripper. - Manually, by pausing the protocol until a user confirms that they&apos;ve moved the labware. The ``use_gripper`` parameter of :py:meth:`~.ProtocolContext.move_labware` determines whether a movement is automatic or manual. Set its value to ``True`` for an automatic move. The default value is ``False``, so if you don&apos;t specify a value, the protocol will pause for a manual move. .. code-block:: python def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;D1&quot;) # have the gripper move the plate from D1 to D2 protocol.move_labware(labware=plate, new_location=&quot;D2&quot;, use_gripper=True) # pause to move the plate manually from D2 to D3 protocol.move_labware(labware=plate, new_location=&quot;D3&quot;, use_gripper=False) # pause to move the plate manually from D3 to C1 protocol.move_labware(labware=plate, new_location=&quot;C1&quot;) .. versionadded:: 2.15 .. note:: Don&apos;t add a ``pause()`` command before ``move_labware()``. When ``use_gripper`` is unset or ``False``, the protocol pauses when it reaches the movement step. The Opentrons App or the touchscreen on Flex shows an animation of the labware movement that you need to perform manually. The protocol only resumes when you press **Confirm and resume**. The above example is a complete and valid ``run()`` function. You don&apos;t have to load the gripper as an instrument, and there is no ``InstrumentContext`` for the gripper. All you have to do to specify that a protocol requires the gripper is to include at least one ``move_labware()`` command with ``use_gripper=True``. If you attempt to use the gripper to move labware in an OT-2 protocol, the API will raise an error. Supported Labware ================= You can manually move any standard or custom labware. Using the gripper to move the following labware is fully supported by Opentrons: .. list-table:: :header-rows: 1 * - Labware Type - API Load Names * - Full-skirt PCR plates - * ``armadillo_96_wellplate_200ul_pcr_full_skirt`` * ``opentrons_96_wellplate_200ul_pcr_full_skirt`` * - NEST well plates - * ``nest_96_wellplate_200ul_flat`` * ``nest_96_wellplate_2ml_deep`` * - Opentrons Flex 96 Tip Racks - * ``opentrons_flex_96_tiprack_50ul`` * ``opentrons_flex_96_tiprack_200ul`` * ``opentrons_flex_96_tiprack_1000ul`` * ``opentrons_flex_96_filtertiprack_50ul`` * ``opentrons_flex_96_filtertiprack_200ul`` * ``opentrons_flex_96_filtertiprack_1000ul`` The gripper may work with other ANSI/SLAS standard labware, but this is not recommended. .. note:: The labware definitions listed above include information about the position and force that the gripper uses to pick up the labware. The gripper uses default values for labware definitions that don&apos;t include position and force information. The Python Protocol API won&apos;t raise a warning or error if you try to grip and move other types of labware. .. _movement-modules: Movement with Modules ===================== Moving labware on and off of modules lets you precisely control when the labware is in contact with the hot, cold, or magnetic surfaces of the modules — all within a single protocol. When moving labware anywhere that isn&apos;t an empty deck slot, consider what physical object the labware will rest on following the move. That object should be the value of ``new_location``, and you need to make sure it&apos;s already loaded before the move. For example, if you want to move a 96-well flat plate onto a Heater-Shaker module, you actually want to have it rest on top of the Heater-Shaker&apos;s 96 Flat Bottom Adapter. Pass the adapter, not the module or the slot, as the value of ``new_location``:: def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;D1&quot;) hs_mod = protocol.load_module(&quot;heaterShakerModuleV1&quot;, &quot;C1&quot;) hs_adapter = hs_mod.load_adapter(&quot;opentrons_96_flat_bottom_adapter&quot;) hs_mod.open_labware_latch() protocol.move_labware( labware=plate, new_location=hs_adapter, use_gripper=True ) .. versionadded:: 2.15 If you try to move the plate to slot C1 or the Heater-Shaker module, the API will raise an error, because C1 is occupied by the Heater-Shaker, and the Heater-Shaker is occupied by the adapter. Only the adapter, as the topmost item in that stack, is unoccupied. Also note the ``hs_mod.open_labware_latch()`` command in the above example. To move labware onto or off of a module, you have to make sure that it&apos;s physically accessible: - For the Heater-Shaker, use :py:meth:`~.HeaterShakerContext.open_labware_latch`. - For the Thermocycler, use :py:meth:`~.ThermocyclerContext.open_lid`. If the labware is inaccessible, the API will raise an error. Movement into the Waste Chute ============================= Move used tip racks and well plates to the waste chute to dispose of them. This requires you to first :ref:`configure the waste chute &amp;lt;configure-waste-chute&amp;gt;` in your protocol. Then use the loaded :py:class:`.WasteChute` object as the value of ``new_location``:: chute = protocol.load_waste_chute() protocol.move_labware( labware=plate, new_location=chute, use_gripper=True ) .. versionadded:: 2.16 This will pick up ``plate`` from its current location and drop it into the chute. Always specify ``use_gripper=True`` when moving labware into the waste chute. The chute is not designed for manual movement. You can still manually move labware to other locations, including off-deck, with the chute installed. .. _off-deck-location: The Off-Deck Location ===================== In addition to moving labware around the deck, :py:meth:`~.ProtocolContext.move_labware` can also prompt you to move labware off of or onto the deck. Remove labware from the deck to perform tasks like retrieving samples or discarding a spent tip rack. The destination location for such moves is the special constant :py:obj:`~opentrons.protocol_api.OFF_DECK`:: protocol.move_labware(labware=plate, new_location=protocol_api.OFF_DECK) .. versionadded:: 2.15 Moving labware off-deck always requires user intervention, because the gripper can&apos;t reach outside of the robot. Omit the ``use_gripper`` parameter or explicitly set it to ``False``. If you try to move labware off-deck with ``use_gripper=True``, the API will raise an error. You can also load labware off-deck, in preparation for a ``move_labware()`` command that brings it *onto* the deck. For example, you could assign two tip racks to a pipette — one on-deck, and one off-deck — and then swap out the first rack for the second one: .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;, &quot;protocolName&quot;: &quot;Tip rack replacement&quot;} requirements = {&quot;robotType&quot;: &quot;OT-2&quot;} def run(protocol: protocol_api.ProtocolContext): tips1 = protocol.load_labware(&quot;opentrons_96_tiprack_1000ul&quot;, 1) # load another tip rack but don&apos;t put it in a slot yet tips2 = protocol.load_labware( &quot;opentrons_96_tiprack_1000ul&quot;, protocol_api.OFF_DECK ) pipette = protocol.load_instrument( &quot;p1000_single_gen2&quot;, &quot;left&quot;, tip_racks=[tips1, tips2] ) # use all the on-deck tips for i in range(96): pipette.pick_up_tip() pipette.drop_tip() # pause to move the spent tip rack off-deck protocol.move_labware(labware=tips1, new_location=protocol_api.OFF_DECK) # pause to move the fresh tip rack on-deck protocol.move_labware(labware=tips2, new_location=1) pipette.pick_up_tip() Using the off-deck location to remove or replace labware lets you continue your workflow in a single protocol, rather than needing to end a protocol, reset the deck, and start a new protocol run.</content></file><file name="new_advanced_running.rst" type="rst"><content>:og:description: How to control a robot outside of the Opentrons App, using Jupyter Notebook or the command line. .. _advanced-control: Advanced Control ================ As its name implies, the Python Protocol API is primarily designed for creating protocols that you upload via the Opentrons App and execute on the robot as a unit. But sometimes it&apos;s more convenient to control the robot outside of the app. For example, you might want to have variables in your code that change based on user input or the contents of a CSV file. Or you might want to only execute part of your protocol at a time, especially when developing or debugging a new protocol. The Python API offers two ways of issuing commands to the robot outside of the app: through Jupyter Notebook or on the command line with ``opentrons_execute``. Jupyter Notebook ---------------- The Flex and OT-2 run `Jupyter Notebook &amp;lt;https://jupyter.org&amp;gt;`_ servers on port 48888, which you can connect to with your web browser. This is a convenient environment for writing and debugging protocols, since you can define different parts of your protocol in different notebook cells and run a single cell at a time. Access your robot’s Jupyter Notebook by either: - Going to the **Advanced** tab of Robot Settings and clicking **Launch Jupyter Notebook**. - Going directly to ``http://&amp;lt;robot-ip&amp;gt;:48888`` in your web browser (if you know your robot&apos;s IP address). Once you&apos;ve launched Jupyter Notebook, you can create a notebook file or edit an existing one. These notebook files are stored on the the robot. If you want to save code from a notebook to your computer, go to **File &amp;gt; Download As** in the notebook interface. Protocol Structure ^^^^^^^^^^^^^^^^^^ Jupyter Notebook is structured around `cells`: discrete chunks of code that can be run individually. This is nearly the opposite of Opentrons protocols, which bundle all commands into a single ``run`` function. Therefore, to take full advantage of Jupyter Notebook, you have to restructure your protocol. Rather than writing a ``run`` function and embedding commands within it, start your notebook by importing ``opentrons.execute`` and calling :py:meth:`opentrons.execute.get_protocol_api`. This function also replaces the ``metadata`` block of a standalone protocol by taking the minimum :ref:`API version &amp;lt;v2-versioning&amp;gt;` as its argument. Then you can call :py:class:`~opentrons.protocol_api.ProtocolContext` methods in subsequent lines or cells: .. code-block:: python :substitutions: import opentrons.execute protocol = opentrons.execute.get_protocol_api(&quot;|apiLevel|&quot;) protocol.home() The first command you execute should always be :py:meth:`~opentrons.protocol_api.ProtocolContext.home`. If you try to execute other commands first, you will get a ``MustHomeError``. (When running protocols through the Opentrons App, the robot homes automatically.) You should use the same :py:class:`.ProtocolContext` throughout your notebook, unless you need to start over from the beginning of your protocol logic. In that case, call :py:meth:`~opentrons.execute.get_protocol_api` again to get a new :py:class:`.ProtocolContext`. Running a Previously Written Protocol ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ You can also use Jupyter to run a protocol that you have already written. To do so, first copy the entire text of the protocol into a cell and run that cell: .. code-block:: python import opentrons.execute from opentrons import protocol_api def run(protocol: protocol_api.ProtocolContext): # the contents of your previously written protocol go here Since a typical protocol only `defines` the ``run`` function but doesn&apos;t `call` it, this won&apos;t immediately cause the robot to move. To begin the run, instantiate a :py:class:`.ProtocolContext` and pass it to the ``run`` function you just defined: .. code-block:: python :substitutions: protocol = opentrons.execute.get_protocol_api(&quot;|apiLevel|&quot;) run(protocol) # your protocol will now run .. _using_lpc: Setting Labware Offsets ----------------------- All positions relative to labware are adjusted automatically based on labware offset data. When you&apos;re running your code in Jupyter Notebook or with ``opentrons_execute``, you need to set your own offsets because you can&apos;t perform run setup and Labware Position Check in the Opentrons App or on the Flex touchscreen. Creating a Dummy Protocol ^^^^^^^^^^^^^^^^^^^^^^^^^ For advanced control applications, do the following to calculate and apply labware offsets: 1. Create a &quot;dummy&quot; protocol that loads your labware and has each used pipette pick up a tip from a tip rack. 2. Import the dummy protocol to the Opentrons App. 3. Run Labware Position Check from the app or touchscreen. 4. Add the offsets to your code with :py:meth:`.set_offset`. Creating the dummy protocol requires you to: 1. Use the ``metadata`` or ``requirements`` dictionary to specify the API version. (See :ref:`v2-versioning` for details.) Use the same API version as you did in :py:meth:`opentrons.execute.get_protocol_api`. 2. Define a ``run()`` function. 3. Load all of your labware in their initial locations. 4. Load your smallest capacity pipette and specify its ``tip_racks``. 5. Call ``pick_up_tip()``. Labware Position Check can&apos;t run if you don&apos;t pick up a tip. For example, the following dummy protocol will use a P300 Single-Channel GEN2 pipette to enable Labware Position Check for an OT-2 tip rack, NEST reservoir, and NEST flat well plate. .. code-block:: python metadata = {&quot;apiLevel&quot;: &quot;2.13&quot;} def run(protocol): tiprack = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, 1) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, 2) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, 3) p300 = protocol.load_instrument(&quot;p300_single_gen2&quot;, &quot;left&quot;, tip_racks=[tiprack]) p300.pick_up_tip() p300.return_tip() After importing this protocol to the Opentrons App, run Labware Position Check to get the x, y, and z offsets for the tip rack and labware. When complete, you can click **Get Labware Offset Data** to view automatically generated code that uses :py:meth:`.set_offset` to apply the offsets to each piece of labware. .. code-block:: python labware_1 = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, location=&quot;1&quot;) labware_1.set_offset(x=0.00, y=0.00, z=0.00) labware_2 = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, location=&quot;2&quot;) labware_2.set_offset(x=0.10, y=0.20, z=0.30) labware_3 = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, location=&quot;3&quot;) labware_3.set_offset(x=0.10, y=0.20, z=0.30) This automatically generated code uses generic names for the loaded labware. If you want to match the labware names already in your protocol, change the labware names to match your original code: .. code-block:: python reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, &quot;2&quot;) reservoir.set_offset(x=0.10, y=0.20, z=0.30) .. versionadded:: 2.12 Once you&apos;ve executed this code in Jupyter Notebook, all subsequent positional calculations for this reservoir in slot 2 will be adjusted 0.1 mm to the right, 0.2 mm to the back, and 0.3 mm up. Keep in mind that ``set_offset()`` commands will override any labware offsets set by running Labware Position Check in the Opentrons App. And you should follow the behavior of Labware Position Check, i.e., *do not* reuse offset measurements unless they apply to the *same labware type* in the *same deck slot* on the *same robot*. .. warning:: Improperly reusing offset data may cause your robot to move to an unexpected position or crash against labware, which can lead to incorrect protocol execution or damage your equipment. When in doubt: run Labware Position Check again and update your code! .. _labware-offset-behavior: Labware Offset Behavior ^^^^^^^^^^^^^^^^^^^^^^^ How the API applies labware offsets varies depending on the API level of your protocol. This section describes the latest behavior. For details on how offsets work in earlier API versions, see the API reference entry for :py:meth:`.set_offset`. In the latest API version, offsets apply to labware type–location combinations. For example, if you use ``set_offset()`` on a tip rack, use all the tips, and replace the rack with a fresh one of the same type in the same location, the offsets will apply to the fresh tip rack:: tiprack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D3&quot; ) tiprack2 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=protocol_api.OFF_DECK, ) tiprack.set_offset(x=0.1, y=0.1, z=0.1) protocol.move_labware( labware=tiprack, new_location=protocol_api.OFF_DECK ) # tiprack has no offset while off-deck protocol.move_labware( labware=tiprack2, new_location=&quot;D3&quot; ) # tiprack2 now has offset 0.1, 0.1, 0.1 Because offsets apply to combinations of labware type and location, if you want an offset to apply to a piece of labware as it moves around the deck, call ``set_offset()`` again after each movement:: plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D2&quot; ) plate.set_offset( x=-0.1, y=-0.2, z=-0.3 ) # plate now has offset -0.1, -0.2, -0.3 protocol.move_labware( labware=plate, new_location=&quot;D3&quot; ) # plate now has offset 0, 0, 0 plate.set_offset( x=-0.1, y=-0.2, z=-0.3 ) # plate again has offset -0.1, -0.2, -0.3 Using Custom Labware -------------------- If you have custom labware definitions you want to use with Jupyter, make a new directory called ``labware`` in Jupyter and put the definitions there. These definitions will be available when you call :py:meth:`~opentrons.protocol_api.ProtocolContext.load_labware`. Using Modules ------------- If your protocol uses :ref:`modules &amp;lt;new_modules&amp;gt;`, you need to take additional steps to make sure that Jupyter Notebook doesn&apos;t send commands that conflict with the robot server. Sending commands to modules while the robot server is running will likely cause errors, and the module commands may not execute as expected. To disable the robot server, open a Jupyter terminal session by going to **New &amp;gt; Terminal** and run ``systemctl stop opentrons-robot-server``. Then you can run code from cells in your notebook as usual. When you are done using Jupyter Notebook, you should restart the robot server with ``systemctl start opentrons-robot-server``. .. note:: While the robot server is stopped, the robot will display as unavailable in the Opentrons App. If you need to control the robot or its attached modules through the app, you need to restart the robot server and wait for the robot to appear as available in the app. Command Line ------------ .. TODO update with separate links to OT-2 and Flex setup, when new Flex process is in manual or on help site The robot&apos;s command line is accessible either by going to **New &amp;gt; Terminal** in Jupyter or `via SSH &amp;lt;https://support.opentrons.com/s/article/Connecting-to-your-OT-2-with-SSH&amp;gt;`_. To execute a protocol from the robot&apos;s command line, copy the protocol file to the robot with ``scp`` and then run the protocol with ``opentrons_execute``: .. prompt:: bash opentrons_execute /data/my_protocol.py By default, ``opentrons_execute`` will print out the same run log shown in the Opentrons App, as the protocol executes. It also prints out internal logs at the level ``warning`` or above. Both of these behaviors can be changed. Run ``opentrons_execute --help`` for more information.</content></file><file name="new_atomic_commands.rst" type="rst"><content>:og:description: Basic commands that Opentrons robots can perform with pipette tips, for liquid handling, and other utility features. .. _v2-atomic-commands: *********************** Building Block Commands *********************** .. toctree:: basic_commands/pipette_tips basic_commands/liquids basic_commands/utilities Building block commands execute some of the most basic actions that your robot can complete. But basic doesn’t mean these commands lack capabilities. They perform important tasks in your protocols. They&apos;re also foundational to the :ref:`complex commands &amp;lt;v2-complex-commands&amp;gt;` that help you combine multiple actions into fewer lines of code. Pages in this section of the documentation cover: - :ref:`pipette-tips`: Get started with commands for picking up pipette tips, dropping tips, returning tips, and working with used tips. - :ref:`liquid-control`: Learn about aspirating and dispensing liquids, blow out and touch tip procedures, mixing, and creating air gaps. - :ref:`new-utility-commands`: Control various robot functions such as pausing or delaying a protocol, checking the robot’s door, turning robot lights on/off, and more.</content></file><file name="new_complex_commands.rst" type="rst"><content>:og:description: Complex liquid-handling commands for Opentrons robots can handle large groups of wells and repetitive actions. .. _v2-complex-commands: **************** Complex Commands **************** .. toctree:: complex_commands/sources_destinations complex_commands/order_operations complex_commands/parameters Complex liquid handling commands combine multiple :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` into a single method call. These commands make it easier to handle larger groups of wells and repeat actions without having to write your own control flow code. They integrate tip-handling behavior and can pick up, use, and drop multiple tips depending on how you want to handle your liquids. They can optionally perform other actions, like adding air gaps, knocking droplets off the tip, mixing, and blowing out excess liquid from the tip. There are three complex liquid handling commands, each optimized for a different liquid handling scenario: - :py:meth:`.InstrumentContext.transfer` - :py:meth:`.InstrumentContext.distribute` - :py:meth:`.InstrumentContext.consolidate` Pages in this section of the documentation cover: - :ref:`complex-source-dest`: Which wells complex commands aspirate from and dispense to. - :ref:`complex-command-order`: The order of basic commands that are part of a complex commmand. - :ref:`complex_params`: Additional keyword arguments that affect complex command behavior. Code samples throughout these pages assume that you&apos;ve loaded the pipettes and labware from the :ref:`basic protocol template &amp;lt;protocol-template&amp;gt;`.</content></file><file name="new_examples.rst" type="rst"><content>:og:description: Useful code snippets for working with Opentrons robots. .. _new-examples: ***************** Protocol Examples ***************** This page provides simple, ready-made protocols for Flex and OT-2. Feel free to copy and modify these examples to create unique protocols that help automate your laboratory workflows. Also, experimenting with these protocols is another way to build upon the skills you&apos;ve learned from working through the :ref:`tutorial &amp;lt;tutorial&amp;gt;`. Try adding different hardware, labware, and commands to a sample protocol and test its validity after importing it into the Opentrons App. Using These Protocols ===================== These sample protocols are designed for anyone using an Opentrons Flex or OT-2 liquid handling robot. For our users with little to no Python experience, we’ve taken some liberties with the syntax and structure of the code to make it easier to understand. For example, we’ve formatted the samples with line breaks to show method arguments clearly and to avoid horizontal scrolling. Additionally, the methods use `named arguments &amp;lt;https://en.wikipedia.org/wiki/Named_parameter&amp;gt;`_ instead of positional arguments. For example:: # This code uses named arguments tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) # This code uses positional arguments tiprack_1 = protocol.load_labware(&quot;opentrons_flex_96_tiprack_200ul&quot;, &quot;D2&quot;) Both examples instantiate the variable ``tiprack_1`` with a Flex tip rack, but the former is more explicit. It shows the parameter name and its value together (e.g. ``location=&quot;D2&quot;``), which may be helpful when you&apos;re unsure about what&apos;s going on in a protocol code sample. Python developers with more experience should feel free to ignore the code styling used here and work with these examples as you like. Instruments and Labware ======================= The sample protocols all use the following pipettes: * Flex 1-Channel Pipette (5–1000 µL). The API load name for this pipette is ``flex_1channel_1000``. * P300 Single-Channel GEN2 pipette for the OT-2. The API load name for this pipette is ``p300_single_gen2``. They also use the labware listed below: .. list-table:: :header-rows: 1 * - Labware type - Labware name - API load name * - Reservoir - USA Scientific 12-Well Reservoir 22 mL - ``usascientific_12_reservoir_22ml`` * - Well plate - Corning 96-Well Plate 360 µL Flat - ``corning_96_wellplate_360ul_flat`` * - Flex tip rack - Opentrons Flex 96 Tip Rack 200 µL - ``opentrons_flex_96_tiprack_200ul`` * - OT-2 tip rack - Opentrons 96 Tip Rack 300 µL - ``opentrons_96_tiprack_300ul`` .. _protocol-template: Protocol Template ================= This code only loads the instruments and labware listed above, and performs no other actions. Many code snippets from elsewhere in the documentation will run without modification when added at the bottom of this template. You can also use it to start writing and testing your own code. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # load tip rack in deck slot D3 tiprack = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D3&quot; ) # attach pipette to left mount pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack] ) # load well plate in deck slot D2 plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D2&quot; ) # load reservoir in deck slot D1 reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=&quot;D1&quot; ) # load trash bin in deck slot A3 trash = protocol.load_trash_bin(location=&quot;A3&quot;) # Put protocol commands here .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): # load tip rack in deck slot 3 tiprack = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=3 ) # attach pipette to left mount pipette = protocol.load_instrument( instrument_name=&quot;p300_single_gen2&quot;, mount=&quot;left&quot;, tip_racks=[tiprack] ) # load well plate in deck slot 2 plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=2 ) # load reservoir in deck slot 1 reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=1 ) # Put protocol commands here Transferring Liquids ==================== These protocols demonstrate how to move 100 µL of liquid from one well to another. Basic Method ------------ This protocol uses some :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` to tell the robot, explicitly, where to go to aspirate and dispense liquid. These commands include the :py:meth:`~.InstrumentContext.pick_up_tip`, :py:meth:`~.InstrumentContext.aspirate`, and :py:meth:`~.InstrumentContext.dispense` methods. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;:&quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) pipette.pick_up_tip() pipette.aspirate(100, plate[&quot;A1&quot;]) pipette.dispense(100, plate[&quot;B1&quot;]) pipette.drop_tip() .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=1) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=2) p300 = protocol.load_instrument( instrument_name=&quot;p300_single&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) p300.pick_up_tip() p300.aspirate(100, plate[&quot;A1&quot;]) p300.dispense(100, plate[&quot;B1&quot;]) p300.drop_tip() Advanced Method --------------- This protocol accomplishes the same thing as the previous example, but does it a little more efficiently. Notice how it uses the :py:meth:`.InstrumentContext.transfer` method to move liquid between well plates. The source and destination well arguments (e.g., ``plate[&quot;A1&quot;], plate[&quot;B1&quot;]``) are part of ``transfer()`` method parameters. You don&apos;t need separate calls to ``aspirate`` or ``dispense`` here. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) # transfer 100 µL from well A1 to well B1 pipette.transfer(100, plate[&quot;A1&quot;], plate[&quot;B1&quot;]) .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=1) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=2) p300 = protocol.load_instrument( instrument_name=&quot;p300_single&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) # transfer 100 µL from well A1 to well B1 p300.transfer(100, plate[&quot;A1&quot;], plate[&quot;B1&quot;]) Loops ===== In Python, a loop is an instruction that keeps repeating an action until a specific condition is met. When used in a protocol, loops automate repetitive steps such as aspirating and dispensing liquids from a reservoir to a a range of wells, or all the wells, in a well plate. For example, this code sample loops through the numbers 0 to 7, and uses the loop&apos;s current value to transfer liquid from all the wells in a reservoir to all the wells in a 96-well plate. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;:&quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=&quot;D3&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) # distribute 20 µL from reservoir:A1 -&amp;gt; plate:row:1 # distribute 20 µL from reservoir:A2 -&amp;gt; plate:row:2 # etc... # range() starts at 0 and stops before 8, creating a range of 0-7 for i in range(8): pipette.distribute(20, reservoir.wells()[i], plate.rows()[i]) .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=1) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=2) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=4) p300 = protocol.load_instrument( instrument_name=&quot;p300_single&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) # distribute 20 µL from reservoir:A1 -&amp;gt; plate:row:1 # distribute 20 µL from reservoir:A2 -&amp;gt; plate:row:2 # etc... # range() starts at 0 and stops before 8, creating a range of 0-7 for i in range(8): p300.distribute(20, reservoir.wells()[i], plate.rows()[i]) Notice here how Python&apos;s :py:class:`range` class (e.g., ``range(8)``) determines how many times the code loops. Also, in Python, a range of numbers is *exclusive* of the end value and counting starts at 0, not 1. For the Corning 96-well plate used here, this means well A1=0, B1=1, C1=2, and so on to the last well in the row, which is H1=7. Multiple Air Gaps ================= Opentrons electronic pipettes can do some things that a human cannot do with a pipette, like accurately alternate between liquid and air aspirations that create gaps within the same tip. The protocol shown below shows you how to aspirate from the first five wells in the reservoir and create an air gap between each sample. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;:&quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_1000ul&quot;, location=&quot;D2&quot;) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=&quot;D3&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) pipette.pick_up_tip() # aspirate from the first 5 wells for well in reservoir.wells()[:5]: pipette.aspirate(volume=35, location=well) pipette.air_gap(10) pipette.dispense(225, plate[&quot;A1&quot;]) pipette.return_tip() .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=1) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=2) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=3) p300 = protocol.load_instrument( instrument_name=&quot;p300_single&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1]) p300.pick_up_tip() # aspirate from the first 5 wells for well in reservoir.wells()[:5]: p300.aspirate(volume=35, location=well) p300.air_gap(10) p300.dispense(225, plate[&quot;A1&quot;]) p300.return_tip() Notice here how Python&apos;s :py:class:`slice` functionality (in the code sample as ``[:5]``) lets us select the first five wells of the well plate only. Also, in Python, a range of numbers is *exclusive* of the end value and counting starts at 0, not 1. For the USA Scientific 12-well reservoir used here, this means well A1=0, A2=1, A3=2, and so on to the last well used, which is A5=4. See also, the :ref:`tutorial-commands` section of the Tutorial. Dilution ======== This protocol dispenses diluent to all wells of a Corning 96-well plate. Next, it dilutes 8 samples from the reservoir across all 8 columns of the plate. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) tiprack_2 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D3&quot;) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=&quot;C1&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1, tiprack_2]) # Dispense diluent pipette.distribute(50, reservoir[&quot;A12&quot;], plate.wells()) # loop through each row for i in range(8): # save the source well and destination column to variables source = reservoir.wells()[i] row = plate.rows()[i] # transfer 30 µL of source to first well in column pipette.transfer(30, source, row[0], mix_after=(3, 25)) # dilute the sample down the column pipette.transfer( 30, row[:11], row[1:], mix_after=(3, 25)) .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=1) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=2) tiprack_2 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=3) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=4) p300 = protocol.load_instrument( instrument_name=&quot;p300_single&quot;, mount=&quot;left&quot;, tip_racks=[tiprack_1, tiprack_2]) # Dispense diluent p300.distribute(50, reservoir[&quot;A12&quot;], plate.wells()) # loop through each row for i in range(8): # save the source well and destination column to variables source = reservoir.wells()[i] row = plate.rows()[i] # transfer 30 µL of source to first well in column p300.transfer(30, source, row[0], mix_after=(3, 25)) # dilute the sample down the column p300.transfer( 30, row[:11], row[1:], mix_after=(3, 25)) Notice here how the code sample loops through the rows and uses slicing to distribute the diluent. For information about these features, see the Loops and Air Gaps examples above. See also, the :ref:`tutorial-commands` section of the Tutorial. Plate Mapping ============= This protocol dispenses different volumes of liquids to a well plate and automatically refills the pipette when empty. .. tabs:: .. tab:: Flex .. code-block:: python :substitutions: from opentrons import protocol_api requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D2&quot;) tiprack_2 = protocol.load_labware( load_name=&quot;opentrons_flex_96_tiprack_200ul&quot;, location=&quot;D3&quot;) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=&quot;C1&quot;) trash = protocol.load_trash_bin(&quot;A3&quot;) pipette = protocol.load_instrument( instrument_name=&quot;flex_1channel_1000&quot;, mount=&quot;right&quot;, tip_racks=[tiprack_1, tiprack_2]) # Volume amounts are for demonstration purposes only water_volumes = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96 ] pipette.distribute(water_volumes, reservoir[&quot;A12&quot;], plate.wells()) .. tab:: OT-2 .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;} def run(protocol: protocol_api.ProtocolContext): plate = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=1) tiprack_1 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=2) tiprack_2 = protocol.load_labware( load_name=&quot;opentrons_96_tiprack_300ul&quot;, location=3) reservoir = protocol.load_labware( load_name=&quot;usascientific_12_reservoir_22ml&quot;, location=4) p300 = protocol.load_instrument( instrument_name=&quot;p300_single&quot;, mount=&quot;right&quot;, tip_racks=[tiprack_1, tiprack_2]) # Volume amounts are for demonstration purposes only water_volumes = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96 ] p300.distribute(water_volumes, reservoir[&quot;A12&quot;], plate.wells())</content></file><file name="new_labware.rst" type="rst"><content>:og:description: How to load and work with Opentrons-verified and custom labware in a Python protocol. .. _new-labware: ####### Labware ####### Labware are the durable or consumable items that you work with, reuse, or discard while running a protocol on a Flex or OT-2. Items such as pipette tips, well plates, tubes, and reservoirs are all examples of labware. This section provides a brief overview of default labware, custom labware, and how to use basic labware API methods when creating a protocol for your robot. .. note:: Code snippets use coordinate deck slot locations (e.g. ``&quot;D1&quot;``, ``&quot;D2&quot;``), like those found on Flex. If you have an OT-2 and are using API version 2.14 or earlier, replace the coordinate with its numeric OT-2 equivalent. For example, slot D1 on Flex corresponds to slot 1 on an OT-2. See :ref:`deck-slots` for more information. ************* Labware Types ************* Default Labware =============== Default labware is everything listed in the `Opentrons Labware Library &amp;lt;https://labware.opentrons.com/&amp;gt;`_. When used in a protocol, your Flex or OT-2 knows how to work with default labware. However, you must first inform the API about the labware you will place on the robot’s deck. Search the library when you’re looking for the API load names of the labware you want to use. You can copy the load names from the library and pass them to the :py:meth:`~.ProtocolContext.load_labware` method in your protocol. .. _v2-custom-labware: Custom Labware ============== Custom labware is labware that is not listed the Labware Library. If your protocol needs something that&apos;s not in the library, you can create it with the `Opentrons Labware Creator &amp;lt;https://labware.opentrons.com/create/&amp;gt;`_. However, before using the Labware Creator, you should take a moment to review the support article `Creating Custom Labware Definitions &amp;lt;https://support.opentrons.com/s/article/Creating-Custom-Labware-Definitions&amp;gt;`_. After you&apos;ve created your labware, save it as a ``.json`` file and add it to the Opentrons App. See `Using Labware in Your Protocols &amp;lt;https://support.opentrons.com/s/article/Using-labware-in-your-protocols&amp;gt;`_ for instructions. If other people need to use your custom labware definition, they must also add it to their Opentrons App. .. _loading-labware: *************** Loading Labware *************** Throughout this section, we&apos;ll use the labware listed in the following table. .. list-table:: :widths: 20 40 45 :header-rows: 1 * - Labware type - Labware name - API load name * - Well plate - `Corning 96 Well Plate 360 µL Flat &amp;lt;https://labware.opentrons.com/corning_96_wellplate_360ul_flat/&amp;gt;`_ - ``corning_96_wellplate_360ul_flat`` * - Flex tip rack - `Opentrons Flex 96 Tips 200 µL &amp;lt;https://shop.opentrons.com/opentrons-flex-tips-200-l/&amp;gt;`_ - ``opentrons_flex_96_tiprack_200ul`` * - OT-2 tip rack - `Opentrons 96 Tip Rack 300 µL &amp;lt;https://labware.opentrons.com/opentrons_96_tiprack_300ul&amp;gt;`_ - ``opentrons_96_tiprack_300ul`` Similar to the code sample in :ref:`overview-section-v2`, here&apos;s how you use the :py:meth:`.ProtocolContext.load_labware` method to load labware on either Flex or OT-2. .. code-block:: python #Flex tiprack = protocol.load_labware(&quot;opentrons_flex_96_tiprack_200ul&quot;, &quot;D1&quot;) plate = protocol.load_labware(&quot;corning_96_wellplate_360ul_flat&quot;, &quot;D2&quot;) .. code-block:: python #OT-2 tiprack = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, &quot;1&quot;) plate = protocol.load_labware(&quot;corning_96_wellplate_360ul_flat&quot;, &quot;2&quot;) .. versionadded:: 2.0 When the ``load_labware`` method loads labware into your protocol, it returns a :py:class:`~opentrons.protocol_api.labware.Labware` object. .. _labware-label: .. Tip:: The ``load_labware`` method includes an optional ``label`` argument. You can use it to identify labware with a descriptive name. If used, the label value is displayed in the Opentrons App. For example:: tiprack = protocol.load_labware( load_name=&quot;corning_96_wellplate_360ul_flat&quot;, location=&quot;D1&quot;, label=&quot;any-name-you-want&quot;) .. _labware-on-adapters: Loading Labware on Adapters =========================== The previous section demonstrates loading labware directly into a deck slot. But you can also load labware on top of an adapter that either fits on a module or goes directly on the deck. The ability to combine labware with adapters adds functionality and flexibility to your robot and protocols. You can either load the adapter first and the labware second, or load both the adapter and labware all at once. Loading Separately ------------------ The ``load_adapter()`` method is available on ``ProtocolContext`` and module contexts. It behaves similarly to ``load_labware()``, requiring the load name and location for the desired adapter. Load a module, adapter, and labware with separate calls to specify each layer of the physical stack of components individually:: hs_mod = protocol.load_module(&quot;heaterShakerModuleV1&quot;, &quot;D1&quot;) hs_adapter = hs_mod.load_adapter(&quot;opentrons_96_flat_bottom_adapter&quot;) hs_plate = hs_adapter.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;) .. versionadded:: 2.15 The ``load_adapter()`` method. Loading Together ---------------- Use the ``adapter`` argument of ``load_labware()`` to load an adapter at the same time as labware. For example, to load the same 96-well plate and adapter from the previous section at once:: hs_plate = hs_mod.load_labware( name=&quot;nest_96_wellplate_200ul_flat&quot;, adapter=&quot;opentrons_96_flat_bottom_adapter&quot; ) .. versionadded:: 2.15 The ``adapter`` parameter. The API also has some &quot;combination&quot; labware definitions, which treat the adapter and labware as a unit:: hs_combo = hs_mod.load_labware( &quot;opentrons_96_flat_bottom_adapter_nest_wellplate_200ul_flat&quot; ) Loading labware this way prevents you from :ref:`moving the labware &amp;lt;moving-labware&amp;gt;` onto or off of the adapter, so it&apos;s less flexible than loading the two separately. Avoid using combination definitions unless your protocol specifies an ``apiLevel`` of 2.14 or lower. .. _new-well-access: ************************** Accessing Wells in Labware ************************** Well Ordering ============= You need to select which wells to transfer liquids to and from over the course of a protocol. Rows of wells on a labware have labels that are capital letters starting with A. For instance, an 96-well plate has 8 rows, labeled ``&quot;A&quot;`` through ``&quot;H&quot;``. Columns of wells on a labware have labels that are numbers starting with 1. For instance, a 96-well plate has columns ``&quot;1&quot;`` through ``&quot;12&quot;``. All well-accessing functions start with the well at the top left corner of the labware. The ending well is in the bottom right. The order of travel from top left to bottom right depends on which function you use. .. image:: ../img/well_iteration/Well_Iteration.png The code in this section assumes that ``plate`` is a 24-well plate. For example: .. code-block:: python plate = protocol.load_labware(&quot;corning_24_wellplate_3.4ml_flat&quot;, location=&quot;D1&quot;) .. _well-accessor-methods: Accessor Methods ================ The API provides many different ways to access wells inside labware. Different methods are useful in different contexts. The table below lists out the methods available to access wells and their differences. .. list-table:: :widths: 20 30 50 :header-rows: 1 * - Method - Returns - Example * - :py:meth:`.Labware.wells` - List of all wells. - ``[labware:A1, labware:B1, labware:C1...]`` * - :py:meth:`.Labware.rows` - List of lists grouped by row. - ``[[labware:A1, labware:A2...], [labware:B1, labware:B2...]]`` * - :py:meth:`.Labware.columns` - List of lists grouped by column. - ``[[labware:A1, labware:B1...], [labware:A2, labware:B2...]]`` * - :py:meth:`.Labware.wells_by_name` - Dictionary with well names as keys. - ``{&quot;A1&quot;: labware:A1, &quot;B1&quot;: labware:B1}`` * - :py:meth:`.Labware.rows_by_name` - Dictionary with row names as keys. - ``{&quot;A&quot;: [labware:A1, labware:A2...], &quot;B&quot;: [labware:B1, labware:B2...]}`` * - :py:meth:`.Labware.columns_by_name` - Dictionary with column names as keys. - ``{&quot;1&quot;: [labware:A1, labware:B1...], &quot;2&quot;: [labware:A2, labware:B2...]}`` Accessing Individual Wells ========================== .. _well-dictionary-access: Dictionary Access ----------------- The simplest way to refer to a single well is by its :py:obj:`.well_name`, like A1 or D6. Referencing a particular key in the result of :py:meth:`.Labware.wells_by_name` accomplishes this. This is such a common task that the API also has an equivalent shortcut: dictionary indexing. .. code-block:: python a1 = plate.wells_by_name()[&quot;A1&quot;] d6 = plate[&quot;D6&quot;] # dictionary indexing If a well does not exist in the labware, such as ``plate[&quot;H12&quot;]`` on a 24-well plate, the API will raise a ``KeyError``. In contrast, it would be a valid reference on a standard 96-well plate. .. versionadded:: 2.0 List Access From ``wells`` -------------------------- In addition to referencing wells by name, you can also reference them with zero-indexing. The first well in a labware is at position 0. .. code-block:: python plate.wells()[0] # well A1 plate.wells()[23] # well D6 .. tip:: You may find coordinate well names like ``&quot;B3&quot;`` easier to reason with, especially when working with irregular labware, e.g. ``opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical`` (see the `Opentrons 10 Tube Rack &amp;lt;https://labware.opentrons.com/opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical&amp;gt;`_ in the Labware Library). Whichever well access method you use, your protocol will be most maintainable if you use only one access method consistently. .. versionadded:: 2.0 Accessing Groups of Wells ========================= When handling liquid, you can provide a group of wells as the source or destination. Alternatively, you can take a group of wells and loop (or iterate) through them, with each liquid-handling command inside the loop accessing the loop index. Use :py:meth:`.Labware.rows_by_name` to access a specific row of wells or :py:meth:`.Labware.columns_by_name` to access a specific column of wells on a labware. These methods both return a dictionary with the row or column name as the keys: .. code-block:: python row_dict = plate.rows_by_name()[&quot;A&quot;] row_list = plate.rows()[0] # equivalent to the line above column_dict = plate.columns_by_name()[&quot;1&quot;] column_list = plate.columns()[0] # equivalent to the line above print(&apos;Column &quot;1&quot; has&apos;, len(column_dict), &apos;wells&apos;) # Column &quot;1&quot; has 4 wells print(&apos;Row &quot;A&quot; has&apos;, len(row_dict), &apos;wells&apos;) # Row &quot;A&quot; has 6 wells Since these methods return either lists or dictionaries, you can iterate through them as you would regular Python data structures. For example, to transfer 50 µL of liquid from the first well of a reservoir to each of the wells of row ``&quot;A&quot;`` on a plate:: for well in plate.rows()[0]: pipette.transfer(reservoir[&quot;A1&quot;], well, 50) Equivalently, using ``rows_by_name``:: for well in plate.rows_by_name()[&quot;A&quot;].values(): pipette.transfer(reservoir[&quot;A1&quot;], well, 50) .. versionadded:: 2.0 .. _labeling-liquids: ************************* Labeling Liquids in Wells ************************* Optionally, you can specify the liquids that should be in various wells at the beginning of your protocol. Doing so helps you identify well contents by name and volume, and adds corresponding labels to a single well, or group of wells, in well plates and reservoirs. You can view the initial liquid setup: - For Flex protocols, on the touchscreen. - For Flex or OT-2 protocols, in the Opentrons App (v6.3.0 or higher). To use these optional methods, first create a liquid object with :py:meth:`.ProtocolContext.define_liquid` and then label individual wells by calling :py:meth:`.Well.load_liquid`. Let&apos;s examine how these two methods work. The following examples demonstrate how to define colored water samples for a well plate and reservoir. .. _defining-liquids: Defining Liquids ================ This example uses ``define_liquid`` to create two liquid objects and instantiates them with the variables ``greenWater`` and ``blueWater``, respectively. The arguments for ``define_liquid`` are all required, and let you name the liquid, describe it, and assign it a color: .. code-block:: python greenWater = protocol.define_liquid( name=&quot;Green water&quot;, description=&quot;Green colored water for demo&quot;, display_color=&quot;#00FF00&quot;, ) blueWater = protocol.define_liquid( name=&quot;Blue water&quot;, description=&quot;Blue colored water for demo&quot;, display_color=&quot;#0000FF&quot;, ) .. versionadded:: 2.14 The ``display_color`` parameter accepts a hex color code, which adds a color to that liquid&apos;s label when you import your protocol into the Opentrons App. The ``define_liquid`` method accepts standard 3-, 4-, 6-, and 8-character hex color codes. .. _loading-liquids: Labeling Wells and Reservoirs ============================= This example uses ``load_liquid`` to label the initial well location, contents, and volume (in µL) for the liquid objects created by ``define_liquid``. Notice how values of the ``liquid`` argument use the variable names ``greenWater`` and ``blueWater`` (defined above) to associate each well with a particular liquid: .. code-block:: python well_plate[&quot;A1&quot;].load_liquid(liquid=greenWater, volume=50) well_plate[&quot;A2&quot;].load_liquid(liquid=greenWater, volume=50) well_plate[&quot;B1&quot;].load_liquid(liquid=blueWater, volume=50) well_plate[&quot;B2&quot;].load_liquid(liquid=blueWater, volume=50) reservoir[&quot;A1&quot;].load_liquid(liquid=greenWater, volume=200) reservoir[&quot;A2&quot;].load_liquid(liquid=blueWater, volume=200) .. versionadded:: 2.14 This information is available after you import your protocol to the app or send it to Flex. A summary of liquids appears on the protocol detail page, and well-by-well detail is available on the run setup page (under Initial Liquid Setup in the app, or under Liquids on Flex). .. note:: ``load_liquid`` does not validate volume for your labware nor does it prevent you from adding multiple liquids to each well. For example, you could label a 40 µL well with ``greenWater``, ``volume=50``, and then also add blue water to the well. The API won&apos;t stop you. It&apos;s your responsibility to ensure the labels you use accurately reflect the amounts and types of liquid you plan to place into wells and reservoirs. Labeling vs Handling Liquids ============================ The ``load_liquid`` arguments include a volume amount (``volume=n`` in µL). This amount is just a label. It isn&apos;t a command or function that manipulates liquids. It only tells you how much liquid should be in a well at the start of the protocol. You need to use a method like :py:meth:`.transfer` to physically move liquids from a source to a destination. .. _v2-location-within-wells: .. _new-labware-well-properties: *************** Well Dimensions *************** The functions in the :ref:`new-well-access` section above return a single :py:class:`.Well` object or a larger object representing many wells. :py:class:`.Well` objects have attributes that provide information about their physical shape, such as the depth or diameter, as specified in their corresponding labware definition. These properties can be used for different applications, such as calculating the volume of a well or a :ref:`position relative to the well &amp;lt;position-relative-labware&amp;gt;`. Depth ===== Use :py:attr:`.Well.depth` to get the distance in mm between the very top of the well and the very bottom. For example, a conical well&apos;s depth is measured from the top center to the bottom center of the well. .. code-block:: python :substitutions: plate = protocol.load_labware(&quot;corning_96_wellplate_360ul_flat&quot;, &quot;D1&quot;) depth = plate[&quot;A1&quot;].depth # 10.67 Diameter ======== Use :py:attr:`.Well.diameter` to get the diameter of a given well in mm. Since diameter is a circular measurement, this attribute is only present on labware with circular wells. If the well is not circular, the value will be ``None``. Use length and width (see below) for non-circular wells. .. code-block:: python :substitutions: plate = protocol.load_labware(&quot;corning_96_wellplate_360ul_flat&quot;, &quot;D1&quot;) diameter = plate[&quot;A1&quot;].diameter # 6.86 Length ====== Use :py:attr:`.Well.length` to get the length of a given well in mm. Length is defined as the distance along the robot&apos;s x-axis (left to right). This attribute is only present on rectangular wells. If the well is not rectangular, the value will be ``None``. Use diameter (see above) for circular wells. .. code-block:: python :substitutions: plate = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, &quot;D1&quot;) length = plate[&quot;A1&quot;].length # 8.2 Width ===== Use :py:attr:`.Well.width` to get the width of a given well in mm. Width is defined as the distance along the y-axis (front to back). This attribute is only present on rectangular wells. If the well is not rectangular, the value will be ``None``. Use diameter (see above) for circular wells. .. code-block:: python :substitutions: plate = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, &quot;D1&quot;) width = plate[&quot;A1&quot;].width # 71.2 .. versionadded:: 2.9</content></file><file name="new_modules.rst" type="rst"><content>:og:description: How to work with powered and unpowered Opentrons hardware modules in a Python protocol. .. _new_modules: **************** Hardware Modules **************** .. toctree:: modules/setup modules/absorbance_plate_reader modules/heater_shaker modules/magnetic_block modules/magnetic_module modules/temperature_module modules/thermocycler modules/multiple_same_type Hardware modules are powered and unpowered deck-mounted peripherals. The Flex and OT-2 are aware of deck-mounted powered modules when they&apos;re attached via a USB connection and used in an uploaded protocol. The robots do not know about unpowered modules until you use one in a protocol and upload it to the Opentrons App. Powered modules include the Absorbance Plate Reader Module, Heater-Shaker Module, Magnetic Module, Temperature Module, and Thermocycler Module. The 96-well Magnetic Block is an unpowered module. Pages in this section of the documentation cover: - :ref:`Setting up modules and their labware &amp;lt;module-setup&amp;gt;`. - Working with the module contexts for each type of module. - :ref:`Absorbance Plate Reader Module &amp;lt;absorbance-plate-reader-module&amp;gt;` - :ref:`Heater-Shaker Module &amp;lt;heater-shaker-module&amp;gt;` - :ref:`Magnetic Block &amp;lt;magnetic-block&amp;gt;` - :ref:`Magnetic Module &amp;lt;magnetic-module&amp;gt;` - :ref:`Temperature Module &amp;lt;temperature-module&amp;gt;` - :ref:`Thermocycler Module &amp;lt;thermocycler-module&amp;gt;` - Working with :ref:`multiple modules of the same type &amp;lt;moam&amp;gt;` in a single protocol. .. note:: Throughout these pages, most code examples use coordinate deck slot locations (e.g. ``&quot;D1&quot;``, ``&quot;D2&quot;``), like those found on Flex. If you have an OT-2 and are using API version 2.14 or earlier, replace the coordinate with its numeric OT-2 equivalent. For example, slot D1 on Flex corresponds to slot 1 on an OT-2. See :ref:`deck-slots` for more information.</content></file><file name="new_pipette.rst" type="rst"><content>:og:description: How to load and work with Opentrons pipettes in a Python protocol. .. _new-pipette: ******** Pipettes ******** .. toctree:: pipettes/loading pipettes/characteristics pipettes/partial_tip_pickup pipettes/volume_modes Opentrons pipettes are configurable devices used to move liquids throughout the working area during the execution of protocols. Flex and OT-2 each have their own pipettes, which are available for use in the Python API. Pages in this section of the documentation cover: - :ref:`Loading pipettes &amp;lt;loading-pipettes&amp;gt;` into your protocol. - :ref:`Pipette characteristics &amp;lt;pipette-characteristics&amp;gt;`, such as how fast they can move liquid and how they move around the deck. - :ref:`Partial tip pickup &amp;lt;partial-tip-pickup&amp;gt;` configurations for multi-channel pipettes. Full and partial tip pickup configurations can be combined in a single protocol. - The :ref:`volume modes &amp;lt;pipette-volume-modes&amp;gt;` of Flex 50 µL pipettes, which must operate in low-volume mode to accurately dispense very small volumes of liquid. For information about liquid handling, see :ref:`v2-atomic-commands` and :ref:`v2-complex-commands`.</content></file><file name="new_protocol_api.rst" type="rst"><content>:og:description: A comprehensive reference of classes and methods that make up the Opentrons Python Protocol API. .. _protocol-api-reference: *********************** API Version 2 Reference *********************** .. _protocol_api-protocols-and-instruments: Protocols ========= .. module:: opentrons.protocol_api .. autoclass:: opentrons.protocol_api.ProtocolContext :members: :exclude-members: location_cache, cleanup, clear_commands Instruments =========== .. autoclass:: opentrons.protocol_api.InstrumentContext :members: :exclude-members: delay .. _protocol-api-labware: Labware ======= .. autoclass:: opentrons.protocol_api.Labware :members: :exclude-members: next_tip, use_tips, previous_tip, return_tips, load_empty, load_liquid, load_liquid_by_well .. The trailing ()s at the end of TrashBin and WasteChute here hide the __init__() signatures, since users should never construct these directly. .. autoclass:: opentrons.protocol_api.TrashBin() :members: .. autoclass:: opentrons.protocol_api.WasteChute() :members: Wells and Liquids ================= .. autoclass:: opentrons.protocol_api.Well :members: :exclude-members: geometry .. autoclass:: opentrons.protocol_api.Liquid .. _protocol-api-modules: Modules ======= Absorbance Plate Reader ----------------------- .. autoclass:: opentrons.protocol_api.AbsorbanceReaderContext :members: :exclude-members: broker, geometry, load_labware_object, load_adapter, load_adapter_from_definition :inherited-members: Heater-Shaker ------------- .. autoclass:: opentrons.protocol_api.HeaterShakerContext :members: :exclude-members: broker, geometry, load_labware_object :inherited-members: Magnetic Block -------------- .. autoclass:: opentrons.protocol_api.MagneticBlockContext :members: :exclude-members: broker, geometry, load_labware_object :inherited-members: Magnetic Module --------------- .. autoclass:: opentrons.protocol_api.MagneticModuleContext :members: :exclude-members: calibrate, broker, geometry, load_labware_object :inherited-members: Temperature Module ------------------ .. autoclass:: opentrons.protocol_api.TemperatureModuleContext :members: :exclude-members: start_set_temperature, await_temperature, broker, geometry, load_labware_object :inherited-members: Thermocycler ------------ .. autoclass:: opentrons.protocol_api.ThermocyclerContext :members: :exclude-members: total_step_count, current_cycle_index, total_cycle_count, hold_time, ramp_rate, current_step_index, broker, geometry, load_labware_object, load_adapter, load_adapter_from_definition :inherited-members: .. _protocol-api-types: Useful Types ============ .. The opentrons.types module contains a mixture of public Protocol API things and private internal things. Explicitly name the things that we expect to be public, excluding everything else. .. automodule:: opentrons.types :members: PipetteNotAttachedError, Point, Location, Mount .. autoclass:: opentrons.protocol_api.CSVParameter :members: .. autodata:: opentrons.protocol_api.OFF_DECK :no-value: Executing and Simulating Protocols ================================== .. automodule:: opentrons.execute :members: .. automodule:: opentrons.simulate :members:</content></file><file name="robot_position.rst" type="rst"><content>:og:description: How to define positions within an Opentrons robot and alter its speed and trajectory. .. _robot-position: ************************** Labware and Deck Positions ************************** The API automatically determines how the robot needs to move when working with the instruments and labware in your protocol. But sometimes you need direct control over these activities. The API lets you do just that. Specifically, you can control movements relative to labware and deck locations. You can also manage the gantry’s speed and trajectory as it traverses the working area. This document explains how to use API commands to take direct control of the robot and position it exactly where you need it. .. _position-relative-labware: Position Relative to Labware ============================ When the robot positions itself relative to a piece of labware, where it moves is determined by the labware definition, the actions you want it to perform, and the labware offsets for a specific deck slot. This section describes how these positional components are calculated and how to change them. Top, Bottom, and Center ----------------------- Every well on every piece of labware has three addressable positions: top, bottom, and center. The position is determined by the labware definition and what the labware is loaded on top of. You can use these positions as-is or calculate other positions relative to them. .. _well-top: Top ^^^^ Let&apos;s look at the :py:meth:`.Well.top` method. It returns a position level with the top of the well, centered in both horizontal directions. .. code-block:: python plate[&quot;A1&quot;].top() # the top center of the well This is a good position to use for a :ref:`blow out operation &amp;lt;new-blow-out&amp;gt;` or an activity where you don&apos;t want the tip to contact the liquid. In addition, you can adjust the height of this position with the optional argument ``z``, which is measured in mm. Positive ``z`` numbers move the position up, negative ``z`` numbers move it down. .. code-block:: python plate[&quot;A1&quot;].top(z=1) # 1 mm above the top center of the well plate[&quot;A1&quot;].top(z=-1) # 1 mm below the top center of the well .. versionadded:: 2.0 Bottom ^^^^^^ Let&apos;s look at the :py:meth:`.Well.bottom` method. It returns a position level with the bottom of the well, centered in both horizontal directions. .. code-block:: python plate[&quot;A1&quot;].bottom() # the bottom center of the well This is a good position for :ref:`aspirating liquid &amp;lt;new-aspirate&amp;gt;` or an activity where you want the tip to contact the liquid. Similar to the ``Well.top()`` method, you can adjust the height of this position with the optional argument ``z``, which is measured in mm. Positive ``z`` numbers move the position up, negative ``z`` numbers move it down. .. code-block:: python plate[&quot;A1&quot;].bottom(z=1) # 1 mm above the bottom center of the well plate[&quot;A1&quot;].bottom(z=-1) # 1 mm below the bottom center of the well # this may be dangerous! .. warning:: Negative ``z`` arguments to ``Well.bottom()`` will cause the pipette tip to collide with the bottom of the well. Collisions may bend the tip (affecting liquid handling) and the pipette may be higher than expected on the z-axis until it picks up another tip. Flex can detect collisions, and even gentle contact may trigger an overpressure error and cause the protocol to fail. Avoid ``z`` values less than 1, if possible. The OT-2 has no sensors to detect contact with a well bottom. The protocol will continue even after a collision. .. versionadded:: 2.0 Center ^^^^^^ Let&apos;s look at the :py:meth:`.Well.center` method. It returns a position centered in the well both vertically and horizontally. This can be a good place to start for precise control of positions within the well for unusual or custom labware. .. code-block:: python plate[&quot;A1&quot;].center() # the vertical and horizontal center of the well .. versionadded:: 2.0 .. _new-default-op-positions: Default Positions ----------------- By default, your robot will aspirate and dispense 1 mm above the bottom of wells. This default clearance may not be suitable for some labware geometries, liquids, or protocols. You can change this value by using the :py:meth:`.Well.bottom` method with the ``z`` argument, though it can be cumbersome to do so repeatedly. If you need to change the aspiration or dispensing height for multiple operations, specify the distance in mm from the well bottom with the :py:obj:`.InstrumentContext.well_bottom_clearance` object. It has two attributes: ``well_bottom_clearance.aspirate`` and ``well_bottom_clearance.dispense``. These change the aspiration height and dispense height, respectively. Modifying these attributes will affect all subsequent aspirate and dispense actions performed by the attached pipette, even those executed as part of a :py:meth:`.transfer` operation. This snippet from a sample protocol demonstrates how to work with and change the default clearance:: # aspirate 1 mm above the bottom of the well (default) pipette.aspirate(50, plate[&quot;A1&quot;]) # dispense 1 mm above the bottom of the well (default) pipette.dispense(50, plate[&quot;A1&quot;]) # change clearance for aspiration to 2 mm pipette.well_bottom_clearance.aspirate = 2 # aspirate 2 mm above the bottom of the well pipette.aspirate(50, plate[&quot;A1&quot;]) # still dispensing 1 mm above the bottom pipette.dispense(50, plate[&quot;A1&quot;]) pipette.aspirate(50, plate[&quot;A1&quot;]) # change clearance for dispensing to 10 mm pipette.well_bottom_clearance.dispense = 10 # dispense high above the well pipette.dispense(50, plate[&quot;A1&quot;]) .. versionadded:: 2.0 Using Labware Position Check ============================ All positions relative to labware are adjusted automatically based on labware offset data. Calculate labware offsets by running Labware Position Check during protocol setup, either in the Opentrons App or on the Flex touchscreen. Version 6.0.0 and later of the robot software can apply previously calculated offsets on the same robot for the same labware type and deck slot, even across different protocols. You should only adjust labware offsets in your Python code if you plan to run your protocol in Jupyter Notebook or from the command line. See :ref:`using_lpc` in the Advanced Control article for information. .. _position-relative-trash: Position Relative to Trash Containers ===================================== Movement to :py:class:`.TrashBin` or :py:class:`.WasteChute` objects is based on the horizontal *center* of the pipette. This is different than movement to labware, which is based on the primary channel (the back channel on 8-channel pipettes, and the back-left channel on 96-channel pipettes in default configuration). Using the center of the pipette ensures that all attached tips are over the trash container for blowing out, dropping tips, or other disposal operations. .. note:: In API version 2.15 and earlier, trash containers are :py:class:`.Labware` objects that have a single well. See :py:obj:`.fixed_trash` and :ref:`position-relative-labware` above. You can adjust the position of the pipette center with the :py:meth:`.TrashBin.top` and :py:meth:`.WasteChute.top` methods. These methods allow adjustments along the x-, y-, and z-axes. In contrast, ``Well.top()``, :ref:`covered above &amp;lt;well-top&amp;gt;`, only allows z-axis adjustment. With no adjustments, the &quot;top&quot; position is centered on the x- and y-axes and is just below the opening of the trash container. .. code-block:: python trash = protocol.load_trash_bin(&quot;A3&quot;) trash # pipette center just below trash top center trash.top() # same position trash.top(z=10) # 10 mm higher trash.top(y=10) # 10 mm towards back, default height .. versionadded:: 2.18 Another difference between the trash container ``top()`` methods and ``Well.top()`` is that they return an object of the same type, not a :py:class:`.Location`. This helps prevent performing undesired actions in trash containers. For example, you can :py:meth:`.aspirate` at a location or from a well, but not from a trash container. On the other hand, you can :py:meth:`.blow_out` at a location, well, trash bin, or waste chute. .. _protocol-api-deck-coords: Position Relative to the Deck ============================= The robot&apos;s base coordinate system is known as *deck coordinates*. Many API functions use this coordinate system, and you can also reference it directly. It is a right-handed coordinate system always specified in mm, with the origin ``(0, 0, 0)`` at the front left of the robot. The positive ``x`` direction is to the right, the positive ``y`` direction is to the back, and the positive ``z`` direction is up. You can identify a point in this coordinate system with a :py:class:`.types.Location` object, either as a standard Python :py:class:`tuple` of three floats, or as an instance of the :py:obj:`~collections.namedtuple` :py:class:`.types.Point`. .. note:: There are technically multiple vertical axes. For example, ``z`` is the axis of the left pipette mount and ``a`` is the axis of the right pipette mount. There are also pipette plunger axes: ``b`` (left) and ``c`` (right). You usually don&apos;t have to refer to these axes directly, since most motion commands are issued to a particular pipette and the robot automatically selects the correct axis to move. Similarly, :py:class:`.types.Location` only deals with ``x``, ``y``, and ``z`` values. Independent Movement ==================== For convenience, many methods have location arguments and incorporate movement automatically. This section will focus on moving the pipette independently, without performing other actions like ``aspirate()`` or ``dispense()``. .. _move-to: Move To ------- The :py:meth:`.InstrumentContext.move_to` method moves a pipette to any reachable location on the deck. If the pipette has picked up a tip, it will move the end of the tip to that position; if it hasn&apos;t, it will move the pipette nozzle to that position. The :py:meth:`~.InstrumentContext.move_to` method requires the :py:class:`.Location` argument. The location can be automatically generated by methods like ``Well.top()`` and ``Well.bottom()`` or one you&apos;ve created yourself, but you can&apos;t move a pipette to a well directly: .. code-block:: python pipette.move_to(plate[&quot;A1&quot;]) # error; can&apos;t move to a well itself pipette.move_to(plate[&quot;A1&quot;].bottom()) # move to the bottom of well A1 pipette.move_to(plate[&quot;A1&quot;].top()) # move to the top of well A1 pipette.move_to(plate[&quot;A1&quot;].bottom(z=2)) # move to 2 mm above the bottom of well A1 pipette.move_to(plate[&quot;A1&quot;].top(z=-2)) # move to 2 mm below the top of well A1 When using ``move_to()``, by default the pipette will move in an arc: first upwards, then laterally to a position above the target location, and finally downwards to the target location. If you have a reason for doing so, you can force the pipette to move in a straight line to the target location: .. code-block:: python pipette.move_to(plate[&quot;A1&quot;].top(), force_direct=True) .. warning:: Moving without an arc runs the risk of the pipette colliding with objects on the deck. Be very careful when using this option, especially when moving longer distances. Small, direct movements can be useful for working inside of a well, without having the tip exit and re-enter the well. This code sample demonstrates how to move the pipette to a well, make direct movements inside that well, and then move on to a different well:: pipette.move_to(plate[&quot;A1&quot;].top()) pipette.move_to(plate[&quot;A1&quot;].bottom(1), force_direct=True) pipette.move_to(plate[&quot;A1&quot;].top(-2), force_direct=True) pipette.move_to(plate[&quot;A2&quot;].top()) .. versionadded:: 2.0 .. _points-locations: Points and Locations -------------------- When instructing the robot to move, it&apos;s important to consider the difference between the :py:class:`~opentrons.types.Point` and :py:class:`~opentrons.types.Location` types. * Points are ordered tuples or named tuples: ``Point(10, 20, 30)``, ``Point(x=10, y=20, z=30)``, and ``Point(z=30, y=20, x=10)`` are all equivalent. * Locations are a higher-order tuple that combines a point with a reference object: a well, a piece of labware, or ``None`` (the deck). .. TODO document position_for and other methods in deck.py that return Locations This distinction is important for the :py:meth:`.Location.move` method, which operates on a location, takes a point as an argument, and outputs an updated location. To use this method, include ``from opentrons import types`` at the start of your protocol. The ``move()`` method does not mutate the location it is called on, so to perform an action at the updated location, use it as an argument of another method or save it to a variable. For example:: # get the location at the center of well A1 center_location = plate[&quot;A1&quot;].center() # get a location 1 mm right, 1 mm back, and 1 mm up from the center of well A1 adjusted_location = center_location.move(types.Point(x=1, y=1, z=1)) # aspirate 1 mm right, 1 mm back, and 1 mm up from the center of well A1 pipette.aspirate(50, adjusted_location) # dispense at the same location pipette.dispense(50, center_location.move(types.Point(x=1, y=1, z=1))) .. note:: The additional ``z`` arguments of the ``top()`` and ``bottom()`` methods (see :ref:`position-relative-labware` above) are shorthand for adjusting the top and bottom locations with ``move()``. You still need to use ``move()`` to adjust these positions along the x- or y-axis: .. code-block:: python # the following are equivalent pipette.move_to(plate[&quot;A1&quot;].bottom(z=2)) pipette.move_to(plate[&quot;A1&quot;].bottom().move(types.Point(z=2))) # adjust along the y-axis pipette.move_to(plate[&quot;A1&quot;].bottom().move(types.Point(y=2))) .. versionadded:: 2.0 Movement Speeds =============== In addition to instructing the robot where to move a pipette, you can also control the speed at which it moves. Speed controls can be applied either to all pipette motions or to movement along a particular axis. .. note:: Like all mechanical systems, Opentrons robots have resonant frequencies that depend on their construction and current configuration. It&apos;s possible to set a speed that causes your robot to resonate, producing louder sounds than typical operation. This is safe, but if you find it annoying, increase or decrease the speed slightly. .. _gantry_speed: Gantry Speed ------------ The robot&apos;s gantry usually moves as fast as it can given its construction. The default speed for Flex varies between 300 and 350 mm/s. The OT-2 default is 400 mm/s. However, some experiments or liquids may require slower movements. In this case, you can reduce the gantry speed for a specific pipette by setting :py:obj:`.InstrumentContext.default_speed` like this:: pipette.move_to(plate[&quot;A1&quot;].top()) # move to the first well at default speed pipette.default_speed = 100 # reduce pipette speed pipette.move_to(plate[&quot;D6&quot;].top()) # move to the last well at the slower speed .. warning:: These default speeds were chosen because they&apos;re the maximum speeds that Opentrons knows will work with the gantry. Your robot may be able to move faster, but you shouldn&apos;t increase this value unless instructed by Opentrons Support. .. versionadded:: 2.0 .. _axis_speed_limits: Axis Speed Limits ----------------- In addition to controlling the overall gantry speed, you can set speed limits for each of the individual axes: ``x`` (gantry left/right motion), ``y`` (gantry forward/back motion), ``z`` (left pipette up/down motion), and ``a`` (right pipette up/down motion). Unlike ``default_speed``, which is a pipette property, axis speed limits are stored in a protocol property :py:obj:`.ProtocolContext.max_speeds`; therefore the ``x`` and ``y`` values affect all movements by both pipettes. This property works like a dictionary, where the keys are axes, assigning a value to a key sets a max speed, and deleting a key or setting it to ``None`` resets that axis&apos;s limit to the default: .. code-block:: python :substitutions: protocol.max_speeds[&quot;x&quot;] = 50 # limit x-axis to 50 mm/s del protocol.max_speeds[&quot;x&quot;] # reset x-axis limit protocol.max_speeds[&quot;a&quot;] = 10 # limit a-axis to 10 mm/s protocol.max_speeds[&quot;a&quot;] = None # reset a-axis limit Note that ``max_speeds`` can&apos;t set limits for the pipette plunger axes (``b`` and ``c``); instead, set the flow rates or plunger speeds as described in :ref:`new-plunger-flow-rates`. .. versionadded:: 2.0</content></file><file name="runtime_parameters.rst" type="rst"><content>:og:description: Define and customize parameters in Opentrons Python protocols. .. _runtime-parameters: ****************** Runtime Parameters ****************** .. toctree:: parameters/choosing parameters/defining parameters/using_values parameters/use_case_sample_count parameters/use_case_dry_run parameters/use_case_cherrypicking parameters/style Runtime parameters let you define user-customizable variables in your Python protocols. This gives you greater flexibility and puts extra control in the hands of the technician running the protocol — without forcing them to switch between lots of protocol files or write code themselves. This section begins with the fundamentals of runtime parameters: - Preliminary advice on how to :ref:`choose good parameters &amp;lt;good-rtps&amp;gt;`, before you start writing code. - The syntax for :ref:`defining parameters &amp;lt;defining-rtp&amp;gt;` with boolean, numeric, and string values. - How to :ref:`use parameter values &amp;lt;using-rtp&amp;gt;` in your protocol, building logic and API calls that implement the technician&apos;s choices. It continues with a selection of use cases and some overall style guidance. When adding parameters, you are in charge of the user experience when it comes time to set up the protocol! These pages outline best practices for making your protocols reliable and easy to use. - :ref:`Use case – sample count &amp;lt;use-case-sample-count&amp;gt;`: Change behavior throughout a protocol based on how many samples you plan to process. Setting sample count exactly saves time, tips, and reagents. - :ref:`Use case – dry run &amp;lt;use-case-dry-run&amp;gt;`: Test your protocol, rather than perform a live run, just by flipping a toggle. - :ref:`Use case – cherrypicking &amp;lt;use-case-cherrypicking&amp;gt;`: Use a CSV file to specify locations and volumes for a simple cherrypicking protocol. - :ref:`Style and usage &amp;lt;rtp-style&amp;gt;`: When you&apos;re a protocol author, you write code. When you&apos;re a parameter author, you write words. Follow this advice to make things as clear as possible for the technicians who will run your protocol.</content></file><file name="tutorial.rst" type="rst"><content>:og:description: A guide to creating your first Python protocol and running it on an Opentrons robot. .. _tutorial: ******** Tutorial ******** Introduction ============ This tutorial will guide you through creating a Python protocol file from scratch. At the end of this process you&apos;ll have a complete protocol that can run on a Flex or an OT-2 robot. If you don’t have a Flex or an OT-2 (or if you’re away from your lab, or if your robot is in use), you can use the same file to simulate the protocol on your computer instead. What You&apos;ll Automate -------------------- The lab task that you&apos;ll automate in this tutorial is `serial dilution`: taking a solution and progressively diluting it by transferring it stepwise across a plate from column 1 to column 12. With just a dozen or so lines of code, you can instruct your robot to perform the hundreds of individual pipetting actions necessary to fill an entire 96-well plate. And all of those liquid transfers will be done automatically, so you’ll have more time to do other work in your lab. Before You Begin ---------------- You&apos;re going to write some Python code, but you don&apos;t need to be a Python expert to get started writing Opentrons protocols. You should know some basic Python syntax, like how it uses `indentation &amp;lt;https://docs.python.org/3/reference/lexical_analysis.html#indentation&amp;gt;`_ to group blocks of code, dot notation for `calling methods &amp;lt;https://docs.python.org/3/tutorial/classes.html#method-objects&amp;gt;`_, and the format of `lists &amp;lt;https://docs.python.org/3/tutorial/introduction.html#lists&amp;gt;`_ and `dictionaries &amp;lt;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&amp;gt;`_. You’ll also be using `common control structures &amp;lt;https://docs.python.org/3/tutorial/controlflow.html#if-statements&amp;gt;`_ like ``if`` statements and ``for`` loops. You should write your code in your favorite plaintext editor or development environment and save it in a file with a ``.py`` extension, like ``dilution-tutorial.py``. To simulate your code, you&apos;ll need `Python 3.10 &amp;lt;https://www.python.org/downloads/&amp;gt;`_ and the `pip package installer &amp;lt;https://pip.pypa.io/en/stable/getting-started/&amp;gt;`_. Newer versions of Python aren&apos;t yet supported by the Python Protocol API. If you don&apos;t use Python 3.10 as your system Python, we recommend using `pyenv &amp;lt;https://github.com/pyenv/pyenv&amp;gt;`_ to manage multiple Python versions. Hardware and Labware -------------------- Before running a protocol, you’ll want to have the right kind of hardware and labware ready for your Flex or OT-2. - **Flex users** should review Chapter 2: Installation and Relocation in the `instruction manual &amp;lt;https://insights.opentrons.com/hubfs/Products/Flex/Opentrons%20Flex%20Manual.pdf&amp;gt;`_. Specifically, see the pipette information in the &quot;Instrument Installation and Calibration&quot; section. You can use either a 1-channel or 8-channel pipette for this tutorial. Most Flex code examples will use a `Flex 1-Channel 1000 µL pipette &amp;lt;https://shop.opentrons.com/opentrons-flex-1-channel-pipette/&amp;gt;`_. - **OT-2 users** should review the robot setup and pipette information on the `Get Started page &amp;lt;https://support.opentrons.com/s/ot2-get-started&amp;gt;`_. Specifically, see `attaching pipettes &amp;lt;https://support.opentrons.com/s/article/Get-started-Attach-pipettes&amp;gt;`_ and `initial calibration &amp;lt;https://support.opentrons.com/s/article/Get-started-Calibrate-the-deck&amp;gt;`_. You can use either a single-channel or 8-channel pipette for this tutorial. Most OT-2 code examples will use a `P300 Single-Channel GEN2 &amp;lt;https://shop.opentrons.com/single-channel-electronic-pipette-p20/&amp;gt;`_ pipette. The Flex and OT-2 use similar labware for serial dilution. The tutorial code will use the labware listed in the table below, but as long as you have labware of each type you can modify the code to run with your labware. .. list-table:: :widths: 20 40 50 :header-rows: 1 * - Labware type - Labware name - API load name * - Reservoir - `NEST 12 Well Reservoir 15 mL &amp;lt;https://labware.opentrons.com/nest_12_reservoir_15ml&amp;gt;`_ - ``nest_12_reservoir_15ml`` * - Well plate - `NEST 96 Well Plate 200 µL Flat &amp;lt;https://labware.opentrons.com/nest_96_wellplate_200ul_flat&amp;gt;`_ - ``nest_96_wellplate_200ul_flat`` * - Flex tip rack - `Opentrons Flex Tips, 200 µL &amp;lt;https://shop.opentrons.com/opentrons-flex-tips-200-l/&amp;gt;`_ - ``opentrons_flex_96_tiprack_200ul`` * - OT-2 tip rack - `Opentrons 96 Tip Rack &amp;lt;https://labware.opentrons.com/?category=tipRack&amp;amp;manufacturer=Opentrons&amp;gt;`_ - ``opentrons_96_tiprack_300ul`` For the liquids, you can use plain water as the diluent and water dyed with food coloring as the solution. Create a Protocol File ====================== Let’s start from scratch to create your serial dilution protocol. Open up a new file in your editor and start with the line: .. code-block:: python from opentrons import protocol_api Throughout this documentation, you’ll see protocols that begin with the ``import`` statement shown above. It identifies your code as an Opentrons protocol. This statement is not required, but including it is a good practice and allows most code editors to provide helpful autocomplete suggestions. Everything else in the protocol file is required. Next, you’ll specify the version of the API you’re using. Then comes the core of the protocol: defining a single ``run()`` function that provides the locations of your labware, states which kind of pipettes you’ll use, and finally issues the commands that the robot will perform. For this tutorial, you’ll write very little Python outside of the ``run()`` function. But for more complex applications it’s worth remembering that your protocol file *is* a Python script, so any Python code that can run on your robot can be a part of a protocol. .. _tutorial-metadata: Metadata -------- Every protocol needs to have a metadata dictionary with information about the protocol. At minimum, you need to specify what :ref:`version of the API &amp;lt;version-table&amp;gt;` the protocol requires. The `scripts &amp;lt;https://github.com/Opentrons/opentrons/blob/edge/api/docs/v2/example_protocols/&amp;gt;`_ for this tutorial were validated against API version 2.16, so specify: .. code-block:: python metadata = {&quot;apiLevel&quot;: &quot;2.16&quot;} You can include any other information you like in the metadata dictionary. The fields ``protocolName``, ``description``, and ``author`` are all displayed in the Opentrons App, so it’s a good idea to expand the dictionary to include them: .. code-block:: python metadata = { &quot;apiLevel&quot;: &quot;2.16&quot;, &quot;protocolName&quot;: &quot;Serial Dilution Tutorial&quot;, &quot;description&quot;: &quot;&quot;&quot;This protocol is the outcome of following the Python Protocol API Tutorial located at https://docs.opentrons.com/v2/tutorial.html. It takes a solution and progressively dilutes it by transferring it stepwise across a plate.&quot;&quot;&quot;, &quot;author&quot;: &quot;New API User&quot; } Note, if you have a Flex, or are using an OT-2 with API v2.15 (or higher), we recommend adding a ``requirements`` section to your code. See the Requirements section below. .. _tutorial-requirements: Requirements ------------ The ``requirements`` code block can appear before *or* after the ``metadata`` code block in a Python protocol. It uses the following syntax and accepts two arguments: ``robotType`` and ``apiLevel``. Whether you need a ``requirements`` block depends on your robot model and API version. - **Flex:** The ``requirements`` block is always required. And, the API version does not go in the ``metadata`` section. The API version belongs in the ``requirements``. For example:: requirements = {&quot;robotType&quot;: &quot;Flex&quot;, &quot;apiLevel&quot;: &quot;2.16&quot;} - **OT-2:** The ``requirements`` block is optional, but including it is a recommended best practice, particularly if you’re using API version 2.15 or greater. If you do use it, remember to remove the API version from the ``metadata``. For example:: requirements = {&quot;robotType&quot;: &quot;OT-2&quot;, &quot;apiLevel&quot;: &quot;2.16&quot;} With the metadata and requirements defined, you can move on to creating the ``run()`` function for your protocol. .. _run-function: The ``run()`` function ---------------------- Now it’s time to actually instruct the Flex or OT-2 how to perform serial dilution. All of this information is contained in a single Python function, which has to be named ``run``. This function takes one argument, which is the *protocol context*. Many examples in these docs use the argument name ``protocol``, and sometimes they specify the argument’s type: .. code-block:: python def run(protocol: protocol_api.ProtocolContext): With the protocol context argument named and typed, you can start calling methods on ``protocol`` to add labware and hardware. Labware ^^^^^^^ For serial dilution, you need to load a tip rack, reservoir, and 96-well plate on the deck of your Flex or OT-2. Loading labware is done with the :py:meth:`~.ProtocolContext.load_labware` method of the protocol context, which takes two arguments: the standard labware name as defined in the `Opentrons Labware Library &amp;lt;https://labware.opentrons.com/&amp;gt;`_, and the position where you&apos;ll place the labware on the robot&apos;s deck. .. tabs:: .. tab:: Flex Here’s how to load the labware on a Flex in slots D1, D2, and D3 (repeating the ``def`` statement from above to show proper indenting): .. code-block:: python def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_flex_96_tiprack_200ul&quot;, &quot;D1&quot;) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, &quot;D2&quot;) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, &quot;D3&quot;) If you’re using a different model of labware, find its name in the Labware Library and replace it in your code. Now the robot will expect to find labware in a configuration that looks like this: .. image:: ../img/tutorial/initial-deck-map-flex.png :scale: 50 % :name: Initial Deck State – Flex :align: center :alt: Flex deck map with a tip rack in slot D1, reservoir in slot D2, and well plate in slot D3. .. tab:: OT-2 Here’s how to load the labware on an OT-2 in slots 1, 2, and 3 (repeating the ``def`` statement from above to show proper indenting): .. code-block:: python def run(protocol: protocol_api.ProtocolContext): tips = protocol.load_labware(&quot;opentrons_96_tiprack_300ul&quot;, 1) reservoir = protocol.load_labware(&quot;nest_12_reservoir_15ml&quot;, 2) plate = protocol.load_labware(&quot;nest_96_wellplate_200ul_flat&quot;, 3) If you’re using a different model of labware, find its name in the Labware Library and replace it in your code. Now the robot will expect to find labware in a configuration that looks like this: .. image:: ../img/tutorial/initial-deck-map.png :scale: 50 % :name: Initial Deck State – OT-2 :align: center :alt: OT-2 deck map with a tip rack in slot 1, reservoir in slot 2, and well plate in slot 3. You may notice that these deck maps don&apos;t show where the liquids will be at the start of the protocol. Liquid definitions aren’t required in Python protocols, unlike protocols made in `Protocol Designer &amp;lt;https://designer.opentrons.com/&amp;gt;`_. If you want to identify liquids, see `Labeling Liquids in Wells &amp;lt;https://docs.opentrons.com/v2/new_labware.html#labeling-liquids-in-wells&amp;gt;`_. (Sneak peek: you’ll put the diluent in column 1 of the reservoir and the solution in column 2 of the reservoir.) Trash Bin ^^^^^^^^^ Flex and OT-2 both come with a trash bin for disposing used tips. The OT-2 trash bin is fixed in slot 12. Since it can&apos;t go anywhere else on the deck, you don&apos;t need to write any code to tell the API where it is. Skip ahead to the Pipettes section below. Flex lets you put a :ref:`trash bin &amp;lt;configure-trash-bin&amp;gt;` in multiple locations on the deck. You can even have more than one trash bin, or none at all (if you use the :ref:`waste chute &amp;lt;configure-waste-chute&amp;gt;` instead, or if your protocol never trashes any tips). For serial dilution, you&apos;ll need to dispose used tips, so you also need to tell the API where the trash container is located on your robot. Loading a trash bin on Flex is done with the :py:meth:`.load_trash_bin` method, which takes one argument: its location. Here&apos;s how to load the trash in slot A3:: trash = protocol.load_trash_bin(&quot;A3&quot;) Pipettes ^^^^^^^^ Next you’ll specify what pipette to use in the protocol. Loading a pipette is done with the :py:meth:`.load_instrument` method, which takes three arguments: the name of the pipette, the mount it’s installed in, and the tip racks it should use when performing transfers. Load whatever pipette you have installed in your robot by using its :ref:`standard pipette name &amp;lt;new-pipette-models&amp;gt;`. Here’s how to load the pipette in the left mount and instantiate it as a variable named ``left_pipette``: .. code-block:: python # Flex left_pipette = protocol.load_instrument(&quot;flex_1channel_1000&quot;, &quot;left&quot;, tip_racks=[tips]) .. code-block:: python # OT-2 left_pipette = protocol.load_instrument(&quot;p300_single_gen2&quot;, &quot;left&quot;, tip_racks=[tips]) Since the pipette is so fundamental to the protocol, it might seem like you should have specified it first. But there’s a good reason why pipettes are loaded after labware: you need to have already loaded ``tips`` in order to tell the pipette to use it. And now you won’t have to reference ``tips`` again in your code — it’s assigned to the ``left_pipette`` and the robot will know to use it when commanded to pick up tips. .. note:: You may notice that the value of ``tip_racks`` is in brackets, indicating that it’s a list. This serial dilution protocol only uses one tip rack, but some protocols require more tips, so you can assign them to a pipette all at once, like ``tip_racks=[tips1, tips2]``. .. _tutorial-commands: Commands ^^^^^^^^ Finally, all of your labware and hardware is in place, so it’s time to give the robot pipetting commands. The required steps of the serial dilution process break down into three main phases: 1. Measure out equal amounts of diluent from the reservoir to every well on the plate. 2. Measure out equal amounts of solution from the reservoir into wells in the first column of the plate. 3. Move a portion of the combined liquid from column 1 to 2, then from column 2 to 3, and so on all the way to column 12. Thanks to the flexibility of the API&apos;s :py:meth:`.transfer` method, which combines many :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` into one call, each of these phases can be accomplished with a single line of code! You’ll just have to write a few more lines of code to repeat the process for as many rows as you want to fill. Let’s start with the diluent. This phase takes a larger quantity of liquid and spreads it equally to many wells. ``transfer()`` can handle this all at once, because it accepts either a single well or a list of wells for its source and destination: .. code-block:: python left_pipette.transfer(100, reservoir[&quot;A1&quot;], plate.wells()) Breaking down these single lines of code shows the power of :ref:`complex commands &amp;lt;v2-complex-commands&amp;gt;`. The first argument is the amount to transfer to each destination, 100 µL. The second argument is the source, column 1 of the reservoir (which is still specified with grid-style coordinates as ``A1`` — a reservoir only has an A row). The third argument is the destination. Here, calling the :py:meth:`.wells` method of ``plate`` returns a list of *every well*, and the command will apply to all of them. .. image:: ../img/tutorial/diluent.gif :name: Transfer of diluent to plate :align: center :alt: Animation showing an empty well plate followed by the plate with diluent in every well. In plain English, you&apos;ve instructed the robot, “For every well on the plate, aspirate 100 µL of fluid from column 1 of the reservoir and dispense it in the well.” That’s how we understand this line of code as scientists, yet the robot will understand and execute it as nearly 200 discrete actions. Now it’s time to start mixing in the solution. To do this row by row, nest the commands in a ``for`` loop: .. code-block:: python for i in range(8): row = plate.rows()[i] Using Python&apos;s built-in :py:class:`range` class is an easy way to repeat this block 8 times, once for each row. This also lets you use the repeat index ``i`` with ``plate.rows()`` to keep track of the current row. .. image:: ../img/tutorial/row-tracking.gif :name: Tracking current row :align: center :alt: The well plate, with row A annotated as &quot;i = 0&quot;. In each row, you first need to add solution. This will be similar to what you did with the diluent, but putting it only in column 1 of the plate. It’s best to mix the combined solution and diluent thoroughly, so add the optional ``mix_after`` argument to ``transfer()``: .. code-block:: python left_pipette.transfer(100, reservoir[&quot;A2&quot;], row[0], mix_after=(3, 50)) As before, the first argument specifies to transfer 100 µL. The second argument is the source, column 2 of the reservoir. The third argument is the destination, the element at index 0 of the current ``row``. Since Python lists are zero-indexed, but columns on labware start numbering at 1, this will be well A1 on the first time through the loop, B1 the second time, and so on. The fourth argument specifies to mix 3 times with 50 µL of fluid each time. .. image:: ../img/tutorial/solution.gif :name: Solution added to A1 :align: center :alt: The well plate, with blue solution added to well A1. Finally, it’s time to dilute the solution down the row. One approach would be to nest another ``for`` loop here, but instead let’s use another feature of the ``transfer()`` method, taking lists as the source and destination arguments: .. code-block:: python left_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50)) There’s some Python shorthand here, so let’s unpack it. You can get a range of indices from a list using the colon ``:`` operator, and omitting it at either end means “from the beginning” or “until the end” of the list. So the source is ``row[:11]``, from the beginning of the row until its 11th item. And the destination is ``row[1:]``, from index 1 (column 2!) until the end. Since both of these lists have 11 items, ``transfer()`` will *step through them in parallel*, and they’re constructed so when the source is 0, the destination is 1; when the source is 1, the destination is 2; and so on. This condenses all of the subsequent transfers down the row into a single line of code. .. image:: ../img/tutorial/stepwise-transfer.gif :name: Stepwise transfer of solution down a row :align: center :alt: Animation showing transfer from A1 to A2, A2 to A3, and so on. Each step corresponds to an item in the source and destination lists. The color of liquid gets paler with each step from left to right. All that remains is for the loop to repeat these steps, filling each row down the plate. .. image:: ../img/tutorial/row-loop.gif :name: Looping over each row :align: center :alt: Animation showing each row of the plate being filled, from A (i = 0) to H (i = 7). That’s it! If you’re using a single-channel pipette, you’re ready to try out your protocol. 8-Channel Pipette ^^^^^^^^^^^^^^^^^ If you’re using an 8-channel pipette, you’ll need to make a couple tweaks to the single-channel code from above. Most importantly, whenever you target a well in row A of a plate with an 8-channel pipette, it will move its topmost tip to row A, lining itself up over the entire column. Thus, when adding the diluent, instead of targeting every well on the plate, you should only target the top row: .. code-block:: python left_pipette.transfer(100, reservoir[&quot;A1&quot;], plate.rows()[0]) And by accessing an entire column at once, the 8-channel pipette effectively implements the ``for`` loop in hardware, so you’ll need to remove it: .. code-block:: python row = plate.rows()[0] left_pipette.transfer(100, reservoir[&quot;A2&quot;], row[0], mix_after=(3, 50)) left_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50)) Instead of tracking the current row in the ``row`` variable, this code sets it to always be row A (index 0). Try Your Protocol ================= There are two ways to try out your protocol: simulation on your computer, or a live run on a Flex or OT-2. Even if you plan to run your protocol on a robot, it’s a good idea to check the simulation output first. If you get any errors in simulation, or you don&apos;t get the outcome you expected when running your protocol, you can check your code against these reference protocols on GitHub: - `Flex: Single-channel serial dilution &amp;lt;https://github.com/Opentrons/opentrons/blob/edge/api/docs/v2/example_protocols/dilution_tutorial_flex.py&amp;gt;`_ - `Flex: 8-channel serial dilution &amp;lt;https://github.com/Opentrons/opentrons/blob/edge/api/docs/v2/example_protocols/dilution_tutorial_multi_flex.py&amp;gt;`_ - `OT-2: Single-channel serial dilution &amp;lt;https://github.com/Opentrons/opentrons/blob/edge/api/docs/v2/example_protocols/dilution_tutorial.py&amp;gt;`_ - `OT-2: 8-channel serial dilution &amp;lt;https://github.com/Opentrons/opentrons/blob/edge/api/docs/v2/example_protocols/dilution_tutorial_multi.py&amp;gt;`_ .. _tutorial-simulate: In Simulation ------------- Simulation doesn’t require having a robot connected to your computer. You just need to install the `Opentrons Python module &amp;lt;https://pypi.org/project/opentrons/&amp;gt;`_ using pip (``pip install opentrons``). This will give you access to the ``opentrons_simulate`` command-line utility (``opentrons_simulate.exe`` on Windows). To see a text preview of the steps your Flex or OT-2 will take, use the change directory (``cd``) command to navigate to the location of your saved protocol file and run: .. prompt:: bash opentrons_simulate dilution-tutorial.py This should generate a lot of output! As written, the protocol has about 1000 steps. In fact, using a single-channel pipette for serial dilution across the whole plate will take about half an hour — plenty of time to grab a coffee while your robot pipettes for you! ☕️ If that’s too long, you can always cancel your run partway through or modify ``for i in range(8)`` to loop through fewer rows. On a Robot ---------- The simplest way to run your protocol on a Flex or OT-2 is to use the `Opentrons App &amp;lt;https://opentrons.com/ot-app&amp;gt;`_. When you first launch the Opentrons App, you will see the Protocols screen. (Click **Protocols** in the left sidebar to access it at any other time.) Click **Import** in the top right corner to reveal the Import a Protocol pane. Then click **Choose File** and find your protocol in the system file picker, or drag and drop your protocol file into the well. You should see “Protocol - Serial Dilution Tutorial” (or whatever ``protocolName`` you entered in the metadata) in the list of protocols. Click the three-dot menu (⋮) for your protocol and choose **Start setup**. If you have any remaining calibration tasks to do, you can finish them up here. Below the calibration section is a preview of the initial deck state. Optionally you can run Labware Position Check, or you can go ahead and click **Proceed to Run**. On the Run tab, you can double-check the Run Preview, which is similar to the command-line simulation output. Make sure all your labware and liquids are in the right place, and then click **Start run**. The run log will update in real time as your robot proceeds through the steps. When it’s all done, check the results of your serial dilution procedure — you should have a beautiful dye gradient running across the plate! .. image:: ../img/tutorial/serial-dilution-result.jpg :name: Result of Serial Dilution :align: center :alt: An overhead view of a well plate on the metal OT-2 deck, with dark blue liquid in the leftmost column smoothly transitioning to very light blue in the rightmost column. Next Steps ========== This tutorial has relied heavily on the ``transfer()`` method, but there&apos;s much more that the Python Protocol API can do. Many advanced applications use :ref:`building block commands &amp;lt;v2-atomic-commands&amp;gt;` for finer control over the robot. These commands let you aspirate and dispense separately, add air gaps, blow out excess liquid, move the pipette to any location, and more. For protocols that use :ref:`Opentrons hardware modules &amp;lt;new_modules&amp;gt;`, there are methods to control their behavior. And all of the API&apos;s classes and methods are catalogued in the :ref:`API Reference &amp;lt;protocol-api-reference&amp;gt;`.</content></file><file name="versioning.rst" type="rst"><content>:og:description: How to choose the right Python API version for your protocol. .. _v2-versioning: ********** Versioning ********** The Python Protocol API has its own versioning system, which is separate from the versioning system used for the robot software and the Opentrons App. This allows protocols to run on newer robot software versions without modification. Major and Minor Versions ======================== The API uses a major and minor version number and does not use patch version numbers. For instance, major version 2 and minor version 0 is written as ``2.0``. Versions are not decimal numbers, so ``2.10`` indicates major version 2 and minor version 10. The Python Protocol API version will only increase based on changes that affect protocol behavior. The major version of the API increases whenever there are significant structural or behavioral changes to protocols. For instance, major version 2 of the API was introduced because it required protocols to have a ``run`` function that takes a ``protocol`` argument rather than importing the ``robot``, ``instruments``, and ``labware`` modules. Protocols written with major version 1 of the API will not run without modification in major version 2. A similar level of structural change would require a major version 3. This documentation only deals with features found in major version 2 of the API; see the `archived version 1 documentation &amp;lt;https://docs.opentrons.com/v1/index.html&amp;gt;`_ for information on older protocols. The minor version of the API increases whenever there is new functionality that might change the way a protocol is written, or when a behavior changes in one aspect of the API but does not affect all protocols. For instance, adding support for a new hardware module, adding new parameters for a function, or deprecating a feature would increase the minor version of the API. .. _specifying-versions: Specifying Versions =================== You must specify the API version you are targeting in your Python protocol. In all minor versions, you can do this with the ``apiLevel`` key in the ``metadata`` dictionary, alongside any other metadata elements: .. code-block:: python :substitutions: from opentrons import protocol_api metadata = { &quot;apiLevel&quot;: &quot;|apiLevel|&quot;, &quot;author&quot;: &quot;A. Biologist&quot;} def run(protocol: protocol_api.ProtocolContext): protocol.comment(&quot;Hello, world!&quot;) From version 2.15 onward, you can specify ``apiLevel`` in the ``requirements`` dictionary instead: .. code-block:: python :substitutions: from opentrons import protocol_api metadata = {&quot;author&quot;: &quot;A. Biologist&quot;} requirements = {&quot;apiLevel&quot;: &quot;|apiLevel|&quot;, &quot;robotType&quot;: &quot;Flex&quot;} def run(protocol: protocol_api.ProtocolContext): protocol.comment(&quot;Hello, Flex!&quot;) Choose only one of these places to specify ``apiLevel``. If you put it in neither or both places, you will not be able to simulate or run your protocol. The version you specify determines the features and behaviors available to your protocol. For example, support for the Heater-Shaker Module was added in version 2.13, so you can&apos;t specify a lower version and then call ``HeaterShakerContext`` methods without causing an error. This protects you from accidentally using features not present in your specified API version, and keeps your protocol portable between API versions. When choosing an API level, consider what features you need and how widely you plan to share your protocol. Throughout the Python Protocol API documentation, there are version statements indicating when elements (features, function calls, available properties, etc.) were introduced. Keep these in mind when specifying your protocol&apos;s API version. Version statements look like this: .. versionadded:: 2.0 On the one hand, using the highest available version will give your protocol access to all the latest :ref:`features and fixes &amp;lt;version-notes&amp;gt;`. On the other hand, using the lowest possible version lets the protocol work on a wider range of robot software versions. For example, a protocol that uses the Heater-Shaker and specifies version 2.13 of the API should work equally well on a robot running version 6.1.0 or 6.2.0 of the robot software. Specifying version 2.14 would limit the protocol to robots running 6.2.0 or higher. .. _max-version: Maximum Supported Versions ========================== The maximum supported API version for your robot is listed in the Opentrons App under **Robots** &amp;gt; your robot &amp;gt; **Robot Settings** &amp;gt; **Advanced**. Before version 6.0.0 of the app, the same information was listed on your robot&apos;s **Information** card. If you upload a protocol that specifies a higher API level than the maximum supported, your robot won&apos;t be able to analyze or run your protocol. You can increase the maximum supported version by updating your robot software and Opentrons App. Opentrons robots running the latest software (8.3.0) support the following version ranges: * **Flex:** version 2.15–|apiLevel|. * **OT-2:** versions 2.0–|apiLevel|. .. _version-table: API and Robot Software Versions =============================== This table lists the correspondence between Protocol API versions and robot software versions. +-------------+------------------------------+ | API Version | Introduced in Robot Software | +=============+==============================+ | 2.22 | 8.3.0 | +-------------+------------------------------+ | 2.21 | 8.2.0 | +-------------+------------------------------+ | 2.20 | 8.0.0 | +-------------+------------------------------+ | 2.19 | 7.3.1 | +-------------+------------------------------+ | 2.18 | 7.3.0 | +-------------+------------------------------+ | 2.17 | 7.2.0 | +-------------+------------------------------+ | 2.16 | 7.1.0 | +-------------+------------------------------+ | 2.15 | 7.0.0 | +-------------+------------------------------+ | 2.14 | 6.3.0 | +-------------+------------------------------+ | 2.13 | 6.1.0 | +-------------+------------------------------+ | 2.12 | 5.0.0 | +-------------+------------------------------+ | 2.11 | 4.4.0 | +-------------+------------------------------+ | 2.10 | 4.3.0 | +-------------+------------------------------+ | 2.9 | 4.1.0 | +-------------+------------------------------+ | 2.8 | 4.0.0 | +-------------+------------------------------+ | 2.7 | 3.21.0 | +-------------+------------------------------+ | 2.6 | 3.20.0 | +-------------+------------------------------+ | 2.5 | 3.19.0 | +-------------+------------------------------+ | 2.4 | 3.17.1 | +-------------+------------------------------+ | 2.3 | 3.17.0 | +-------------+------------------------------+ | 2.2 | 3.16.0 | +-------------+------------------------------+ | 2.1 | 3.15.2 | +-------------+------------------------------+ | 2.0 | 3.14.0 | +-------------+------------------------------+ | 1.0 | 3.0.0 | +-------------+------------------------------+ .. _version-notes: Changes in API Versions ======================= Version 2.22 ------------- This version includes beta features for our commercial partners. Version 2.21 ------------ - Adds :py:class:`.AbsorbanceReaderContext` to support the :ref:`Absorbance Plate Reader Module &amp;lt;absorbance-plate-reader-module&amp;gt;`. Use the load name ``absorbanceReaderV1`` with :py:meth:`.ProtocolContext.load_module` to add an Absorbance Plate Reader to a protocol. - :ref:`Liquid presence detection &amp;lt;lpd&amp;gt;` now only checks on the first aspiration of the :py:meth:`.mix` cycle. - Improved the run log output of :py:meth:`.ThermocyclerContext.execute_profile`. Version 2.20 ------------ - Detect liquid presence within a well. The :py:meth:`.InstrumentContext.detect_liquid_presence()` and :py:meth:`.InstrumentContext.require_liquid_presence()` building block commands check for liquid any point in your protocol. You can also :ref:`enable liquid presence detection &amp;lt;lpd&amp;gt;` for all aspirations when loading a pipette, although this will add significant time to your protocol. - Define CSV runtime parameters and use their contents in a protocol with new :ref:`data manipulation methods &amp;lt;rtp-csv-data&amp;gt;`. See the :ref:`cherrypicking use case &amp;lt;use-case-cherrypicking&amp;gt;` for a full example. - :py:meth:`.configure_nozzle_layout` now accepts row, single, and partial column layout constants. See :ref:`partial-tip-pickup`. - You can now call :py:obj:`.ProtocolContext.define_liquid()` without supplying a ``description`` or ``display_color``. Version 2.19 ------------ Opentrons recommends updating protocols from ``apiLevel`` 2.18 to 2.19 to take advantage of improved pipetting behavior. - This version uses new values for how much a tip overlaps with the pipette nozzle when the pipette picks up tips. This can correct errors caused by the robot positioning the tip slightly lower than intended, potentially making contact with labware. See :py:meth:`.pick_up_tip` for additional details. Version 2.18 ------------ - Define customizable parameters with the new ``add_parameters()`` function, and access their values on the :py:obj:`.ProtocolContext.params` object during a protocol run. See :ref:`runtime-parameters` and related pages for more information. - Move the pipette to positions relative to the top of a trash container. See :ref:`position-relative-trash`. The default behavior of :py:meth:`.drop_tip` also accounts for this new possibility. - :py:meth:`.set_offset` has been restored to the API with new behavior that applies to labware type–location pairs. - Automatic tip tracking is now available for all nozzle configurations. Version 2.17 ------------ - :py:meth:`.dispense` now raises an error if you try to dispense more than :py:obj:`.InstrumentContext.current_volume`. Version 2.16 ------------ This version introduces new features for Flex and adds and improves methods for aspirating and dispensing. Note that when updating Flex protocols to version 2.16, you *must* load a trash container before dropping tips. - New features - Use :py:meth:`.configure_nozzle_layout` to pick up a single column of tips with the 96-channel pipette. See :ref:`Partial Tip Pickup &amp;lt;partial-tip-pickup&amp;gt;`. - Specify the trash containers attached to your Flex with :py:meth:`.load_waste_chute` and :py:meth:`.load_trash_bin`. - Dispense, blow out, drop tips, and dispose labware in the waste chute. Disposing labware requires the gripper and calling :py:meth:`.move_labware` with ``use_gripper=True``. - Perform actions in staging area slots by referencing slots A4 through D4. See :ref:`deck-slots`. - Explicitly command a pipette to :py:meth:`.prepare_to_aspirate`. The API usually prepares pipettes to aspirate automatically, but this is useful for certain applications, like pre-wetting routines. - Improved features - :py:meth:`.aspirate`, :py:meth:`.dispense`, and :py:meth:`.mix` will not move any liquid when called with ``volume=0``. - Other changes - :py:obj:`.ProtocolContext.fixed_trash` and :py:obj:`.InstrumentContext.trash_container` now return :py:class:`.TrashBin` objects instead of :py:class:`.Labware` objects. - Flex will no longer automatically drop tips in the trash at the end of a protocol. You can add a :py:meth:`.drop_tip()` command to your protocol or use the Opentrons App to drop the tips. Version 2.15 ------------ This version introduces support for the Opentrons Flex robot, instruments, modules, and labware. - Flex features - Write protocols for Opentrons Flex by declaring ``&quot;robotType&quot;: &quot;Flex&quot;`` in the new ``requirements`` dictionary. See the :ref:`examples in the Tutorial &amp;lt;tutorial-requirements&amp;gt;`. - :py:meth:`.load_instrument` supports loading Flex 1-, 8-, and 96-channel pipettes. See :ref:`new-create-pipette`. - The new :py:meth:`.move_labware` method can move labware automatically using the Flex Gripper. You can also move labware manually on Flex. - :py:meth:`.load_module` supports loading the :ref:`Magnetic Block &amp;lt;magnetic-block&amp;gt;`. - The API does not enforce placement restrictions for the Heater-Shaker module on Flex, because it is installed below-deck in a module caddy. Pipetting restrictions are still in place when the Heater-Shaker is shaking or its labware latch is open. - The new :py:meth:`.configure_for_volume` method can place Flex 50 µL pipettes in a low-volume mode for dispensing very small volumes of liquid. See :ref:`pipette-volume-modes`. - Flex and OT-2 features - Optionally specify ``apiLevel`` in the new ``requirements`` dictionary (otherwise, specify it in ``metadata``). - Optionally specify ``&quot;robotType&quot;: &quot;OT-2&quot;`` in ``requirements``. - Use coordinates or numbers to specify :ref:`deck slots &amp;lt;deck-slots&amp;gt;`. These formats match physical labels on Flex and OT-2, but you can use either system, regardless of ``robotType``. - The new module context ``load_adapter()`` methods let you load adapters and labware separately on modules, and :py:meth:`.ProtocolContext.load_adapter` lets you load adapters directly in deck slots. See :ref:`labware-on-adapters`. - Move labware manually using :py:meth:`.move_labware`, without having to stop your protocol. - Manual labware moves support moving to or from the new :py:obj:`~.protocol_api.OFF_DECK` location (outside of the robot). - :py:meth:`.ProtocolContext.load_labware` also accepts :py:obj:`~.protocol_api.OFF_DECK` as a location. This lets you prepare labware to be moved onto the deck later in a protocol. - The new ``push_out`` parameter of the :py:meth:`.dispense` method helps ensure that the pipette dispenses all of its liquid when working with very small volumes. - By default, repeated calls to :py:meth:`.drop_tip` cycle through multiple locations above the trash bin to prevent tips from stacking up. - Bug fixes - :py:attr:`.InstrumentContext.starting_tip` is now respected on the second and subsequent calls to :py:meth:`.InstrumentContext.pick_up_tip` with no argument. Version 2.14 ------------ This version introduces a new protocol runtime that offers more reliable run control and builds a strong foundation for future Protocol API improvements. Several older parts of the Protocol API were deprecated as part of this switchover. If you specify an API version of ``2.13`` or lower, your protocols will continue to execute on the old runtime. - Feature additions - :py:meth:`.ProtocolContext.define_liquid` and :py:meth:`.Well.load_liquid` added to define different liquid types and add them to wells, respectively. - Bug fixes - :py:class:`.Labware` and :py:class:`.Well` now adhere to the protocol&apos;s API level setting. Prior to this version, they incorrectly ignored the setting. - :py:meth:`.InstrumentContext.touch_tip` will end with the pipette tip in the center of the well instead of on the edge closest to the front of the machine. - :py:meth:`.ProtocolContext.load_labware` now prefers loading user-provided labware definitions rather than built-in definitions if no explicit ``namespace`` is specified. - :py:meth:`.ProtocolContext.pause` will now properly wait until you resume the protocol before moving on. In previous versions, the run will not pause until the first call to a different ``ProtocolContext`` method. - Motion planning has been improved to avoid certain erroneous downward movements, especially when using :py:meth:`.InstrumentContext.aspirate`. - :py:meth:`.Labware.reset` and :py:attr:`.Labware.tip_length` will raise useful errors if called on labware that is not a tip rack. - Removals - The ``presses`` and ``increment`` arguments of :py:meth:`.InstrumentContext.pick_up_tip` were deprecated. Configure your pipette pick-up settings with the Opentrons App, instead. - ``InstrumentContext.speed`` property was removed. This property tried to allow setting a pipette&apos;s **plunger** speed in mm/s. However, it could only approximately set the plunger speed, because the plunger&apos;s speed is a stepwise function of the volume. Use :py:attr:`.InstrumentContext.flow_rate` to set the flow rate in µL/s, instead. - ``load_labware_object()`` was removed from module contexts as an unnecessary internal method. - ``geometry`` was removed from module contexts in favor of ``model`` and ``type`` attributes. - ``Well.geometry`` was removed as unnecessary. - ``MagneticModuleContext.calibrate`` was removed since it was never needed nor implemented. - The ``height`` parameter of :py:meth:`.MagneticModuleContext.engage` was removed. Use ``offset`` or ``height_from_base`` instead. - ``Labware.separate_calibration`` and :py:meth:`.Labware.set_calibration` were removed, since they were holdovers from a calibration system that no longer exists. - Various methods and setters were removed that could modify tip state outside of calls to :py:meth:`.InstrumentContext.pick_up_tip` and :py:meth:`.InstrumentContext.drop_tip`. This change allows the robot to track tip usage more completely and reliably. You may still use :py:meth:`.Labware.reset` and :py:meth:`.InstrumentContext.reset_tipracks` to reset your tip racks&apos; state. - The :py:attr:`.Well.has_tip` **setter** was removed. **The getter is still supported.** - Internal methods ``Labware.use_tips``, ``Labware.previous_tip``, and ``Labware.return_tips`` were removed. - The ``configuration`` argument of :py:meth:`.ProtocolContext.load_module` was removed because it made unsafe modifications to the protocol&apos;s geometry system, and the Thermocycler&apos;s &quot;semi&quot; configuration is not officially supported. - Known limitations - :py:meth:`.Labware.set_offset` is not yet supported on this API version. Run protocols via the Opentrons App, instead. - :py:attr:`.ProtocolContext.max_speeds` is not yet supported on the API version. Use :py:attr:`.InstrumentContext.default_speed` or the per-method `speed` argument, instead. - :py:attr:`.InstrumentContext.starting_tip` is not respected on the second and subsequent calls to :py:meth:`.InstrumentContext.pick_up_tip` with no argument. Version 2.13 ------------ - Adds :py:class:`.HeaterShakerContext` to support the Heater-Shaker Module. You can use the load name ``heaterShakerModuleV1`` with :py:meth:`.ProtocolContext.load_module` to add a Heater-Shaker to a protocol. - :py:meth:`.InstrumentContext.drop_tip` now has a ``prep_after`` parameter. - :py:meth:`.InstrumentContext.home` may home *both* pipettes as needed to avoid collision risks. - :py:meth:`.InstrumentContext.aspirate` and :py:meth:`.InstrumentContext.dispense` will avoid interacting directly with modules. Version 2.12 ------------ - :py:meth:`.ProtocolContext.resume` has been deprecated. - :py:meth:`.Labware.set_offset` has been added to apply labware offsets to protocols run (exclusively) outside of the Opentrons App (Jupyter Notebook and SSH). Version 2.11 ------------ - Attempting to aspirate from or dispense to tip racks will raise an error. Version 2.10 ------------ - Moving to the same well twice in a row with different pipettes no longer results in strange diagonal movements. Version 2.9 ----------- - You can now access certain geometry data regarding a labware&apos;s well via a Well Object. See :ref:`new-labware-well-properties` for more information. Version 2.8 ----------- - You can now pass in a list of volumes to distribute and consolidate. See :ref:`distribute-consolidate-volume-list` for more information. - Passing in a zero volume to any :ref:`complex command &amp;lt;v2-complex-commands&amp;gt;` will result in no actions taken for aspirate or dispense - :py:meth:`.Well.from_center_cartesian` can be used to find a point within a well using normalized distance from the center in each axis. - Note that you will need to create a location object to use this function in a protocol. See :ref:`protocol-api-labware` for more information. - You can now pass in a blowout location to transfer, distribute, and consolidate with the ``blowout_location`` parameter. See :py:meth:`.InstrumentContext.transfer` for more detail! Version 2.7 ----------- - Added ``InstrumentContext.pair_with()``, an experimental feature for moving both pipettes simultaneously. .. note:: This feature has been removed from the Python Protocol API. - Calling :py:meth:`.InstrumentContext.has_tip` will return whether a particular instrument has a tip attached or not. Version 2.6 ----------- - GEN2 Single pipettes now default to flow rates equivalent to 10 mm/s plunger speeds - Protocols that manually configure pipette flow rates will be unaffected - For a comparison between API Versions, see :ref:`ot2-flow-rates` Version 2.5 ----------- - New :ref:`utility commands &amp;lt;new-utility-commands&amp;gt;` were added: - :py:meth:`.ProtocolContext.set_rail_lights`: turns robot rail lights on or off - :py:obj:`.ProtocolContext.rail_lights_on`: describes whether or not the rail lights are on - :py:obj:`.ProtocolContext.door_closed`: describes whether the robot door is closed Version 2.4 ----------- - The following improvements were made to the ``touch_tip`` command: - The speed for ``touch_tip`` can now be lowered down to 1 mm/s - ``touch_tip`` no longer moves diagonally from the X direction -&amp;gt; Y direction - Takes into account geometry of the deck and modules Version 2.3 ----------- - Magnetic Module GEN2 and Temperature Module GEN2 are now supported; you can load them with the names ``&quot;magnetic module gen2&quot;`` and ``&quot;temperature module gen2&quot;``, respectively. - All pipettes will return tips to tip racks from a higher position to avoid possible collisions. - During a :py:meth:`.mix`, the pipette will no longer move up to clear the liquid in between every dispense and following aspirate. - You can now access the Temperature Module&apos;s status via :py:obj:`.TemperatureModuleContext.status`. Version 2.2 ----------- - You should now specify Magnetic Module engage height using the ``height_from_base`` parameter, which specifies the height of the top of the magnet from the base of the labware. For more, see :ref:`magnetic-module-engage`. - Return tip will now use pre-defined heights from hardware testing. For more information, see :ref:`pipette-return-tip`. - When using the return tip function, tips are no longer added back into the tip tracker. For more information, see :ref:`pipette-return-tip`. Version 2.1 ----------- - When loading labware onto a module, you can now specify a label with the ``label`` parameter of :py:meth:`.MagneticModuleContext.load_labware`, :py:meth:`.TemperatureModuleContext.load_labware`, or :py:meth:`.ThermocyclerContext.load_labware`, just like you can when loading labware onto the deck with :py:meth:`.ProtocolContext.load_labware`. Version 2.0 ----------- Version 2 of the API is a new way to write Python protocols, with support for new modules like the Thermocycler. To transition your protocols from version 1 to version 2 of the API, follow this `migration guide &amp;lt;http://support.opentrons.com/en/articles/3425727-switching-your-protocols-from-api-version-1-to-version-2&amp;gt;`_. We&apos;ve also published a `more in-depth discussion &amp;lt;http://support.opentrons.com/en/articles/3418212-opentrons-protocol-api-version-2&amp;gt;`_ of why we developed version 2 of the API and how it differs from version 1.</content></file></directory>